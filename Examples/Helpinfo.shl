extras sg Silicon Graphics framestore display cache unix binary file format
Semper on a Silicon Graphics workstation supports the following features in
addition to the standard image processing facilities:

Command interface
-----------------

A scrolling terminal window is created on the screen pointed to by the
environment variable DISPLAY.  You can enter commands into this window and the
command line whenever it (or any other window created by Semper) has input
focus.  Previous commands can be recalled by pressing the up and down cursor
keys.  Characters can be inserted by first pressing the insert key or
Control-A.

Processing of commands can be abandoned by pressing Control-C.

You can specify the font and the foreground/background colours for the terminal
window by setting the environment varibles SEMPER_FONT, SEMPER_FG and SEMPER_BG
respectively.  Set SEMPER_FONT to the desired font name.  The font must be
fixed width.  Use the X11 command "xlsfonts" to find out what fixed width fonts
are available on your system.  SEMPER_FG and SEMPER_BG can be set to X11 colour
names (e.g. "black", "white", "slate blue", etc.) or to hexadecimal colour
specification strings.  Type the following Unix commands to make the font and
foreground/background colours the same as the workstation's Unix shell window:

    setenv SEMPER_FONT Screen15
    setenv SEMPER_FG   #d6d6d6
    setenv SEMPER_BG   #00003f

Image display window
--------------------

You can create a separate window for displaying images with the ASSIGN DISPLAY
command.  The window emulates a framestore.  You can display monochrome, false
colour and full colour images, depending on the graphics capapbilities of the
workstation.  There is support for 8 independent overlays for displaying
graphical output, rubberband lines and a cursor.  You can control the colour
and visibilty of each overlay with the OVERLAY command.

Menu interface window
---------------------

A separate window for displaying menus is created as required.  The window
supports up to 8 different menu colours.

Caching data in memory
----------------------

By default, all disc i/o associated with Semper's data storage devices
(picture discs, program libraries and help libraries) is cached in Semper's
disc cache in order to speed up access to the data.  The CACHE command allows
you to control the size and configuration of Semper's disc cache (you can even
turn off the disc cache by setting the size of the cache to zero) and to
create a separate memory buffer to cache all of the data in a Semper storage
device (MEMORY option).  You can also create temporary memory-based devices
with the ASSIGN MEMORY command.

Executing Unix commands
-----------------------

You can execute non-interactive Unix commands from within a Semper session
with the UNIX command.  Any text sent to standard output will be redirected to
Semper's console output stream.  All dependent processes will br terminated if
the UNIX command is abandoned.

Image file formats
------------------

The commands INPUT, OUTPUT, IPUT, IGET, EPUT, EGET, SPUT, SGET, ZPUT, ZGET and
HPLJ allow you to handle images in various file formats, in particular
Semper's binary image file format and Sun's raster file format (INPUT and
OUTPUT) and Silicon Graphics' image file format (IPUT and IGET).  The OUTPUT
command will also write grey-scale TIFF files.  The HPLJ command outputs
images to file in Hewlett-Packard's Laserjet format.

Frame grabber support
---------------------

If your workstation has an Imaging Technology FG100 frame grabber installed,
you can capture live images from a camera with the GRAB command.  The commands
VIDEO and ILUT allow you to configure the operation of the frame grabber.

Host-specific commands
----------------------

Here is a list of the commands which are specific to your Semper installation.
Consult the documentation for these commands for more details about their
operation.

    ASSIGN DISPLAY
    OVERLAY
    X11
    CACHE
    UNIX
    INPUT, OUTPUT
    EPUT, EGET
    IPUT, IGET
    SPUT, SGET
    ZPUT, ZGET
    HPLJ
    GRAB, ILUT, VIDEO
$add assign.display.command assign.display assign X framestore display window
You use the ASSIGN DISPLAY command to create a display window for displaying
images.  The display window emulates the functioning of a framestore: storing
image data in the framestore causes the image to be displayed on the screen.
The colours and intensities used to display images are determined by a display
look-up table.  There is also support for a number of overlays for displaying
graphical data, a cursor and rubberband lines on top of images.  The size of
the framestore is specified with the SIZE and FRAMES keys.  Use the command
DEASSIGN DISPLAY to destroy the display window.

Exx:  ASSIGN DISPLAY
        create a false colour display window with the default size of
        768 by 512 pixels
      ASSIGN DISPLAY SIZE 400 POSITION 0,0
        create a display window with size 400 by 400 pixels, positioned at
        the top left-hand corner of the screen
      ASSIGN DISPLAY FRAMES 3
        create a display window with 3 frames for displaying full colour
        images (if the X server supports this)
$
The ASSIGN DISPLAY command assigns the display device to emulate a framestore
with a frame size given by the SIZE key and the number of frames given by the
FRAMES key.  If the SIZE key is omitted, the frame size defaults to 768 by 512
pixels.  If the Y dimension is omitted, it defaults to the X dimension.  The
largest frame size allowed is 16384 by 16384 pixels.  The initial size of the
display window is limited to three-quarters of the screen dimensions.  The
display window may be repositioned at any time and resized within the limits
imposed by the screen and the window manager.  The initial position of the
display window may be specified with the POSITION key (the default is to
position the window at the top left-hand corner of the screen).  If the window
manager allows it, the window will be positioned as specified.  Failing that,
the window will have to be manually positioned.

If the display window is not large enough to display the entire frame, the
view position can be altered with the VIEW command.  The view position is the
frame position which appears at the centre of the display window.  The default
for the view poistion is the centre of the frame.  The XWIRES command also
provides the facility (enabled by pressing the V key) to make the view
position track the movement of the cursor.  This allows you to roam freely
around a very large frame.

Image data associated with each display frame and overlay data is separately
stored in memory buffers so that the information can always be accessed,
regardless of the visibility of the displayed image.  The image data is stored
with a maximum resolution of 8 bits (256 levels): the actual resolution
depends on the depth of any PseudoColor and GrayScale visuals supported by the
X server (use the X command "xdpyinfo" to list the supported visuals).  The
minimum suitable depth is 6 bits.  The PseudoColor visual with the greatest
depth is used in preference to the GrayScale visual with the greatest depth.
If no suitable visuals are supported, the ASSIGN command will fail.  If the
depth of the selected visual is greater than 8 bits, the full 256 levels of
image data can be stored and displayed.  The number of display levels (which
is equal to the look-up table size) is listed by the SHOW SYSTEM command and
returned in the variable LSIZE by the command LUT ENQUIRE.

The FRAMES key determines the number of display frames.  The only acceptable
values are 1 (the default) and 3.  You can display monochrome and false colour
images with a single frame.  In order to display full colour images (RGB
pictures with three layers), you must assign three display frames.  The X
server must support a 24-bit TrueColor visual for this to succeed.  Full
colour look-up tables are supported by repainting the display window whenever
changes are made to the current look-up table (the variable CLUT records the
current look-up table number).  You will also have to create a partition with
3 frames in order to display RGB images, for example,

    ASSIGN DISPLAY FRAMES 3
    PARTITION 1 FRAMES 1,3
    DISPLAY 2:1 TO DIS:1

The resolution for each component of a full colour image (the number of levels
and the look-up table size) is the same as for a false colour image.

A total of 8 overlays are supported.  You can control the visibility and
colour of overlays with the OVERLAY command.  The overlays are numbered from 1
to 8 and where overlay data overlaps, the highest numbered overlay is
displayed.  Cursor and rubberbanding functions are carried out using one
overlay each.  Different overlays must be used for displaying graphics, cursor
and rubberbanding.  The display window is repainted whenever an overlay is
turned on of off and when the colour of an overlay for a full colour display
changes.

Interactive input is possible when the display window (or any other window
created by Semper) has input focus.  If during a command which tracks the
pointer (for example, LADJUST), the pointer leaves the window, no further
tracking will take place until it rejoins the window.  Since pointer movement
is handled incrementally, you can obtain more movement than the window allows
by circling the pointer around the outside of the window and dragging it
across the window in the same direction as before.

When image or graphics data is output by a Semper command it is immediately
stored in the memory buffers associated with the display window.  By default,
the display window is updated less often than the memory buffers in order to
reduce the overhead in communicating with the X server.  The rate at which the
display window is updated is controlled with the X11 command.

See also: assign.display.syntax, deassign, overlay, x11, lut, ladjust, view,
          show
$add assign.display.syntax
Keys:
  SIZE(2)        frame size in pixels [768,512]
  FRAMES         number of frames [1]
  POSITION       initial position of the top left-hand corner of the window
                 with respect to the top left-hand of the screen [0,0]

Options:
  DISPLAY        assign the display device

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add cache.command cache disc access buffer virtual memory
You use the CACHE command to manage the way in which disc I/O is buffered in
memory.  This can lead to significant reductions in the amount of data traffic
to and from the hard disc and it can reduce the total number of I/O requests.
Data from a disc device can be buffered in a separate memory buffer allocated
to that device or it can be buffered in Semper's disc cache.  The disc cache
is a collection of memory buffers which are shared between all the disc
devices which are not separately buffered.  With the CACHE command you can
allocate and free separate memory buffers, display/change the number and size
of cache buffers and you can force buffered data to be flushed out to disc.

Exx: CACHE SHOW
       lists the current disc cache settings - number of cache buffers,
       buffer size and total cache size
     CACHE NUMBER 200
       changes the number of cache buffers to 200, keeping the buffer size the
       same
     CACHE NUMBER 20 SIZE 65536
       reconfigures the cache to consist of 20 buffers of 65536 bytes each
       giving a total cache size of 1310720 bytes
     CACHE NUMBER 0
       frees all cache buffers, effectively turning off disc caching
     CACHE FLUSH
       causes all data modified in the cache to be written to disc
     CACHE DEVICE 2 FLUSH
       causes all modified data associated with device 2 to be written to disc
     CACHE DEVICE 3 MEMORY
       causes all data in device 3 to be buffered in a separate dynamically
       allocated memory buffer
     CACHE DEVICE 3 FREE
       flushes and frees separate buffer associated with device 3
$
Data can be buffered, either in one or more cache buffers which are drawn from
a pool of cache buffers (the disc cache), or else in a buffer which is
permanently allocated to the file with which the data is associated.  The
first approach allows you to make optimum use of limited memory resources by
only caching data which needs to be accessed amongst all the disc files that
are currently open.  The second approach reduces actual disc i/o to an
absolute minimum - data is read in once only, and written out when the buffer
is flushed or freed.  On systems which support virtual memory, you must always
keep in mind the possibility that buffered data will be paged onto disc when
the amount of allocated virtual memory exceeds the amount of real physical
memory.

With the CACHE command you can, at any time, allocate and then free a separate
memory buffer for any disc device which is currently assigned.  You specify
the device number with the DEVICE key and you allocate or free the memory
buffer by specifying the MEMORY or FREE options respectively.  The device
number is determined by the ASSIGN command when you open the disc file.  When
such a buffer is allocated, all the data on disc is read just once into
memory.  All subsequent access to the data is made via the memory buffer,
thereby avoiding all disc I/O, until the buffer is freed or flushed.

There is no point in using the MEMORY option with a temporary or scratch disc
file unless you specifically intend to use the FREE option later during the
same Semper session.  If you do not intend to free the memory buffer before
closing and deleting the file, you may as well use the ASSIGN MEMORY command
to open a memory-based device which will not tie up space on the hard disc.

The CACHE command allows you to control the number and size of cache buffers
which make up the disc cache.  The buffer size must be at least a multiple of
8 bytes and, on some systems, it may also have to be a multiple of the
operating system's page size or some other unit of size.  The CACHE SHOW
command will list any constraints on the buffer size.

Semper will automatically create a certain size of disc cache at the start of
a session.  The default size of the cache will vary according to the host
system, but it should at least give reasonably good performance when
processing medium sized images.  Even when the cache is not large enough to
hold all the data being processed by a particular Semper command, the disc
cache can still provide some performance benefits because it reduces the
number of I/O requests.  On some systems, each I/O request can incur large
operating system overheads.

If the number of buffers or the buffer size is set to zero, disc caching is
disabled and disc data will be accessed directly from the hard disc.

On systems which support virtual memory, the size of the disc cache needs to
be managed so that it is not so large that it puts too heavy a burden on the
operating system.  If the size of the cache exceeds the amount of free
physical memory, data will be swapped out of memory to make room.  If this
leads to the point where the code for active processes has to be swapped out,
the performance of the whole system will suffer.


Some indication of the demands being made for memory can be got by invoking
the Unix command "gr_osview -a".  This continuously displays CPU activity and
memory usage in graphical form.

On systems which do not support virtual memory, the size of the disc cache
will be limited by the amount of available memory.  Also, allocating all of
the available memory to the disc cache may cause problems elsewhere when
further requests to allocate memory are refused.

With the FLUSH option you can cause all modified data in the cache to be
written to disc.  With the DEVICE key, you can restrict the operation of the
FLUSH option to a specified disc device.  Reconfiguring the disc cache causes
its contents to be written to disc, as if the FLUSH option had been specified.
If the disc cache is large, this could take a noticeable length of time.
Likewise, when a disc device is deassigned, its contents are flushed out to
disc, except when the file is to be deleted (either because the DELETE option
was specified in the DEASSIGN command or because the device is a temporary or
scratch disc).

The FLUSH command has the same effect as using the CACHE FLUSH command.

The SHOW option causes the current disc cache parameters to be listed on the
console output stream.

See also: cache.syntax, assign, deassign, flush
$add cache.syntax
Keys:
  NUMBER         number of cache buffers [current value]
  SIZE           cache buffer size (bytes) [current value]
  DEVICE         disc device number for use with FLUSH, MEMORY or FREE options

Options:
  FLUSH          flush contents of cache buffer or specified device to disc
  MEMORY         allocate permanent memory buffer for specified device
  FREE           free memory buffer associated with specified device
  SHOW           list current settings for disc cache parameters

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add input.command input read get files BMP TIFF OPTRONICS
You use INPUT to read pictures created by Semper 6 on workstations or PCs
(using the OUTPUT command) or by other selected programs.

Exx: INPUT 5 NAME 'newdata'
       reads picture 5 from the Semper 6 file newdata.pic
     INPUT 125 RAW NAME 'binary' SIZE 512,512
       reads picture 125, of size 512 by 512 pixels from the raw binary
       file binary.bin
     INPUT 33 RAW INTEGER NAME 'mydata' SIZE 640,480 SWAP
       reads picture 33, of size 640 by 480 pixels as 16 bit integers with
       Motorola byte ordering from the file mydata.bin
     INPUT 1 RAW NAME 'special.pic' SIZE 128,128 SKIP 64
       reads picture 1, of size 128 by 128 pixels from the raw binary file
       special.pic, skipping the first 64 bytes of the file
     INPUT 1 RASTER NAME 'dump.rff' MAP 2
       reads SunRaster file dump.rff into picture 1, storing any colourmap
       information in picture 2
     INPUT 1 BMP NAME 'windows.bmp' MAP 2
       reads Windows BitMap file windows.bmp into picture 1, storing any
       colourmap information in picture 2
     INPUT 1 TIFF NAME 'macphoto.tif' MAP 2
       reads TIFF file macphoto.tif into picture 1, storing any colourmap
       information in picture 2
     INPUT 1 OPTRONICS NAME 'NU.img'
       reads an Optronics scanning image (Northwestern)
$
INPUT expects a Semper 6 data file unless one of the options BMP, RASTER, RAW
OPTRONICS or TIFF are given.

If the option BMP is given, the input file is treated as a Windows BitMap
image file. Currently only files with 8 or 24 bits per pixel are accepted.
Only uncompressed images are supported (not RLE compression).

If the option RASTER is given, the input file is treated as a Sun Raster
image file. Currently only files with 8 bits per pixel are accepted. The
file packing types supported are the old and new unpacked types 0 (RT_OLD)
and 1 (RT_STANDARD), and also the byte encoded type 2 (RT_BYTE_ENCODED).

If the option RAW is given, a raw binary file is expected, of size given by
SIZE(3), with bytes starting with the top left pixel of layer 1, reading along
the row.

If the option OPTRONICS (OPT) is given, a byte image from the NU Optronics
scanner is produced.

If the option TIFF is given, the input file is treated as a TIFF image file.
Both the Intel and Motorola packing orders are supported - most Apple
Macintosh packages produce the Motorola form, Windows packages the Intel form.
Currently only greyscale and RGB files with 8 bits per sample are accepted.
Only uncompressed images are supported (not LZW, PackBits or any other
compression scheme). Both planar and packed RGB images can be read.
Semper ignores Grey and Colour response correction curves, as these require
unsigned 16 bit pixels, which Semper does not directly support.
Any text fields found (e.g Author, Software, Manufacturer etc.) are reported
to the console output, as are any significant TIFF Tags that are not
supported. These messages can be suppressed using the NOVERIFY option.

If the keyword MAP is given with the options BMP, RASTER or TIFF it is
treated as a picture number in which to store any colourmap data present
in the file. This information can be used to remap the image data read in
using the Semper MAP or COLOUR commands. For instance, for a SunRaster image,
if the map data has 3 rows (RGB colormap) you can remap the original image
as follows:

      INPUT 1 RASTER NAME 'myfile.rff' MAP 2   ; ! read the data
      COLOUR 1 TO 3 WITH 2                     ; ! create the RGB image

The map information can also be used as a look-up table (LUT) if the LUT
length of the display system is 256 (use SHOW SYSTEM), but the image will
only be displayed with the correct false colours if the pixel range is not
rescaled (option NOSCALE to the DISPLAY command). For example:

      INPUT 1 BMP NAME 'windows.bmp' MAP 2      ; ! read the data
      LUT 1 FROM 2; PARTITION 1 LUT 1           ; ! prepare the LUT
      DISPLAY 1 TO DISPLAY:1 NOSCALE            ; ! display the palette image

The default extension for Semper 6 files is .pic, for Raster files is .rff,
for BitMap files .bmp, for TIFF files .tif and for raw binary is .bin.

The byte ordering for the Semper 6 data file is little-endian (Intel format).
Files written using the OUTPUT command on a PC can be read into a workstation
linked over a PC-NFS type network.

The depth of raw binary can be specified using the form options BYTE, INTEGER,
FP and COMPLEX. The SWAP option specifies that the binary data uses the
Motorola packing format. The SKIP keyword specifies the offset (in bytes) of
the start of the data - this is useful for skipping known size headers.

The AGAIN option can be used to read the last file again without having to
give a filename. (Provided no files have been written since). This option is
most useful in library procedures used to unpick foreign files formats, and is
generally used together with the RAW and SKIP options. For instance to read
a file MYSTYLE.BIN consisting of two 16 bit values giving the size and then
the raw data in bytes:

           INPUT 999 RAW NAME 'MYSTYLE' SIZE 2,1 INTEGER
           ORIGIN LEFT; DX = P(0); DY = P(1)
           INPUT 999 RAW AGAIN SIZE DX,DY BYTE SKIP 4

Files are searched for in the current directory and then throughout the
PATH (see FILEPATH and SHOW PATH). You can give a full path name to avoid
the path scan.

See also: input.syntax output read write colour
$add input.syntax
Keys:
  [TO]            picture to be read [SELECT]
  NAME text       name of file containing picture data  [none; prompts if
                  interactive unless AGAIN is given]

  SIZE(3)         specifies the size of a raw binary data image [none]

  SKIP            the byte offset of the start of the data within the file [0]

  MAP             picture to hold Sun Raster colormap data

Options:
  BMP             read an uncompressed Windows BitMap file
  RASTER          read a Sun Raster file
  RAW             read a raw binary data file
  TIFF            read an uncompressed TIFF file

  NOVERIFY        suppress informational messages (TIFF only)

  SWAP            read data in Motorola byte order (RAW only)

  AGAIN           use NAME given in last file read

  BYTE | INTEGER | read data as byte (8 bit), integer (16 bit), floating
  FP | COMPLEX     or complex

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add output.command output write put files TIFF BMP
You use OUTPUT to output pictures in one of several fast binary forms.

Exx: OUTPUT 23 NAME 'binary' UNLABELLED
       writes picture 23 to the file binary.pic, excluding the picture label
     OUTPUT 12 RAW BYTE NAME 'rawdata'
       writes pictures 12 to the file rawdata.bin as a byte stream
     OUTPUT 14 RAW NAME 'local.dmp' SWAP
       writes picture 14 to the file local.dmp using Motorola byte ordering
     OUTPUT 303 RASTER NAME 'screen'
       writes picture 303 as a Sun Raster file named screen.rff
     OUTPUT 42 TIFF NAME 'image'
       writes picture 42 as a TIFF file named image.tif
     OUTPUT 1 BMP NAME 'bitmap' MAP 2
       writes picture 1 as a Windows BitMap file named bitmap.bmp using
       the contents of picture 2 as a colormap

Pictures produced by OUTPUT can be recovered by INPUT
$
OUTPUT writes a Semper 6 data file unless one of the options BMP, RAW,
RASTER or TIFF are given.


If the option BMP is given a Windows BitMap file is produced. If the source
image has 3 layers the file is output as a 24-bit BitMap (BitpsPerPixel=24).
Otherwise the file is written with a BitsPerPixel value of 8 (256 colours) and
a linear greyscale colormap, unless the key MAP is used. If MAP is specified
it must be a 256 by 3 picture, with the red data in row 1, green in row 2 and
blue in row 3. (On systems where the LUT length is 256, a suitable picture can
be generated using the LUT command with the TO key).

If the option RAW is given a raw binary file is produced. A raw data file is
a byte stream starting with the top left pixel of layer 1, outputting along
each row. Pixels are written to a raw data file using the form of the output
picture, unless one of the form options (BYTE, INTEGER, FP or COMPLEX) is
specified.

If the option RASTER is given a Sun Raster image is produced. Currently these
are always written with a depth of 8 bits per pixel, using standard packing
(type 1 - RT_STANDARD) and with no colormap information (RMT_NONE).

If the option TIFF is given a Tagged Image File Format (TIFF) image is
produced. For a three layer source image an uncompressed RGB file is written,
each pixel as an RGB triple or as a planar RGB file if the option PLANAR
is given. Otherwise a greyscale file is written with a depth of 8 bits
per pixel, black-to-white photometric interpretation and using no compression.
The data is always written contiguously for simple TIFF readers.

The byte ordering for the Semper 6 data file is little-endian (Intel format).
Files written using the OUTPUT command on a PC can be read into a workstation
linked over a PC-NFS type network.

Raw data files can be written using Motorola byte ordering by quoting the
SWAP option.

Semper 6 data files have the picture label included unless the option
UNLABELLED is given. The actual data written is as for WRITE, but with
as binary data with no formatting.

The default extension for Semper 6 files is .pic, for RAW files is .bin, for
SunRaster files is .RAS, for TIFF files .tif and for BMP files it is .bmp.

Output will not automatically overwrite existing files unless the NEW option
is given. If NEW is omitted and the session is interactive the user will be
asked to confirm that the existing file can be overwritten.

See also: output.syntax input read write
$add output.syntax
Keys:
  [FROM]           picture to be written [SELECT]
  NAME text        name of file to write the data into [none; prompts if
                   interactive]

Options:
  NEW              replace output file if it already exists

  BMP |            write an uncompressed Windows BitMap format file
  RASTER |         write a Sun Raster format file
  RAW |            write a raw binary data file
  TIFF             write an uncompressed TIFF file

  PLANAR           write RGB TIFF as three seperate planes

  SWAP             write data in Motorola byte order (RAW only)

  BYTE | INTEGER | write data as byte (8 bit), integer (16 bit), floating
  FP | COMPLEX     or complex (not BMP, RASTER or TIFF)

  UNLABELLED       write without including picture label information

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add overlay.command overlay 4sight sg gl xwindows display framestore extras
You use the OVERLAY command to control the colour and visibility of the
display window's eight overlays.  Display annotation or graphics is directed
to the current graphics overlay, rubberband lines are displayed in the
rubberband overlay and the cursor is displayed in the cursor overlay.
Overlays can be turned on and off without affecting the data stored in the
overlay bitplanes.  Where overlay information is overlapped, the highest
numbered overlay is displayed.

Exx:  OVERLAY SHOW
        lists the current overlay settings
      OVERLAY CYAN
        sets the colour of overlay 1 to cyan
      OVERLAY 3 HSV 60,50,100 CURSOR
        sets the colour of overlay 3 to a desaturated yellow and makes this
        the cursor overlay
      OVERLAY 2 OFF
        turns off overlay 2
      OVERLAY 5 ERASE
        erases overlay 5
$
The display window has eight overlay bit-planes numbered from 1 to 8.  You use
the NUMBER key to specify the overlay number.  Note that the NUMBER key always
defaults to 1.

The SHOW option causes all the current overlay settings to be listed on the
console.

When the display window is created, overlays 1, 7 and 8 are selected as the
graphics, rubberband and cursor overlays, all overlays are turned on and
cleared and the colours for overlays 1 to 8 are set to white, red, green,
blue, cyan, magenta, yellow and red respectively.

The OVERLAY command changes only the overlay settings that are specified with
the command.  The remaining overlay settings are left unchanged.

The overlay colour can be specified in one of three ways.  If you need to
specify the colour exactly, you can specify the RGB components of the colour
as percentages with the RGB key, or the hue, saturation and brightness of the
colour with the HSV key.  The saturation and brightness values must also be
specified as percentages.  If the colour you want is one of the eight primary
or secondary colours, you can use the corresponding colour option as a
convenient alternative.  You may not specify more than one of the options
BLACK, WHITE, RED, GREEN, BLUE, CYAN, MAGENTA and YELLOW and the RGB and HSV
keys at one time.

An overlay can be turned on or off (made visible or invisible) by specifying
the option ON or OFF.

You may use one of the GRAPHICS, RUBBERBAND or CURSOR options to make the
specified overlay the current graphics, rubberband or cursor overlay.  You are
not allowed to specify more than one function for a given overlay.  For
example, the following would not be allowed:

    OVERLAY 2 GRAPHICS; OVERLAY 2 RUBBERBAND

All display annotation is directed into the current graphics overlay.  Note
that the ERASE OVERLAY command erases only the current graphics overlay and
leaves the other seven overlays unchanged.  You can use the ERASE option with
the OVERLAY command to clear a specified overlay.  To clear all the overlays,
type the following command line:

    FOR N=1,8; OVERLAY N ERASE; LOOP N

The cursor and any rubberband lines or boxes (see the XWIRES and PDRAW
commands) are displayed by overwriting and erasing the data in the
corresponding overlays.  You are recommended to retain the highest numbered
overlay for displaying the cursor so that it is not obscured by any of the
other overlays.

See also: xwires, framestore
$add overlay.syntax
Keys:
  [NUMBER]       overlay number [1]
  RGB(3)         red, green and blue percentages of overlay colour [none]
  HSV(3)         hue (0 to 360), saturation (percentage) and brightness
                 (percentage) defining overlay colour [none]

Options:
  BLACK | WHITE | RED | GREEN | BLUE | CYAN | MAGENTA | YELLOW  overlay colour
  ON | OFF       overlay visibility
  GRAPHICS | RUBBERBAND | CURSOR  overlay function
  ERASE          clear the specified overlay
  SHOW           list current overlay settings

The keys RGB and HSV and any of the colour options are mutually exclusive.

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add unix.command unix shell spawn
Use the UNIX command to execute non-interactive Unix commands from within a
Semper session.

Exx: UNIX 'ls .'
       lists the contents of the current directory
     UNIX 'rm junk.dat'
       deletes the file "junk.dat"
     UNIX 'xclock &'
       display the X clock

The Unix command string is specified as a Semper textstring immediately
following the command name.  If it is omitted, Semper prompts for the command
string.

The string is passed to a separate process running a C shell (csh) and is
executed by the shell.  Standard input for the shell is connected to
/dev/null.  Any attempt to read standard input will report an end-of-file
condition (this means that you can't interact with the C shell - to do that
you should open a new terminal window using the window manager menus or a Unix
command like "xterm").  Standard output is copied to Semper's console output
stream and standard error is connected to Semper's standard error (normally
the terminal window from which Semper starts up).

The UNIX command waits until the commands passed to the shell are completed
and return control to the shell.  Some commands (like "xclock" in the last
example above) do not return to the shell until explicitly terminated by other
means, in which case they should be invoked as background processes.  If the
UNIX command is abandoned, all dependent processes will be terminated.

See also unix.syntax, sh, cygstart, shcomm 
$add unix.syntax
Keys:
  [ ] text       Unix command as textstring [none; prompts if interactive]
$add sh
You use the sh command to return control to the calling terminal so you can
execute commands. 

See also ls, pwd, cygstart, shcomm, Unix
$add shcomm
You use shcomm to execute a command in the original terminal, e.g.
	shcomm name 'echo Hello World'
	  prints Hello World at the terminal
	shcomm name 'cygstart file.txt'
        opens the default editor for file.txt in a windows system

See also sh, ls, pwd, cygstart, Unix
$add cygstart
The command cygstart creates a file directory window on a cygwin system
See also sh, ls, pwd, shcomm, Unix
$add ls
Executes the unix 'ls' command in the original terminal
$add pwd
Execute the unix 'pwd' command in the original terminal
$add x11.command x11 X refresh window
You use the X11 command to control the rate at which the server display is
updated from the client (Semper host) machine.

Exx:
     X11 ILIMIT 8
        refresh after every eight image writes (the default)

     X11 VLIMIT 0
        refresh vectors and annotation only at the end of display operations
        or on display flush (the default)

     X11 VLIMIT 1 ILIMIT 1
        refresh on every operation
$
In order to maintain a non-destructive overlay, Semper maintains seperate
copies of the contents of the display and overlay and uses them to update the
visible areas of the window on the server.

To keep the display up to date after every operation involves an additional
processing time overhead of about 80% (images) and up to 10000% (annotation).
To reduce this overhead Semper delays writing to the server until one of the
following occurs:

(a) the number of operations exceeds the appropriate threshold

(b) Semper requires a display flush or display close

(c) the server requests a refresh (e.g. on exposing the window)

(d) the internal table of updates overflows

The X11 command allows the user to set the refresh thresholds or to turn off
the threshold mechanism.  This allows the user to trade off interactive
display rate against processor time.  The default thresholds are generally
acceptable for normal monitoring purposes.  Turning off the display refresh
threshold will give the impression of very fast display update when the image
is completed.  The annotation refresh threshold is turned off by default, so
complex annotation (e.g. YMOD plots) appears to be painted in bands from top
to bottom.  If you require a more conventional appearance use a VLIMIT of
(say) 8, but be prepared to wait for the results.

See also: X11.syntax
$add X11.syntax
Keys:
  ILIMIT      Sets the image refresh threshold. A positive value specifies the
              threshold. A zero or negative value turns off the threshold
              refresh. (Image only appears when complete).

  VLIMIT      Sets the vector/annotation refresh threshold. A positive value
              specifies the threshold. A zero or negative value turns off the
              threshold refresh. (Annotation only appears when complete).

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add acf.command acf autocorrelation auto-correlation Pattersonfunction
You calculate auto-correlation functions (Patterson functions) with ACF; an
acf is the inverse transform of the intensity in the Fourier transform of a
picture; it can be used as a resolution or directionality criterion, or may
help reveal faint periodicities.

Exx: ACF 1 2
       produces the ACF of Image picture 1 in Correlation picture 2
     FOURIER 1 2; ACF TO 3
       obtains the ACF of picture 1 in picture 3, leaving the transform in 2
$
The X and Y dimensions of the image must be a multiple of 4 and 'factorisable'
(no factors other than 2, 3, 4 or 5).  If the source image is a half-plane
Fourier image, the size restriction is applied with respect to the output
picture dimensions.

In general, ACF transforms the source picture, takes the squared modulus,
zeros the central transform pixel, inverse transforms, and divides by the
(final) central value; the resulting a.c.f. - which has a zero mean and a
maximum of 1 (at the centre) - is filed as a Correlation picture.

You can also supply pictures already transformed (Fouriers or Spectrums), in
which case ACF simply picks up the calculation at the appropriate point in the
above sequence, so as to calculate in all cases the a.c.f. of the original
Image picture.

For real source data (i.e. if the source is a non-Complex Image or a half-
plane Fourier or Spectrum), the output is Fp and centro-symmetric; for complex
source data (Complex Image or full-plane Fourier or Spectrum), it is Complex
and conjugate-symmetric instead.

                         Restrictions: image sizes must be factorisable
                                     : unsuitable for direct output to display
                 Multi-layer pictures: faulted
                Forms used internally: fp,complex

See also: acf.syntax
$add acf.syntax
Keys:
  [FROM]         source picture [SELECT]
  [TO]           output pictures [FROM]

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add add.command add
You use ADD to add programs to a program library (or replace them with new
versions, if they already exist).  See PROGRAM.STRUCTURE for how to construct
individual programs. ADD can also be used to convert MACROs into programs.

Exx: ADD
       prompts at the terminal for the program name and then accepts
       a single program terminated by END
     ADD PROGRAM 'QUICK'
       accepts a single program from the terminal and names it QUICK
     ADD NAME 'NEWPROGS'
       reads one or more programs in turn from the file NEWPROGS (or
       NEWPROGS.SPL if your installation forces such an extension)
     ADD NAME 'NEWPROGS' DEVICE 3
       specifies the device number of the program library to which the program
       is to be added - in default, the first unprotected library found in the
       current search order is used.
     ADD NAME 'PROGRAMS' PROGRAM 'WORK'
       reads only the program named WORK from the file PROGRAMS
     ADD MACRO 2:12 PROGRAM 'MAC12'
       converts the macro in picture 12 on device 2 into a program called
       MAC12 on the first writeable program library found.

You may not use ADD itself within a program.
$
Program text is added to the end of the program library; any older version of
a given program is marked as deleted, but the space is not actually released
immediately.  Repeated replacement eventually leads to a 'disc full' or
'directory full' message, when you must COMPRESS the device to recover the
free space before continuing.

By quoting both the NAME and PROGRAM keys you can include a single program
from a file of programs. This is useful for replacing or recovering a single
program without having to reload all of the program in the file.
See also: add.syntax
$add add.syntax
Keys:
  - | NAME text | MACRO   add text from terminal / named file / Macro
  PROGRAM text   program name to be used if adding Macro, single program
                 from a file or interactive program
  DEVICE         device number of program library to be updated [first library
                 in current search order]

Options:
  AGAIN          If NAME omitted, and no write operations have taken place
                 since the last file read, use the last value of NAME.
  VERIFY         confirm addition of program on the console [YES]

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add analyse.command analyse particle object connected region
Using ANALYSE is the first step in any form of particle or object counting
or measurement.  It scans a picture or subregion, identifying and measuring
all connected regions satisfying threshold conditions you specify, and records
the resulting 'ppl' (particle parameter list) as a Plist picture.  You then
use other commands such PTYPE to print, display or process the results.

Exx: ANALYSE GE 100; PHIST AREA
       counts and measures 'particles' in the current picture with pixel
       values 100 or more, storing the results as ppl 999, after which
       the PHIST command dislays a histogram of the areas.
     ANALYSE 50 TO 51 LE 6.35 SEGMENT 52
       counts and measures particles with pixel values 6.35 or less, storing
       the results as ppl 51, and creating a 'segmented' version of the
       original picture 50 for use by later commands such as PSHOW
     ANALYSE 1 GE 0 SIZE 400 AREA 10 MARK DISPLAY ID
       analyses positive particles in picture 1, considering only particles
       whose centre of area lies within a central region 400 points square,
       ignoring particles with areas less than 10, and marking the region and
       the identifiers for each particle on the display

'Particles' are connected regions of pixels with values satisfying threshold
conditions specified by the minimum and maximum keys GE and LE. You may use
one or both of these keys. Using both allows you to pick out particles with
an intermediate intensity value. If you omit both keys, a default value equal
to the middle of the source picture range is assumed for the key GE.
Twenty five (25) distinct parameters are recorded for each particle found.

For information on these parameters see PARTICLE.PARAMETERS.

For information on connected regions see CONNECTIVITY.

To examine them see PHISTOGRAM, PID, PMARK, PSET, PSHOW and PTYPE.

To make use of them see PCALCULATE, PEDIT, PEXTRACT, PFERET and PMOMENT.
$
Particles that touch the picture border are of course likely to be truncated,
and may lead to misleading measurements (e.g. suggesting some undersized
particles in a picture of entirely identical spheres).  You can overcome this
problem by specifying a subregion for analysis: particles whose centre of
area lies outside the subregion are then ignored, but other particles are
recorded correctly even if part of their area lies outside the subregion.

If you want to exclude particles below a certain area (a common way of
eliminating large numbers of spurious measurements as a result of noise in the
image analysed), you use the key AREA to indicate the minimum area of interest
to you.  The AREA key also allows you to specify an upper limit for the area
of a particle if the lower limit is also specified.

The number of particles found is reported on the console (unless you specify
the NOVERIFY option).  The variable N is also set to the number of particles
found.

If you supply a suitable output picture number via the key SEGMENT, a version
of the source picture is produced in which background pixels (belonging to no
particle) are set to zero, and pixels belonging to each particle are set to
the corresponding particle identifier (1,2..) assigned by ANALYSE.  This
picture is used by some subsequent commands; see PARTICLE.ANALYSIS for
general information about segmented pictures.

For later use as defaults for other commands such as PTYPE, ANALYSE sets the
variable PIMAGE to the number of the picture analysed and the variable PPLIST
to the output ppl number; if a segmented picture is produced as well, the
variables PSEGMENT is set to its number; see PA.PICTURENUMBERS for general
information about these.

ANALYSE relies on a series of temporary pictures for intermediate storage
during the picture scan, and may fail if sufficient space is not available
(with a 'disc full' or 'disc fragmented' message).

If you indicate a display with the key MARK, ANALYSE marks the reference point
of each particle found in the style/size specified by MKMODE/MKSIZE as usual.
If you use option ID, the particle identifier assigned is marked instead, and
if you use option CM, the mark is placed at the centre of area rather than at
the reference point.  If a subregion has been specified, this is also marked
on the display indicated by the MARK key.

                              Display marking: particle ref. points or centres
                         Multi-layer pictures: layer 1 processed only
                        Forms used internally: fp, integer

See also: analyse.syntax, particle.parameters
$add analyse.syntax
Keys:
  [FROM]         picture to be analysed [SELECT]
  [TO]           output ppl receiving measured parameters [998]
  SEGMENT        output picture containing segmented version of source [none]
  GE             minimum intensity threshold for particles [middle of source
                 picture range]
  LE             maximum intensity threshold for particles [none]
  AREA(2)        min. and max. area for particles retained [0,picture area]
  SIZE(2)        dimensions of subregion to be analysed [whole picture]
  POSITION(2)    position/offset of subregion [0,0]
  MARK           display to be marked with particle positions and subregion
                 border (only if subregion specified) [none]
  MKMODE         mark mode [1]
  MKSIZE         mark size [2]

Options:
  LEFT | RIGHT   process subregion abutting indicated border
  BOTTOM | TOP
  ID             if MARK set, mark particle identifier rather than as
                 specified with MKMODE and MKSIZE
  CM             if MARK set, place marks at particle centre of area rather
                 than at reference point
  VERIFY         list on the console the number of particles found [YES]

Variables set:
  PIMAGE         source picture analysed
  PPLIST         output ppl
  PSEGMENT       segmented output picture, if any
  N              number of particles found

See SUBREGIONS for more details of subregion keys/options.

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add ask.command ask input prompt read terminal
You use ASK commands in macros or programs for accepting values from the
terminal.  A prompt string can be specified if desired.

Exx: ASK RADIUS
     ASK 'Centre, radius: ' X,Y,RADIUS
     ASK 'Remove background? (YES/NO) ' N; IF ~SET(N) N=YES

The prompt may mix quoted text with expression values as in the third example,
and has exactly the same syntax as a TYPE command; but you must use a space
(not a comma) to mark where it ends.  If no prompt is given, as in the first
example, Semper uses the variable name(s) as a prompt.

If you are asked for more than one variable, as in the second example, you
should enter the appropriate number of values, separated by commas.  If you
omit some or all values, the corresponding variables are unset.  The last
example shows how this can be used to supply default values.

See also: ask.syntax
$add ask.syntax
ASK uses a special syntax:
   The final entry on the command line is the variable or list of variables
   to be read, any entry before this is treated as a prompt to be TYPEd out.

   e.g.      ASK 'New values for a,b:' a,b
$add assign.command assign attach devices create mount libraries allocate +
     assign.disc assign.file assign.log assign.help assign.program +
     program help disc display virtual memory cache log open
You use ASSIGN to provide access to the various kinds of data storage devices
supported by Semper: picture storage devices, program libraries, help
libraries and log files.  The physical storage which can be associated with a
device depends on the type of data being stored and is one the following:
memory, file (permanent or temporary) and a display or framestore.

Permanent files are created or located with a file name which you
must specify.  The file name may be a fully specified path name or the name of
a file which appears on Semper's file search path.  Temporary files are
created with a file name generated by Semper and they are deleted
automatically at the end of a Semper session.  The display device, as well as
storing picture data, can display images on a monitor and it may also allow
you to capture images from a camera.  Each device you assign is given a unique
device number which you use subseqently to refer to the device.  Use the
command SHOW DEVICES to list the devices currently assigned and the DEASSIGN
command to deassign them.

Exx: ASSIGN NAME 'V6DISC'
       assigns the existing picture file V6DISC to first free device number
     ASSIGN NEW SIZE 5000
     File name (as textstring): 'EMSA.BAK'
       creates and assigns a new file EMSA.BAK, with 5000KB of file space
     ASSIGN MEMORY SIZE 3000
       assigns 3MB of memory for storing pictures
     ASSIGN DISPLAY
       assigns the display device (always as device 1)
     ASSIGN SCRATCH SIZE 2000
       assigns a 2MB temporary picture file (deleted when deassigned)
     ASSIGN FILE NAME 'RESULTS.OUT'
       assigns the log file RESULTS.OUT for logging processing results
     ASSIGN HELP NAME 'SEMPER'
       assigns Semper's help library SEMPER.HLB
     ASSIGN PROGRAM NAME 'MYFILE.LIB'
       assigns a program library MYFILE.LIB
     ASSIGN WP NAME 'REPLACE' DEVICE 8
       assigns a write-protected file REPLACE.DSK as device 8
$
The ASSIGN command assigns a unique device number which you subsequently use
to refer to the device.  The device number is returned in the variable N.  You
can specify the device number to be assigned (provided it is not already in
use) with the DEVICE key.  Failing that, ASSIGN chooses the lowest free device
number.  Note that the display device is always assigned with device number 1.
There is a limit to the number of devices.  The command SHOW SYSTEM will list
how many devices Semper can support.  Use the command SHOW DEVICES to list the
details of all the devices currently assigned.  To deassign or close the
device, use the DEASSIGN command.  You specify which device to deassign with
the DEVICE key (you may use the DISPLAY option instead to deassign the display
device).  All devices are automatically deassigned at the end of a Semper
session.

Semper supports four different kinds of data storage devices according to the
type of data being stored:

    picture storage device - Semper pictures
    program library        - Semper programs
    help library           - on-line help
    log files              - ASCII text file (output only)

A picture storage device (or picture library/archive) can store up to 999
Semper pictures of arbitrary size (within the limits set by the capacity of
the device and the limits imposed by Semper itself).  Pictures are primarily
used to encode image data but they can also be used to store other kinds of
data like display look-up tables, histograms, position lists, particle
parameter lists, etc.  Use the EXAMINE command to list the contents of a
picture storage device and the commands CREATE, COPY, RENUMBER, DELETE,
DIRECTORY and COMPRESS to manage its contents.  When you refer to Semper
pictures you must specify the device number either explicitly (for example,
5:233, 2001, n:4, etc.) or implicitly when the picture resides on the current
picture storage device (for example, :12, :pic, 100).  The variable CD returns
the device number for the current picture storage device (so the previous
examples are interpreted as cd:12, cd:pic, cd:100).

A program library contains the text for Semper programs together with some
extra information to speed up the invocation of programs and the execution of
FOR loops and JUMP commands.  You invoke a program with the LIBRARY command by
giving the name of the program.  Unlike Semper pictures, you do not have to
specify a device number.  If programs with the same name appear in different
program libraries, the program library search order determines which one is
invoked.  Use the command ORDER to set or modify the program library search
order.  Use the command SHOW PROGRAMS to list the contents of a program
library and the commands ADD, LIST, COPY, RENAME, DELETE, DIRECTORY and
COMPRESS to manage its contents.

A help library contains the text for Semper's interactive HELP command.  This
allows you to obtain detailed and up-to-date information about all of Semper's
facilities and commands.  Help libraries are created and managed by a separate
program HELPMAN which you invoke outside of a Semper session.

You use log files to record textual data generated by Semper.  There are six
categories of output text: console, log, diagnostic, monitor, command and
input text, any combination of which can be output to a log file.  You use the
ECHO command to specify what kind of text is to be output to a log file.  The
command SHOW ECHO lists the current echo settings.

The physical storage associated with each type of data storage device can take
a number of different forms:

   picture device  - memory, permanent or temporary binary file, display
   program library - memory, permanent or temporary binary file
   help library    - memory, permanent or temporary binary file
   log files       - permanent text file

The data stored in a memory-based device is permanently stored in memory. This
provides the most efficient form of access to data, provided that your system
can support large memory arrays (this is not the case for PC systems based
purely on MS-DOS).

Files provide the most important form of data storage.  They can reside on any
physical medium which can be accessed via your machine's file system using the
normal file naming conventions (principally hard disc, but could also be
floppy disc, networked files, etc.).  Permanent files (in the sense that they
are intended to have a visible presence in the file system) must be given a
file name.  Temporary files are created with a Semper-generated name and they
are automatically deleted when deassigned.

The display device, at the same time as functioning as a picture storage
device (possibly providing access as efficient as with a memory-based device),
can display and manipulate picture data.  The resolution of the storage is
limited to 8 bits or less per pixel, so there is the facility to scale data
values into the range supported by the display memory.  When data is read back
the inverse scaling transformation is applied so that the data is returned
scaled to the original source data range, but with possible loss of precision.
The display device also supports the overlaying of graphical data on top of an
image, cursor driven data input and the manipulation of look-up tables.  You
use the following commands to control these facilities:

    general           - ERASE, PARTITION, VIEW
    look-up tables    - LADJUST, LSET, LUT, PSHOW
    interactive input - DRAW, PDRAW, SKETCH, XWIRES
    display output    - DISPLAY, RAMPS, RGB
    graphical i/o     - CONTOUR, MARK, OVREAD, OVWRITE, YMOD

Display look-up tables define a mapping from stored data values to displayed
intensities and colours.  The mapping does not change the stored data and can
usually be applied instantaneously.  If the display device is a framestore, it
will also allow you to capture images with a camera, with the camera image
displayed live on the monitor.  Once a camera image has been captured it can
be accessed like any other display picture.

The ASSIGN command can be used with the following combinations of keys and
options:

    ASSIGN [OLD]   [PROGRAM/HELP] NAME '.....' [WP]
    ASSIGN NEW     [PROGRAM/HELP] NAME '.....' SIZE ... [SLOTS ...]
    ASSIGN SCRATCH [PROGRAM/HELP] SIZE ... [SLOTS ...]
    ASSIGN MEMORY  [PROGRAM/HELP] SIZE ... [SLOTS ...]
    ASSIGN DISPLAY [..... extra keys/options .....]
    ASSIGN FILE NAME '.....' [NEW/OLD] [WIDTH ...] [APPEND]

In the first four examples above, the default is to assign a picture storage
device.  If however you specify the option PROGRAM or HELP, a program library
or help library is assigned instead.

In the absence of any of the options SCRATCH, MEMORY, DISPLAY or FILE, the
ASSIGN command assigns a permanent file.  If the option OLD is specified, an
existing file is assigned.  If the option NEW is specified a new file is
created.  If during an interactive session a newly created file would replace
an existing file, you will be asked for confirmation.  Option OLD is assumed
if neither OLD or NEW is specified.

If the SCRATCH option is given, a temporary file is assigned.  The file will
be created in the current directory unless one of the following environment
variables is set to a valid directory pathname:

    SEMPER$TEMP, TEMPDIR, TEMPFILES, TEMP

in which case, the file will be created in the named directory.  If more than
on of these environment variables is set, the first one in the list which is
set is used.  Semper generates a unique 8 character file name beginning with
"zzzz" and followed by the appropriate file extension.  The contents of a
temporary file are deleted automatically when the file is deassigned.  On some
systems, the file's directory entry is deleted as soon as the file is created,
so the file will not appear in the file system but space is still allocated to
the file.  If Semper terminates abnormally, the operating system will
automatically free this space.

The MEMORY option allows you to create memory-based devices where all the data
is stored in memory.  As long as your system can support large memory arrays,
this approach provides the most efficient way to store and process data
because it avoids the delays inherent in disc i/o.  For commands which require
more random access to data, storing all the data in memory can brings very
significant performance improvements over and above the improvements obtained
from Semper's disc caching scheme.

You can achieve similar results for accessing data in existing disc files with
the CACHE MEMORY command.  This reads the entire contents of a file (which you
have previously assigned as a Semper device) into a memory array, converting
the device into a memory-based device.  The data is written back to disc when
the FLUSH, CACHE FREE or DEASSIGN commands are used on the same device.

If the option DISPLAY is specified, the ASSIGN command assigns the display
device and returns the frame size in variables FSIZE(2), the monitor size in
variables MSIZE(2) and the number of frames in variable NFRAME.  You may find
that your version of the ASSIGN DISPLAY command accepts additional keys or
options, controlling details of the hardware configuration, such as the number
of display frames to be made available to you.  Consult the documentation for
your installation for more details.

If the option FILE is specified instead, a log file is assigned.

When assigning a permanent file, log file, a file name must be given. This
can be specified with the NAME key, but if you omit the key and you are
running an interactive session, Semper will prompt for the file name, for
example,

     ASSIGN
     File name (as textstring): 'my_disc'

where "my_disc" is the file name (the character string must be enclosed in
quotes).

Default file name extensions are provided according to the type of device
being assigned:

    picture file       .dsk
    program library    .plb
    help library       .hlb
    log file           .log

If no file extension is given, the default extension is used.  If you are
assigning an existing file, and a file with the default extension does not
exist, a further search for the file name without the extension is made.  When
creating a new file, the default file extension is always used.  When refering
to an existing file you can specify just a file name instead of a fully
specified path name, in which case the file must lie somewhere on Semper's
file search path to be found.  The current directory is always the first
directory in the search path.  Use the command SHOW PATH to list Semper's file
search path.  When creating a new file, you should give a fully specified
pathname unless you want the file to be created in the current directory.  The
command SHOW DEVICES always lists the full path name.

When creating a new permanent file, a temporary file or a memory-based device,
you must specify a data storage size in kilobytes with the SIZE key.  The
total size of the device also includes space for a header block and a
directory, so the overall size of the device will be larger than the size you
specify with the SIZE key.  You can control the size of the directory with the
SLOTS key.  For picture storage devices, the default directory size is the
maximum possible (each slot requires 8 bytes and the absolute maximum number
of slots required is 2002, giving a maximum size of 16KB).  Here you would use
the SLOTS key to create a picture device with a smaller directory.  Each
program in a program library takes up one slot of 64 bytes and the default is
to create a program library with 64 slots.  Directory entries in a help
library vary in size, but the slot size is assumed to be 64 bytes, with a
default directory size of 400 slots (a total size of 25KB).

When assigning files, you can specify the WP option to protect all the
data from accidental deletion or overwriting, irrespective of any other
protection status.  In multi-user installations the WP option is usually
required when assigning files belonging to other users (for which you may not
have write access privileges).  It also makes it possible for more than one
Semper session to share access to the same file.  The WP option is ignored
when option NEW, SCRATCH, MEMORY or FILE is used.

You use the FILE option to open/create log files for recording text output by
Semper.  The ECHO command controls what type of text is output to each file.
When a file is assigned, all output to that file is disabled.  Use the command
SHOW ECHO to list the current echo settings for each file.  A file, when it is
opened, is positioned at the beginning, unless option APPEND is used, in which
case it will be positioned at the end and text output to the file will be
added to any text already in the file. Text is truncated to the the output
width for the file. This is specified by the WIDTH key and defaults to 132.

The operation of the ASSIGN command is confirmed on the console.  You can
suppress this output by setting the option NOVERIFY.

For more information:

For general info:
See: assign.syntax, DEASSIGN, PROGRAMS, SCRATCH, SHOW

For picture management:
See: COMPRESS, COPY, CREATE, DELETE, DIRECTORY, EXAMINE, RENUMBER

For program management:
See: ADD, COMPRESS, COPY, DELETE, LIBRARY, LIST, ORDER, RENAME, SHOW

For program flow:
See: FOR, JUMP, CONDITIONALS

For memory management:
See: CACHE, FLUSH

For display management:
See: ERASE, PARTITION, VIEW

For displaying:
See: CONTOUR, DISPLAY, MARK, OVREAD, OVWRITE, PDRAW, RAMPS, RGB, YMOD

For display interaction:
See: DRAG, LADJUST, SKETCH, XWIRES

For display colouring:
See: LSET, LUT, PSHOW

For log files:
See: ECHO, SHOW

$add assign.syntax
Keys:
  NAME text      name of file to be assigned [none; prompts if interactive]
  SIZE           device size in KB for new disc or memory device [none]
  SLOTS          number of directory slots to be allocated when assigning new
                 disc or memory device [maximum possible for picture device,
                 64 for program library, 400 for help library]
  DEVICE         device number for assignment (the specified device number
                 must not already be in use)
  WIDTH          maximum record length for log file [132]

Options:
  SCRATCH | MEMORY | DISPLAY | FILE  assign temporary disc file,
                 memory, display or log file [assign permanent file]
  PROGRAM | HELP if file or memory, assign program or help library
                 [picture storage device]
  OLD | NEW      OLD:  if permanent disc file, open the file
                       if log file, re-use an existing file (use this option
                                    for write-only output devices)
                 NEW:  if permanent disc file or log file, create a new file
  WP             assign write-protected (read-only)
  APPEND         position log file so that output is appended
  VERIFY         confirm assignment on the console [YES]

Variables set:
  N              device number assigned
  FSIZE(2)       display frame size
  NFRAME         number of display frames
  MSIZE(2)       display monitor size

Since the variable DISPLAY is invariably set during any Semper session,
the 'option' DISPLAY is in fact handled by testing the value of the assumed
key $1.

Other keys (e.g. FRAMES) may be recognised locally in connection with
display assignment: see INSTALLATION or DISPLAY.ASSIGNMENT.

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add backproject.command backproject
You use BACKPROJECT to do the opposite of a projection operation such as
PROJECT does, i.e. to modify arbitrarily oriented picture columns according to
values in a 1-D 'projection' picture spanning the columns.  Alternative modes
allow you add or multiply by the projection value.

Exx: BACKPROJECT 1 WITH 10 ANGLE PI/4
       sweeps 1-D picture 10 across picture 1 from bottom left to top right,
       adding to picture 1 pixels as it goes.
    BACKPROJECT MULTIPLY 1 WITH 10
       backprojects picture 10 'on its end' horizontally across picture 1,
       multiplying rather than adding
$
You indicate source and output pictures as usual, and use a key WITH for the
1-D picture to be back-projected.  You choose one of two operating modes:
BACKPROJECT ADD (the default), which adds the projection to the source, and
BACKPROJECT MULTIPLY, which multiplies it on to the source instead.

Use the key ANGLE (default 0) to specify the projection direction, in the same
way as for PROJECT; this is in radians (as usual), and is measured anti-
clockwise from the positive X axis.  The projection is positioned so that the
source picture origin projects into its own coordinate origin.  Source pixels
projecting outside the 1-D picture are treated as though they projected on to
the nearer end of it.
                                    Multi-layer pictures: faulted
                                    Form used internally: complex

See also: backproject.syntax, project
$add backproject.syntax
Keys:
  [FROM]         source picture [SELECT]
  [TO]           output picture [FROM]
  WITH           1-D picture to be back-projected
  ANGLE          back-projection direction (radians, anticlockwise from the
                 positive X axis) [0]
Options:
  ADD | MULTIPLY add/multiply the back-projected data [ADD]

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add base.command base lattice
You use BASE to fit a lattice to a list of positions in a Plist picture (from
PEAKS or XWIRES LIST, for example); it refines initial estimates you provide
of the base vectors U and V and the origin W, using a least-squares criterion,
and reports the quality of the fit achieved.

Exx: U=10,0 V=0,10 W=0,0; BASE 51
       fits a lattice, roughly 10 pixels square, to sites listed in picture 51
     BASE 51 RADIUS 100 POSITION W,W2 MARK DISPLAY
       fits positions within 100 pixels of the lattice origin W, and marks the
       final deviations on the display.
     BASE NUMBERS 100,150 UVONLY VERIFY
       fits positions 100 to 150, with the lattice origin fixed at the picture
       origin, printing on the console the details of the fitting process
     BASE 51 TO 52 TOLERANCE 0.1
       produces a new Plist 52 containing only those positions from 51 that
       lie within .1 lattice vectors of a fitted lattice site
$
BASE alters the supplied values of U,V and W appropriately; if you know the
lattice origin exactly (e.g. because you are fitting a power spectrum), the
fitting of W can be suppressed via option UVONLY.  The initial estimates of U,
V and W (picture coordinates) you provide should be accurate enough to permit
correct indexing of most positions at least; if you cannot arrange this,
restrict the fit initially (as in the second example) to a limited region, and
then use BASE a second time without the restriction.

To prevent a few spurious positions from biassing the fitted lattice,
positions are ignored if they are not reasonably near a site of the estimated
lattice - specifically, if their indices (coordinates in terms of the lattice
base vectors) are not within 0.3 of an integer.  The key TOLERANCE allows you
to alter this threshold value; a value of 0.5 or greater eliminates selection
on this basis.

If you quote TO explicitly, as in the last example, an output Plist is
produced which includes only those positions included in the fitting process
(i.e. those within any subregion defined and within the relevant tolerance of
the lattice).

Variables N and R return the number of positions fitted, and their r.m.s.
deviation.  If MARK is set, the final deviations of all positions from the
lattice are marked via small lines emanating from the positions in the
directions of the corresponding lattice site, but 5 times larger than the
actual deviation for visibility; you can alter this figure if you need to via
a key TIMES.
                                   Display marking: final position deviations
                              Form used internally: complex

See also: base.syntax
$add base.syntax
Keys:
  [FROM]         source picture [SELECT]
  [TO]           output picture [no output]
  POSITION(2)    centre of region to which fitting is restricted [0,0]
  RADIUS         radius of region to which fitting is restricted [infinite]
  NUMBERS(2)     serial numbers of positions to which fitting is restricted
                 [all positions]
  TOLERANCE      fractional deviation from initial (estimated) lattice sites
                 beyond which sites are excluded from fit [0.3]
  MARK           display to be marked with deviations from lattice positions
                 [none]
  TIMES          magnification of display marking [5]

Options:
  UVONLY         fit U,U2 and V,V2 only, preserving lattice origin W,W2
  VERIFY         list on the console the details of fitting process

Variables used:
  U(2),V(2)      initial estimates for lattice base vectors
  W(2)           initial estimate for lattice origin

Variables set:
  U(2),V(2)      base vectors of fitted lattice
  W(2)           origin of fitted lattice
  N              number of sites included in fit
  R              r.m.s deviation between included sites and fitted lattice
                 (in source pixels)

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add filters convolution
Semper provides many different simple filter operations, including
  DIFFERENTIATE  Calculates picture derivatives via 3-point operator
  EDGE      Applies magnitude or Roberts edge operator
  FIR       Applies arbitrary small block (FIR) filter (with options for
            gaussian smoothing and laplacean sharpening)
  HP        Applies a square-block high-pass operator
  LMEAN     Calculates local block mean (smooths picture)
  LVARIANCE Calculates local block variance
  LSD       Calculates local block standard deviation
  RANK      Applies local ranking (median,eroding,dilating) filter
  RF        Applies two point recursive (IIR) filter for smoothing/sharpening
  SHARPEN   Applies square-block edge-enhancing operator

For operating on binary (zero/non-zero) pictures only, the following are
also available:
  MEDIAN    Applies a median filter
  ERODE     Erodes simply or selectively, and generates outlines or skeletons
  DILATE    Dilates simply or selectively, and grows objects without joining
$add keyboard recall command command.editing
It is possible to recall up to 40 previous commands from Semper's command line
buffer using the cursor up and cursor down keys.  Cursor left and cursor right
can be used to move along the line.  In addition there are keys to toggle the
insert/overstrike mode, move to the end of current line, move to the beginning
of the current line, erase the whole line and redraw the current line.

   The key assignments recognised by Semper are:

   Cursor up                  Recall previous line (cyclic)
   Cursor down                Recall next line (cyclic)
   Cursor left                Move to previous character
   Cursor right               Move to next character
   Home                       Move to start of current line
   End                        Move to end of current line
   Insert                     Toggle insert/overstrike mode
   Control+R                  Refresh current line
   Control+U                  Erase current line
   (or key set using STTY kill)
$add fileopening files opening input output
When opening external files such as log files and PostScript output files
Semper commands use the following strategy:

   The filename supplied to the command is broken down into a drive/directory
component, a name and an extension. If the extension is missing the default
extension name for the command is used (see FILETYPES). If the drive/
directory is missing the action taken will depend on the way the command
intends to use the file:

   For output files the current directory name will be used.
   For input files the path is searched for the file (see FILEPATH).
   For input/output files the path is searched and if the file is not found
       the current directory is used.

   If an output file already exists Semper will report an error. (The
       exception to this is VAX/VMS systems,  which will create a new
       version, unless the exact version was specified. Some of the
       other systems, such as Windows Semper, may prompt to allow the
       user to overwrite the existing file.)
   In order to change this action use the options NEW and OLD:
       NEW is used to specify that any old file should always be replaced.
       OLD is used to allow a previous version to be re-used (the data in
           the file will be lost). This option should be used when text is
           to be sent to a write-only file or device, such as a printer.

See also: filetypes filepath
$add filepath search path files
When opening external input files, Semper commands will search a number of
directories to locate a file that is not found in the current drive or
directory.  The sequence of directories is defined by Semper's file search
path.  You can find out what this currently is with the command SHOW PATH.

On systems that have an operating system path (DOS and UNIX), that path will
be used.  Failing that there will be some mechanism provided for defining the
search path outside Semper (e.g. on VAX systems, the search path is defined by
the logicals called SEMPER$PATH and PATH (in that order)).
$add filetypes extensions filenames files
The following default file extensions are used:

   .dsk  disc file - picture storage
   .hlb  help libraries
   .plb  program libraries
   .wrk  work disc - internal data storage
   .run  run program files
   .log  log files
   .dat  data file used by READ/WRITE commands
   .unf  data file used by READ/WRITE UNFORMATTED commands
   .ps   PostScript image output file
   .eps  encapsulated PostScript image file
   .spl  library program source files
   .shl  standard help library source
   .syn  syntax definition file
   .err  standard error message file
   .pic  data file used by INPUT/OUTPUT commands
   .bin  data file used by INPUT/OUTPUT RAW commands
   .bmp  data file used by INPUT/OUTPUT BMP commands
   .rff  data file used by INPUT/OUTPUT RASTER commands
   .tif  data file used by INPUT/OUTPUT TIFF commands
$add scratch temporary workspace
Semper's workspace device and all files assigned using ASSIGN SCRATCH are
temporary and are deassigned as soon as the local operating system permits.
The actual names generated by Semper usually begin with ZZZZ..., and if any
files of this form are found after a system failure when Semper was running
they should be deleted. (Avoid doing this if there is an active Semper
session anywhere on your machine or network).

You can specify where the files will actually reside using one of several
environment variables (logical names on VAX/VMS systems). The names are
searched in the following order:

      SEMPER$TEMP, TEMPDIR, TEMPFILES, TEMP

If none of these are present Semper will use the current directory. To learn
where temporary files are being stored do SHOW DEVICE 0 which will show the
full name of the workspace device.
$add layout commands syntax blanklines spaces case lowercase continued +
continuations linelengths
You can enter several commands in a single line, using a semicolon (;) to
delimit each. Layout is flexible: blank lines are ignored and spaces matter
only within numbers, names and text strings.  Upper/lower case distinctions
matter only in text strings.

Commands may be as long as you like, but input lines are limited to 80
characters; you can 'continue' lines to the following line (up to an
installation-dependent limit) by adding a plus (+) to the end of the line.
Ex: TITLE 2:53 ADD '- subregion extracted bottom left and passed +
    through FIR GAUSSIAN'
$add comments remarks notes !
You can include comments in macros or programs by starting commands with an
exclamation mark (!); Semper skips such commands completely.

Exx: ! Construct filter denominator
     ! Set focus; Focus=50mm

Note that a semicolon marks the end of a command as usual, and terminates the
comment as in the 2nd example!
$add conditionals if unless and or greaterthan lessthan equalto compare
You can begin a command with an IF or UNLESS prefix if you want to make its
execution depend on some condition or other.

Exx: UNLESS V > 0.2 JUMP AGAIN
     IF N=0 IF X < PI RETURN
     IF N=0 & X < PI RETURN

Logical operators > < and = are used to mean greater than, less than and equal
to, respectively (see LOGICALS).  Multiple conditions can be imposed either
via successively interpreted conditional prefixes, as in the 2nd example, or
by using the logical AND and OR operators & and | as in the last example.
$add logicals
For such purposes as IF and UNLESS prefixes, Semper considers zero values as
being equivalent to the logical value FALSE, and non-zero values as equivalent
to the logical value TRUE.  Two separate sets of operators are concerned with
such values.

Firstly, you can use the numerical comparison operators <, >, <=, >=, = and ~=
to compare numerical values:
   X < Y  has the value 1 if X is less than Y, and otherwise 0
   X > Y  has the value 1 if X is greater than Y, and otherwise 0
   X <= Y has the value 1 if X is less than or equal to Y, and otherwise 0
   X >= Y has the value 1 if X is greater than or equal to Y, and otherwise 0
   X = Y  has the value 1 if X is equal to Y, and otherwise 0
   X ~= Y has the value 1 if X is not equal to Y, and otherwise 0

Secondly, you can combine logical values with logical operators & (AND),
| (OR) and ~ (NOT):
   P & Q has the value 1 if both P and Q are non-zero, and otherwise 0
   P | Q has the value 1 if either P or Q is non-zero, and otherwise 0
    ~P   has the value 1 if P is 0, and otherwise 0

Exx:  X > 3 & Y < 2 is true if X is greater than 3 and Y is less than 2
      X = Y | CD ~= 2 is true if X equals Y or if CD does not equal 2
      P1 & ~P2 is true if P1 is true and P2 is false

Additional 'bitwise' AND, OR and NOT operations are provided as functions
(see FUNCTIONS).  These treat all bits of the operands and resulting values
as significant and apply binary AND, OR and NOT operations to all bits.

Exx:  NOT(4) is the complement of ...0000100, i.e. ...11111011, i.e. -5
      AND(5,7) is AND(...0000101,...0000111), i.e. ...000101, i.e. 5
      OR(5,7) is OR(...0000101,...0000111), i.e. ...000111, i.e. 7
$add expressions arithmetic operators +
 compare add subtract multiply divide power+
 min max remainder ifelse complex real imaginary conjugate cc phase modulus+
 msq cos acos sin asin tan atan root exp ln logarithm integer round nearest+
 gt lt ge le eq ne and or not
When you combine numbers, variables and function calls with arithmetical
operators, the result is called an 'expression'; generally, you may use
expressions wherever Semper expects a numerical value.

Exx: N+3             X-.5            EXP(-X^2)
     MOD(X,Y)        (MIN+MAX)/2     ROOT(A*COS(B))

The operator ^ denotes exponentiation (raising to a power).
See FUNCTIONS for a list of the functions (arithmetical and otherwise) which
are recognised.
See LOGICALS for details of logical values and operators.

There are three types of operators used in expressions: arithmetical,
relational and logical operators. Arithmetical and relational operators take
numerical arguments and logical operators take logical arguments. Arithmetical
operators produce a numerical result whereas relational and logical operators
produce a logical result (0 or 1 numerically speaking).

   Arithmetical      *   /   +   -   ^   :

   Relational        <   >   <=  >=  =   ~=

   Logical           ~   &   |

Most operators are dyadic: they require two arguments, but +, - and : may also
be used as unary operators and ~ may only be used as a unary operator.

Exx:    +4    -PI    :N    ~SET(ERASE)

For those who understand these things, functions have the highest priority,
followed by :, then ^, then * and / together, then + and - together,
then <, >, <=, >=, = and ~= together, then ~, then & and finally |.  Left to
right evaluation applies between operators of equal priority, so that for
example 1/2/3 is the same as 1/6.  Brackets can be used freely to control the
order in which expressions are evaluated.
$add functions
The following functions are recognised by the command interpreter:

    SIN(X)        sine
    ASIN(X)       arcsine
    COS(X)        cosine
    ACOS(X)       arccosine
    TAN(X)        tangent
    PHASE(X)      arctangent
    PHASE(X,Y)    arg(X+iY), i.e. TAN(PHASE(X,Y)) = Y/X
    EXP(X)        exponent (e to the power of x)
    LN(X)         ln (natural log - the base e)
    MIN(X,Y)      lower of X,Y
    MAX(X,Y)      greater of X,Y
    MOD(X)        modulus (absolute value)
    MOD(X,Y)      modulus of (X+iY), MOD(X,Y) = ROOT(X*X + Y*Y)
    MSQ(X,Y)      modulus squared of (X+iY), MSQ(X,Y) = X*X + Y*Y
    ROOT(X)       square root (X must not be less than zero)
    REM(X,Y)      remainder when X divided by Y, REM(X,Y) = X - (Y*FIX(X/Y))
    ROUND(X)      nearest integer to X
    FIX(X)        next integer towards zero from X
    NOT(N)        bitwise NOT (complement) of integral value (e.g., not(2)=-3)
    AND(N,M)      bitwise AND of integral values (e.g., and(7,5)=5)
    OR(N,M)       bitwise OR of integral values (e.g., or(7,5)=7)
    RAD(X)        angle in radians equivalent to X degrees
    DEG(X)        angle in degrees equivalent to X radians
    IFELSE(X,Y,Z) returns Y if X is non-zero (TRUE), and Z otherwise

    P(X,Y,Z)      pixel X,Y,Z of current picture (SELECT)
    RE(X,Y,Z)     real part of pixel X,Y,Z - same as P(X,Y,Z)
    IM(X,Y,Z)     imag part of pixel X,Y,Z

    SET(name)     returns 1 (TRUE) if named variable is set, and 0 (FALSE)
                  otherwise

If Y and Z are omitted in functions P, RE and IM, they default to zero.
$add select current
The variable SELECT provides a 'current picture' number at any given time; it
is used as a default source for any command involving pictures.  For example,
if you simply type EXAMINE, or DISPLAY, it is picture SELECT that is examined
or displayed.

Semper sets SELECT automatically to the number of the last picture you
produced (e.g. SHARPEN 2 to 3 selects 3) or inspected (e.g. SURVEY 2:54
selects 2:54).  If you are in doubt as to the current picture at any time,
simply TYPE SELECT.

Since the display does not have the range or precision of other devices,
display pictures are NOT selected automatically unless you have taken the
deliberate step of making the display device current (e.g. CD=FS).  You can
select display pictures 'manually', if you want to, with the SELECT command
(see SELECT.COMMAND).
$add command.syntax command syntax
The syntax of some Semper commands such as TYPE is special; however other
commands such as DISPLAY, FOURIER etc. follow a fixed pattern of a command
name followed by a list of option names and key name / value pairs in any
order.  For example,
   $ MASK 1 TO 2 RADIUS 0.7*R FP
consists of
   a command name MASK (which applies a circular mask to a picture)
   an omitted key name, with the value 1 (selecting a picture to be masked)
   a key name TO, with the value 2 (choosing an output picture number)
   a key name RADIUS, with the value 0.7*R (setting the mask radius)
   an option name FP (causing the output to be stored in floating point form)

See KEYS and OPTIONS for further information.
A complete list of the keys and options for each command are given under
names of the form -.SYNTAX, e.g. MASK.SYNTAX.
If a command has any keys and/or options defined, you can use the SYNTAX
command to list these.
$add elements syntax names numbers
The items making up Semper commands are names, numbers, punctuation characters
and text strings (see TEXT).

Names identify commands (operations to be performed), options, variables,
labels etc.; they  begin with a letter and continue with letters or digits;
only the first three characters are significant. Examples are DISPLAY
(equivalent to DIS), FROM (=FRO), NEXT (=NEX), A and U1.

(See also SUBSCRIPTS for information about names such as N#I.)

Numbers are (decimal) numerical values, with or without a leading sign and a
trailing 'exponent' (power of 10 factor).  Examples are 1, 1984, -3.421, 1E5
(=100000), .7 and -.2E-6 (=-.000002).
$
Numerical values used by commands can almost always be replaced by the name of
a variable or function to be used instead, or an arithmetic expression formed
by combining these with the operators + - * / and ^ (the last indicating
raising to a power).  Examples are X, X+2, SIN(THETA), 0.5*(MIN+MAX), 1-1/N,
CS^0.25 and MOD(X,Y).

See EXPRESSIONS for more details.
$add subscripts
Names of the form NAME#VARIABLENAME are interpreted as if the first name
appeared with the decimal value of the variable (the 'subscript' variable)
attached.  For example, if I is 3, then N#I is equivalent to the name N3; if
I is 39, N#I is equivalent to N39 and NP#I is equivalent to the name NP39
(=NP3).

The construction allows you to hold sets of parameter values conveniently in
'array'-like variables; it also allows computed JUMP commands, e.g. JUMP L#N,
since subscripts are recognised anywhere that names are recognised.

The first name must have 1 or 2 letters only, and the subscript value must be
in the range 0-99.
$add textstrings textstring characters letters
Semper allows you to specify text strings in several contexts - as terminal
messages, as picture titles, display lettering, file names etc.  Wherever this
occurs, a common syntax is accepted in which strings of literal text enclosed
in quotes, and numerical expressions to be evaluated, are listed in any order
with commas separating them.  This allows you to include calculated values in
messages etc.

Exx of text strings in isolation:
    min,max
    'This is a message'
    'Circle area is ',PI*R^2,' and perimeter ',2*PI*R

Exx of text strings used in commands:
    TYPE 'Processing complete'
    TITLE 52 'Image plate number ',N,' directly from TV camera'
    ASSIGN NAME 'series.',NS WP
$add minimum maximum
See RANGES, DISPLAY.SCALING and SURVEY for information on picture ranges
and display grey scaling.

See CALCULATE for information on applying point by point minimum or maximum
functions to pictures.

See EXPRESSIONS for information on applying minimum or maximum functions
to variables.

See RANK for information of applying local minimum or maximum operators
to pictures.
$add display
Semper's display device allows you in general to display pictures with
various different grey or colour scales and magnifications, to mark or
measure features directly with a display cursor, and to make use of the
memory of the device (if of the framestore type) directly for picture
storage and manipulation.

The word display itself may refer to two different things:

The DISPLAY command (see display.command); used for displaying picture.
The DISPLAY variable (see display.variable) which allows you to refer to
the most recently used display picture at any given time.

Thus, you can display pictures by commands such as DISPLAY 1 (using the
DISPLAY command itself), or by commands such as COPY .. TO DISPLAY (or
SHARPEN .. TO DISPLAY etc.), using the word as an output picture number.

Details of each usage are given separately.

See also: display.assignment display.scaling partitions
$add display.variable current
The variable DISPLAY is always set by Semper to the picture of the display
most recently produced, used or inspected, so providing a 'current' display
number.  You can use it as a source or output picture number in commands:
   COPY DISPLAY TO 51            [as source]
   SHARPEN DISPLAY               [as source and output]
   LMEAN TO DISPLAY OVER 10      [as output]

You can also use it as to provide the device part of explicit display picture
or partition numbers, e.g. DISPLAY TO DIS:4 or ERASE PARTITION DIS:2
$add display.scaling black white grey brightness contrast intensity
Display scaling can be effected EITHER by changing the way the display data
are presented on the screen (see VIEW and LUT), or by re-scaling the display
data themselves; information about the second course is given here.

When you direct the output of a given command to the display device, e.g.
SHARPEN 3 TO DISPLAY, Semper uses the current values of the variables MIN,MAX
to control the grey scaling - scaling MIN (or below) to black and MAX (or
above) to white.  You will need in general therefore to set these before
outputting pictures to the display if the current values are unsuitable.

The DISPLAY command itself however, e.g. DISPLAY 3, normally establishes
suitable scaling automatically: it sets MIN and MAX itself to the actual
minimum and maximum values present in the data to be displayed (usually by
recovering these from the picture label).  When you use the DISPLAY command
accordingly, you do not normally need to concern yourself with the grey
scaling.

EXAMINE FULL, applied to a display picture, reports the black,white levels
used in scaling the data; this scaling is reversed when you read data back
from the display, and is thus transparent except for a possible loss of
precision.
$add blocks
Semper manages disc space in units called 'blocks', typically 64B to 1024B in
size; space is allocated in units of the block size, and picture rows are
stored aligned with block boundaries.  The 'block' size may well not be the
same size as the physical sector size on your machine's disc drives.  EXAMINE
FULL reports the number of blocks used by a given disc picture.
$add cd current
The variable CD identifies a device number assumed whenever you omit an
explicit number, i.e. typing 52 means CD:52.  It is also the default device
for operations involving a complete device, e.g. EXAMINE ALL, DIRECTORY or
DEASSIGN.

You have complete control of CD yourself, and set it or change it as you like;
Semper never changes it.  You will usually want to set a suitable initial
value in your startup file.
$add images
For general information on using, referencing and storing pictures in Semper,
see CLASSES, FORMS, DEVICES and PICTURENUMBERS.

For information on the IMAGE command (used to regenerate images from Fourier
or other transforms), see IMAGE.COMMAND.
$add sizes dimensions
Semper pictures have three dimensions in general:
  - the row length (number of columns)
  - the column length (number of rows)
  - the number of layers
You usually specify sizes, when you need to, via a set of three numbers
accordingly, e.g. SIZE 500,400,3 for a picture with 3 layers each 500 wide by
400 high.

For most purposes, the dimensions are unrestricted.  The maximum row length
acceptable is installation-dependent (depending on the lengths of various
buffers internal to Semper); SHOW SYSTEM lists the limits for each picture
form.  The number of rows and layers is limited only by amount of
disc and/or display storage available.

There are a few commands which impose some restriction on the size of pictures
that can be processed.  For the commands HILBRT, TURN and WALSH, the picture
dimensions are limited to powers of two.  For the commands ROTATE, TRANSPOSE
and the commands involving Fourier transforms: ACF, FOURIER, IMAGE, PS and
XCF, the picture dimensions are limited to numbers which are a multiple of 4
and which have no factors except 2, 3, 4 or 5.  The command SHOW SIZES will
list all such 'factorisable' sizes.
$add classes usage datatypes pictures spectrum correlation undefined
Semper distinguishes several 'classes' of picture, depending on what the data
represent, and adapts the action of some commands to suit the class concerned:

Number   Name         Meaning
   1     Image        standard (visual) image
   2     Macro        command macro text (commands or command fragment)
   3     Fourier      Fourier transform
   4     Spectrum     power spectrum (Fourier transform intensity)
   5     Correlation  auto- or cross-correlation function
   6     Undefined    anything not otherwise classifiable
   7     Walsh        Walsh/Hadamard transform
   8     Histogram    histogram
   9     Plist        position list (coordinates + optional related info)
  10     Lut          look-up table (size N,1,1 for monochrome, N,3,1 for
                      false colour, N,1,3 for full colour)

You can check the class name of any picture via EXAMINE, and PCB sets the
variable CLASS to its number.  You can use RECLASS to alter the class in most
cases, should you wish to coerce the system in some way.

See also: class.fourier class.plist class.lut
$add transforms
See FOURIER, HILBERT and WALSH for information on various different forms
of image transform.

See also IMAGE, the command which performs inverse transforms.
$add fourier fourier.general ffts
For information on Class Fourier pictures, and general information on the use
of Fourier transforms in Semper, see CLASS.FOURIER; for information on the
FOURIER command, see FOURIER.COMMAND.
$add correlation alignment registration cross-correlation
Auto- and Cross-correlation functions are held by Semper in class Correlation
pictures; the main commands relevant to their calculation are:
  ACF   auto-correlation functions
  XCF   cross-correlation functions w.r.t. translation
  OCF   cross-correlation functions w.r.t. orientation
  RCF   cross-correlation at various spatial frequencies, as resolution test
XCF and OCF are important tools for aligning (registering) one picture with
respect to another.
$add class.fourier full-plane half-plane fourier
Class Fourier pictures hold discrete Fourier transforms of Images, from which
the original Image can be recovered exactly by inverse transformation.  The
point h,k in the transform of a size N,M image t(x,y) is the sum over image
points (x,y) of t(x,y).exp{-2pi.i(hx/N+ky/M)}; the image is recovered by a
similar sum divided by the product NM.  Exceptionally, the image coordinate
origin is treated as central when transforms are calculated, and any different
origin recorded in the label is ignored.

The transform data are almost always complex, and you should never force a
transform into other picture forms.  The transforms of real images have the
property of 'conjugate symmetry', however: T(-h,-k) is the complex conjugate
of T(h,k), so that only half the data are independent.  Semper stores only the
right hand half-plane of such transforms, with the transform origin recorded
as being at the centre of the first column.  Commands FULL and HALF allow you
to interconvert full-plane and half-plane forms if you want to. Pictorially:

    ------------------          ----------          ------------------
    |** .    .  **.  |          |        |          |                |
    |  **    .    ** | FOURIER  |        |   FULL   |                |
    |   .*** .    .  |  ---->   |  *     |   --->   |     -    *     |
    |   .   **    .  |          *   -    |          |        *       |
    |   .    .*** .  |  <----   |        |   <---   |      *    -    |
    | **.    .   *.  |  IMAGE   half-plane   HALF   |  full-plane    |
    |   ** Image  .**|          | xform  |          |     xform      |
    ------------------          ----------          ------------------

Discrete transform sampling is such that one pixel away from the origin
corresponds to a period equal to the image field of view (in x and y
directions independently), and the furthest pixel from the origin corrresponds
to a period of two image pixels (a component +1 -1 +1 -1 +1 -1 .. across the
image).  The discrete transform of an image sampled on a non-cartesian lattice
provides transform samples on a corresponding 'reciprocal' lattice; LIBRARY
RECIPROCAL will interconvert real and reciprocal lattices for you.
$add class.histogram
Class Histogram pictures consist of a single row containing a set of channel
counts followed by two additional values recording the minimum and maximum
values spanned by the histogram channels.  Form Fp is normally necessary for
adequate precision and range.  The default origin position is at the left.
$add class.plist lists
Class Plist pictures consist of lists of positions, with optional additional
information attached to each position.  The first layer always contains the X
coordinates of the positions, the second contains the Y coordinates (for 2D
positions) and the third the Z coordinates (for 3D positions), with subsequent
layers containing further information such as picture heights at the positions
listed.  Plists are used in several different ways, however, and the number of
layers actually present varies widely.
A 'type' code is recorded for each Plist, as follows:
   1 Pure list, without any particular connectedness between positions
   2 Open curve, with the positions taken serially to define a curve
   3 Closed curve, with the positions taken serially to define a curve and a
     final additional line segment assumed to close the curve by joining the
     extreme positions.

Most Plists involve a single row only, but there may in general be many rows
in each layer (2D array or grid of positions).  The default position for the
origin of a Plist is at the far top left.
$add class.lut
Class Lut pictures consist of copies of display hardware look-up-tables, with
a default origin position top left.  A monochrome lut involves a single table
of values, held in a single picture row; a false colour lut involves three
rows for the red, green and blue outputs respectively from top to bottom; and
a full colour lut involves three single-row layers, for the same colours from
back to front.

You may not need to use Lut pictures at all, since Semper provides
additional lut storage intermediate between Lut pictures and the display
hardware (see LUT.GENERAL); their value is the saving of luts between
sessions or their interchange between users.
$add colour falsecolour
Semper has facilities for displaying full colour (three layer) pictures in
full colour form, and monochrome (single layer) pictures in false colour form;
whether all of these are achievable in a given installation depends on the
local hardware, of course.

Full colour presentation is achieved by loading the three layers into
corresponding regions of three successively numbered display frames fed to the
red, green and blue channels; you should define a partition that is three
frames deep as this will instruct Semper to output the red, green and blue
layers to the first second and third frame assigned to the partition.  You
also need to VIEW the picture with a lut created with the mode 'colour'
(see LUT).  The same output mechanism operates on single-layer pictures by
copying the image to all the frames assigned to the partition.  This allows
you to view single layer pictures as monchrome or false-colour images in the
usual way.

False colour presentation is achieved simply by VIEWing with a lut created
with the mode 'false'.

Since you can record a default lut for each partition (see PARTITIONS),
commands such as
   LUT 1 CREATE; LUT 2 CREATE FALSE; LUT 3 COLOUR
   PARTITION 1 LUT 1; PARTITION 2 LUT 2; PARTITION 3 LUT 3
allow you subsequently to achieve monochrome, false colour or full colour mode
simply according to whether you refer to partition DIS:1, DIS:2 or DIS:3.
$add hue saturation hsi
One of the common ways of describing physiological perceptions of coloured
objects is via the three parameters HUE, SATURATION and INTENSITY (HSI).

              .   .   .
     GREEN .     90       .  yellow        The hue indicates whether the
        . 120              60.             colour is red, green or blue etc.
      .                        .           via a circular scale as left;
     .                          .          positions are indicated numerically
     .                          .          in degrees anticlockwise from the
cyan .180                      0. RED      +X axis, as marked.  For example,
     .                          .          blue is indicated via HUE 240.
     .                          .
      .                        .
        .240              300.
    BLUE   .     270      . magenta
              .   .   .

When white light is superposed on a pure colour, the result is said to be
an unsaturated colour; the SATURATION parameter measures this characteristic
on a 0-1 scale (zero meaning completely white and 1 completely pure colour).
For example, pink is an unsaturated form of red: SATURATION .2 gives a faint
(nearly white) pink, and SATURATION .8 a strong (nearly red) pink.

Intensity measures the overall brightness, on an arbitrary scale - exactly
like the brightness of a monochrome picture.
$add coordinates positions indices
[This section describes the standard 'picture' coordinate system; for
graphical purposes, you can also use two alternative coordinate systems
however: see GRAPHICS]

You use a normal right handed coordinate system to identify positions within a
picture; one coordinate is needed for 1-D pictures, two for 2-D and three for
3-D. The X coordinate increases to the right, the Y upwards, and the Z towards
you.  HELP ORIGIN explains where the origin is by default, and how you can
move it if you want to.  As an alternative to the Z coordinate, you can often
use layer numbers (1,2.. from the back, irrespective of the origin position).
$
Ex: a picture containing 3 layers each of 50 pixels square, with the default
    origin position, has the following coordinate system:

   (-24,25,-1)----------(0,25,-1)------------(25,25,-1)
        |                   |            layer 1 |
        |   (-24,25,0)-----------(0,25,0)------------(25,25,0)
        |        |                   |           layer 2 |
        |        |   (-24,25,1)-----------(0,25,1)------------(25,25,1)
        |        |        |                   |           layer 3 |
   (-24,0,-1)----|        |                   |                   |
        |        |        |                   |                   |
        |   (-24,0,0)-----|                   |                   |
        |        |        |                   |                   |
        |        |   (-24,0,1)-------------(0,0,1)------------(25,0,1)
        |        |        |                   |                   |
   (-24,-24,-1)--|        |                   |                   |
                 |        |                   |                   |
            (-24,-24,0)---|                   |                   |
                          |                   |                   |
                     (-24,-24,1)----------(0,-24,1)-----------(25,-24,1)
$add labels
Two kinds of labels figure in Semper:
   (i) command labels - marking individual commands in programs or long
       command lines to which you transfer control via JUMP commands; JUMP
       gives more information.
  (ii) picture labels, which include such information as the dimensions,
       the type of data contained, the title etc.; TITLE, DATE, ORIGIN,
       RANGES, CLASS, FORM, and DISPLAY.SCALING give more information.  You
       can verify label information via the command EXAMINE or EXAMINE FULL
       when you want to; you can also use the command PCB to set variables
       to the values of the main picture parameters.
$add date lastwritten when updated changed
Semper picture labels record the date and time at which the picture was
created; 'creation' includes being replaced by a processed version with the
same number, though not being updated by the P command.

The information is verified by EXAMINE FULL.
$add devices storage pictures files discs
Semper pictures are stored in 'devices'.  A device may be a disc file
(containing pictures, help library or a program library),
or a framestore (or other display device), and up to a thousand pictures
may be stored in each one.  At least one device will usually be set up by your
session's startup file, but you can use ASSIGN later to open or close others,
so as to recover pictures dumped previously, get access
to larger amounts of workspace etc.

SHOW DEVICES reports the devices assigned to your session at any given time;
you can DEASSIGN devices, COMPRESS them to recover fragmented free space,
REINITIALISE them, and inspect their directories via DIRECTORY (ask HELP about
these).

You can dump groups of pictures to disc files outside Semper via SAVE, which
creates a disc file like any other Semper disc device; alternatively, you can
use WRITE, which is slower but writes in a variety of formats so as to allow
interchange with different program systems.

Semper also allows you to assign log files for the purposes of logging the
various kinds of textual information that can be obtained from a Semper
session, e.g. processing results, sequences of commands, error messages, etc.
You use the ASSIGN FILE command to create/open such files, then the ECHO
command to direct text into these files, and finally the DEASSIGN command to
close the files.
$add text logical output streams echo log files terminal page window
All of the textual information output during a Semper session is handled by a
centralised 'text echoing' facility.  The text is classified by being directed
to one of six logical output streams: console, diagnostic, log, monitor,
command and input streams.

Normal terminal output goes to the console output stream.  This includes
information listed by commands such as SHOW and EXAMINE and processing results
from commands such as PTYPE.  Indeed, the 'console' can be thought of as being
largely synonymous with the 'terminal'.  The distinction to be made between
them is that the 'console' is one of Semper's logical output streams, whereas
the 'terminal' is a physical output device to which text directed via the
'console' may in fact be output.

Errors and warnings and any other forms of un-solicited, diagnostic
information is directed to the diagnostic output stream.  Providing a separate
output stream for these types of messages means that they can readily be
suppressed or collected together in a log file (this is particularly useful
when running Semper non-interactively).

The log output stream is provided for text that is not suitable for output to
the terminal, usually because it is too voluminous or not suitably formatted.
Output to this stream is currently limited to the LOG, DISPLAY LOG and
HELP/LOG commands.

Semper provides a certain amount of internally generated diagnostic
information for the purposes of debugging and monitoring the software itself.
All this information is sent to the monitor output stream.  Monitor output is
controlled by the MONITOR command.  This facility is not recommended for use
by anyone who is unfamiliar with the internal workings of Semper.

All commands are 'reflected' or echoed to a separate logical output stream.
This allows you to log particular sequences of commands, in particular, the
commands contained in a Semper program which would not normally be reflected
on the terminal.

All other forms of input text (non-command input such as the response to the
ASK command) are reflected the logical output stream for non-command input.

All text written to these six logical output streams can be directed to one or
more physical output devices, i.e. the terminal and/or any assignable text
files.  You use the ECHO command to specify the physical destination(s) for
each of the logical output streams.  The logical output streams are specified
by means of the options CONSOLE, DIAGNOSTIC, LOG, MONITOR, COMMAND and INPUT.
The TERMINAL option refers to the terminal and the DEVICE key refers to an
assigned log file.  A log file is opened/created with the ASSIGN FILE
command and is subsequently referred to by its device number.  At the start of
a Semper session the console, diagnostic and monitor output streams are echoed
to the terminal.  When a log file is assigned, all echoing of text to that
file is turned off.  The SHOW ECHO command lists the current echo settings for
the terminal and any assigned log files.

When text is written to file it will be truncated if it exceeds the line width
specified by means of the WIDTH key in the ASSIGN FILE command.  If you
specify the APPEND option when assigning a log file, any output text will be
written at the end of the file.

The PAGE command controls how text is formatted when it is output to the
terminal.  You can specify values for the terminal window size (WIDTH and
LENGTH keys) and for the character aspect ratio.  You would use the PAGE
command at the start of a Semper session to change the these values if the
default settings (79, 24 and 2.00) are not appropriate for your terminal. Note
that if these settings exceed the actual terminal window size (which could
happen on an engineering workstation), the actual window size is used.  The
command SHOW PAGE lists both sets of values and the command PAGE ENQUIRE sets
Semper variables to the current page size.  All the commands which depend on
the character aspect ratio provide an ASPECT key to enable you to override the
current value.

If a line of text exceeds the current terminal width, it will normally be
truncated.  However, you can arrange for text to overflow onto the next line
by setting the WRAP option in the PAGE command.  Wrap-around of text can
subsequently be turned off with the NOWRAP option.  As each line of text is
output to the terminal, the text already displayed will scroll up the terminal
window.  If the stage is reached where the first line output since the last
interactive input of data is about to scroll off the top of the terminal
window, a prompt string will normally appear, giving you the option to step
forwards a line or a page at a time or else to quit out of the current
sequence of commands. The page prompt can be suppressed with the PAGE NOPROMPT
command and restored with the PROMPT option. The option to quit in response to
the page prompt can be disabled with the command PAGE NOQUIT.
$add errors trapping rc errorcodes problems faults
Semper's brief error messages are accompanied by a numerical code, e.g.
  ?41: Write-protected device/picture: 2051
If one does not make sense, try HELP ?41 (for error 41, etc.), which provides
further information on the possible causes for it.  SHOW ERRORS produces a
full list of standard error messages.  The REPORT ERROR command will print out
again the last error message output by Semper.

A short extract from the offending command line is also printed, and the stack
of program calls in force if the command was not entered interactively.
$
You can 'trap' errors if it matters enough to you, suppressing the normal
error message and allowing command interpretation to continue.  To trap error
41 during a given command, for example, you set TRAP to 41 at the beginning of
it, e.g. TRAP=41 DELETE 2051 (not TRAP=41; DELETE 2051).  Using the number -1
(e.g. TRAP=-1) traps all errors.  The error code returned by the last command
is placed in RC for you to test if you want to, e.g.
   TRAP=41 DELETE 2051; IF RC TYPE '..

The REPORT TRAP command will print out the message that Semper would have
output for the error that was most recently trapped.
$add forms representations datatypes precision storage pictures byte integer +
 fp complex
You can store Semper pictures in any of four 'forms' or representations:

               Typical
Number Name    Storage   Meaning
   0   Byte       1B     Small positive integer values
   1   Integer    2B     Positive and negative integer values
   2   Fp         4B     'Any' values
   3   Complex    8B     Pairs of Fp values

These allow a flexible trade-off between storage requirements and precision;
you can check the form of a given picture via EXAMINE, and PCB sets the
variables FORM to the corresponding number.  Generally speaking, all commands
can be applied to all forms without distinction, and you can force changes by
adding the new form name to a command, e.g. COPY 1 TO 2 FP.
$
BYTE     1B storage;  0 to 255, positive integers only
         compact but restrictive; you can't represent negative values, such as
         the difference between two pictures, or a high-pass filtered picture
INTEGER  2B storage usually; -32768 to 32767 or wider; integers
         less restrictive but still compact
FP       4B storage usually; 1e-35 to 1e+35 or wider; pos. and neg. values
         floating point (Fortran's REAL datatype); 6 decimal digit precision
         across the full range, but more storage required; used internally by
         most Semper commands
COMPLEX  8B storage usually; precision as for FP form
         pairs of FP values - for Fourier transforms, wave modelling, etc.

SHOW SYSTEM reports the number of bytes actually occupied by each form in
your installation.

You have no guarantee of sensible action if you force a picture into a form
its pixels will not fit, e.g. convert a picture with negative values to BYTE
form, or an FP picture with values as large as 1e20 into INTEGER form; your
session may simply abort, so take care.
$add fs current
The variable FS identifies the device number of your display device, and may
be used conveniently like DISPLAY in referring to display pictures, partitions
and frames, e.g. DISPLAY TO FS:2, LMEAN FS:11.  It is also assumed in a few
contexts when you omit the display device number, e.g. VIEW FRAME 2 (= VIEW
FRAME FS:2).

FS is set by the command ASSIGN DISPLAY; you can reset it yourself freely, but
no purpose is served by doing so in the current release of Semper: the
variable is present mainly to provide for later releases handling multiple
display devices simultaneously.
$add graphics overlay
Semper allows you to overlay vector and textual graphics (lines, outline
drawings and text - but not raster-scan images) on pictures, normally by
drawing them in a single bit 'overlay' independent of displays in the main
framestore memory; also, some commands make their own graphical annotation
to indicate such things as sub-regions being processed.

You can erase overlays independently (see ERASE).

You can write to them in various ways (see MARK).

You can use a display cursor for indicating positions, directions and
subregions (see XWIRES).

Subtopics: graphics.coordinates
$add graphics.coordinates
Most of the time, you use the standard 'picture' coordinates, relative to a
moveable origin, for overlaying text and line graphics on display pictures.
You may sometimes wish however to use other simpler systems, closer to the
framestore hardware, and Semper accordingly allows you also to use systems
that simply count hardware pixels, in the usual directions, from a partition
centre ('partition' coordinates) or a frame centre ('frame' coordinates).
You select the 'graphics coordinate mode', in all of the commands to which it
is relevant, by which of the options PICTURE, PARTITION and FRAME you use; for
example, the MARK command can be used in the following three ways:

   MARK PICTURE DIS:3 .. [or simply MARK DIS:3 ..]
     marks picture DIS:3 (picture DISPLAY in default), in picture coordinates
   MARK PARTITION DIS:5 ..
     marks partition DIS:5 (DISPLAY in default), in partition coordinates
   MARK FRAME 2 ..
     marks frame 2 (CFRAME in default), in frame coordinates
$
To illustrate the three systems, the following drawing shows a rectangular
frame, with a partition defined top right which in turn holds a picture whose
origin is near its bottom left; the position A on the display has picture
coords (x,y), partition coords (px,py) and frame coords (fx,fy).

     |----------------------------|------------------------|
     |                            |  ....................  |
     |                            |  .                  .  |
     |                         |  |  . |     |      A   .  |
     |                         |  |  . |     py         .  |
     |                        fy  |  . |     |          .  |
     |                         |  |  . y     O--px---   .  |
     |                         |  |  . |                .  |
     |                         O-----------fx--------   .  |
     |                            |  . O------x------   .  |
     |                            |  ...picture.border...  |
     |                            |                        |
     |                            |----partition-border----|
     |                                                     |
     |                                                     |
     |-frame-border----------------------------------------|

Graphical output is clipped at the partition limits for both picture and
partition modes, and at the frame limits for frame mode.

If you use the DISPLAY command to display a picture subregion, perhaps
magnified, the 'picture' coordinates used for graphical purposes remain those
of the original picture, even if their origin is outside the display; this is
useful for inspecting parts of large pictures closely, and is quite different
from what happens if you use CUT, MAGNIFY or EXTRACT to the display, for which
the output is quite independent of the source.

For 1-D graphs in picture mode, X = pixel coordinate, Y = pixel value (ranging
from the graph min to its max; for histograms in this mode, X = pixel value
(having the same range as the channels span), Y = pixel count (for what this
is worth).
$add histogram
Semper holds histograms as class Histogram pictures.  You can generate them
easily with the HISTOGRAM command; they are treated specially by DISPLAY
and SURVEY, and can be used by MAP for histogram equalisation or shape
forcing.

See also: histogram.command
$add keys
A key to a processing command is a name followed by a numerical value or
expression, specifying some detail of the operation to be performed.  You may
give a key a value in a command (e.g. MASK RADIUS 30), or allow it to default.

Help entries of the form -.SYNTAX (e.g. HELP MASK.SYNTAX, or HELP MAS.S for
short) give full lists of the keys recognised by each command, together with
details of their default values and any interactions between them.
$
You can force a key's value permanently by an assignment such as RADIUS=30,
and still override it in a given command, e.g. MASK RADIUS 25.  The facility
should be used with care however, especially with widely used keys.

See also:  syntax
$add luts itts lookuptables look-up-tables
For general information about dislay look-up-tables (Luts), see LUT.GENERAL.

For information on the LUT command, see LUT.COMMAND.

For information on class Lut pictures, see CLASS.LUT.

For information on how to apply an intensity transformation to a picture in a
permanent way, see MAP.
$add lut.general
Look-up tables (luts) are intensity or colour transformation tables used to
control how the pixel values stored in the display actually appear on the
screen.  They are defined and manipulated with the LUT command, and may be of
three modes:
    monochrome: a single intensity transformation table, used to map pixels
                from one display frame to all three monitor colours (or simply
                to the monitor if this is monochrome)
  false colour: three transformation tables, used to map one display frame to
                each of the three monitor colours
   full colour: three tables, used to map three consecutively numbered display
                frames to the red, green and blue monitor channels

Luts are numbered 1,2.. up to an installation-dependent maximum; SHOW LUTS
lists the numbers and modes of all luts currently defined.  A default lut
for viewing is associated with each partition (defined via the PARTITION
command, e.g. PARTITION 6 SIZE 256 TOP LEFT LUT 2), and you may request a
different one at any time via the VIEW command, e.g. VIEW LUT 3.  The lut
currently being used for viewing is said to be 'active', and it is the mode
of the active lut that determines whether presentation is in monochrome,
false colour or full colour form.
$
Semper makes no assumptions about luts at the start of a session: usually, you
define at least one in your startup file (e.g., LUT 1 CREATE defines a
monochrome lut 1).  You can alter luts in various ways using the LUT command:
in particular, you can enter an interactive mode where single keystrokes cause
instant stretching and compression of the grey or colour scales, and you can
transfer data between luts and Semper class Lut 'pictures'.

The maximum number of luts may be greater than is supported by your display
hardware; Semper provides its own lut storage, loading tables to the hardware
as appropriate.  If your hardware is capable of holding several tables
internally, switches between them are effected without the overhead of
reloading them.  The intermediate storage also allows apparent lut read-back
for adjustment even in installations where the display hardware does not
support it.
$add macros
Macros are predefined sequences of commands, command fragments, or other text,
recalled by typing an @ sign followed by an identifying number or name.

Exx: XWIRES REGION; DISPLAY @REGION  [= DISPLAY SIZE R,R2 POSITION X,Y]
     MACRO 20; ASK 'Picture: ' N; DISPLAY N; PS FULL LN;  DISPLAY
     @20
     MACRO 91; 'Subregion from 25 micron scan of stained specimen'
     TITLE 53 @91; TITLE 57 @91

Macros identified by names, like @region above, are built in to the command
interpreter; SHOW MACROS lists these.

Macros identified by numbers, like 20 and 91 above, are defined by MACRO
commands as in the examples, and are stored in class MACRO 'pictures'; EXAMINE
MACROS lists all the macros on the current device, and LIST lists the text of
any given one.  You can alter the text of one of these via EDIT.
$
NB: Two special restriction affect the use of numbered macros within programs,
though not macros used directly from terminal input:
   (i) macros called within programs may not contain labels or FOR loops;
  (ii) programs may not use the MACRO command to (re-)define macros.
$add mark
For information on the MARK command (for overlaying line and text graphics on
pictures, see MARK.COMMAND.

For information on the general key MARK, see MARK.KEY.
$add mark.key
To help you observe what they are doing clearly, several Semper commands can
mark positions, regions, directions etc. on the display screen.  To request
this, you set the key MARK to number of the display picture you want; thus
  $ CUT SIZE 400 @XY MARK DIS
outlines on the current display (DISPLAY) a region being cut out of the
current picture; and
  $ PROJECT 50 TO 51 ANGLE THETA MARK FS:3
marks an arrow on display picture FS:3 showing the direction in which it is
projecting picture 50.

The annotation may of course be of little value to you if the display is not
the same shape as the picture on which you are operating.

If you assign the value MARK=YES permanently, annotations are made on the
display current at the time of annotation; assigning MARK=DISPLAY causes them
to be made thereafter on the display current at the time of your assignment.
$add mkmode mark mksize
Semper normally uses a small upright (horizontal/vertical) cross when marking
a position on a display; if you want to change this (e.g. to distinguish one
of set of marks from another), you set MKMODE ('mark mode'), either globally
(by assignment) or locally (as a key), to one of the values in the following
list:
    1  Upright cross (default form)
    2  Diagonal cross
    3  Upright box
    4  Diagonal box
    5  Single pixel

You can control the size of the mark in a similar way via MKSIZE.  This
defaults to 2, and sets the (x/y) distance from the centre of the mark to its
edges - e.g. a box with MKSIZE 5 has sides 11 pixels long.
$add origin centres coordinates coords
For most picture classes, the default coordinate origin is at the physical
centre, rounded towards the right, the bottom and the back when the dimensions
are even.  For Fouriers, it may be at the centre of the left hand column
instead (half-plane transforms), while for Histograms, Plists and Luts, it is
at the far top left instead.

However, a picture label may record a different origin: the ORIGIN command
(see ORIGIN.COMMAND) allows you to put it anywhere you like within the
picture, so that you can use a different coordinate range subsequently if you
prefer.  You can check the origin position for any picture via EXAMINE FULL.
$add options
An option to a processing command is a name forcing some optional feature on
or off. You may force one on by quoting the option name (e.g. ERASE); or force
it off by quoting it with NO prefixed (e.g. NOERASE); or let it default.

Help entries of the form -.SYNTAX (e.g. HELP MASK.SYNTAX, or HELP MAS.S for
short) give full lists of the options recognised by each command, together
with details of their default states (usually NO) and any interactions between
them.
$
A few 'general' options are allowed with any command:
    BYTE, INTEGER, FP, COMPLEX  force the output picture form
    ERASE   causes automatic erasing before display output
    VIEW    causes automatic viewing (on monitor) of display picture(s), e.g.
            DISPLAY 53 VIEW
    RE, IM  for complex displays (with a real and an imaginary part), selects
            which part(s) are marked, erased etc.

Forcing an option on in fact causes the corresponding variable to be set with
value YES (=1) for the duration of the command.  Forcing it off sets it with
value NO (=0).  You can force an option either way permanently by an
assignment such as PRESET=YES or ERASE=NO, and still override it in a given
command, e.g. by DISPLAY NOPRESET or DISPLAY ERASE.  Amongst those you might
want to set permanently are:
    PRESET  causes MIN,MAX to be used (for example, in display scaling)
            instead of actual data range
    ERASE   causes automatic erasure before each new display output
    VERIFY  causes additional information to be printed on the console by some
            commands

See also:  syntax
$add erase.option erase
The general option ERASE controls whether display partitions are erased each
time a new picture is displayed within them; its default is NO, so that new
pictures overwrite existing ones as you watch.  To change the default, you
assign ERASE=YES (perhaps in your startup file).  In either case, you can
override the default in any command:

   DISPLAY 51 ERASE    to force an erase when the default is NO
   DISPLAY 42 NOERASE  to prevent the erase when the default is YES
$add partitions
Within Semper, you can subdivide a framestore's memory into 'partitions' of
whatever shape and size you like, and then use these independently.  The
partitions are numbered 1,2.. up to an installation dependent maximum; you
define (or re-define) their size and position with the PARTITION command
and thereafter refer to them as DIS:1, DIS:2.. (or FS:1, FS:2..).

Display pictures are stored at the centre of the partitions with the
corresponding number, and you cannot display pictures at all until you have
defined at least one partition; a default set is typically established
automatically for you by your startup file at the start of your session.

SHOW PARTITIONS lists the partitions you have currently defined, and
MARK PARTITION DIS:N BORDER can be used to outline partition DIS:N on the
display.

See also: partition.command
$add picturenumbers numbers devices
The different devices available to your session (see DEVICES) are numbered
1,2,3 etc.  Within each device, the individual pictures are given numbers
between 1 and 999.  You can set a default, or current, device at any time by
typing CD=2 etc., after which you need only quote the picture number (1,2,
3..) to refer to pictures within that device; to refer to pictures on other
devices you quote a device number together with the picture number, perhaps
using the special operator ':'.

Exx: 23 or :23        picture 23 on current device
     N or :N          picture N on current device
     3041 or 3:41     picture 41 on device 3
     2000+N or 2:N    picture N on device 2
     1000*D+N or D:N  picture N on device D
     DIS:2            picture 2 on display device
$add pixels points picturelements values
Pixels are 'picture elements' - the brightness sample values making up a
picture.  To find out the value of any pixel of the current picture (SELECT),
use the function P (or RE,IM for complex pictures - see FUNCTIONS),

 e.g.

    XWIRES; TYPE P(X,Y)

or PRINT @XY, if you want to examine a block of values printed together.  To
change the value of any pixel, use the P command:

    P X,Y,Z=VALUE,IVALUE

sets the pixel with coordinates X,Y,Z to the indicated value.  Y, Z and IVALUE
all default to zero if you omit them.  If the picture you want to inspect or
change is not current, make it so with the SELECT command.

See also: coordinates
$add Plists
Semper provides a picture class Plist in which lists of positions can be
held, either isolated as individual sites or connected to form curves.  You
can create these directly via the XWIRES command or indirectly with commands
such as PEAKS, and use them in commands such as MASK, MARK, PCURVE and MOTIF.

See also: class.plist
$add programs indirect deferred
Besides executing commands typed interactively at the terminal, Semper can
take 'indirect' commands in three ways:
- from 'numbered macros' created via the MACRO command
- from 'run files' created outside Semper with whatever text editor you
  normally use
- from 'programs' held in disc devices called 'program libraries'.

Commands or command fragments stored in response to commands such as
MACRO 52.. are recalled to the command line by constructions of the
form @52 (see MACROS).  They are stored in class Macro 'pictures', and
you can EDIT them within Semper if you wish; however their maximum length
is only that of a (continued) command line.

Commands stored in a run files are executed in response to commands of the
form RUN NAME 'MYFILE' (see RUNFILES).  A very important use of the facility
is the automatic running of a startup file at the start of each Semper
session: by editing this file you can configure the initial environment as you
please.

Individual programs in an assigned program library are executed in response
to commands of the form LIBRARY MOLECULE (see LIBRARY); for once, all the
letters of the program name are considered significant.  Programs may call
each other (and themselves) up to an installation-dependent maximum depth
(typically 8); execution is relatively efficient, as Semper maintains
directories not only for programs as a whole but also for individual labels,
loops etc. within each program.  You can LIST the contents of a program via
LIST PROGRAM 'progname', and add new ones via the ADD command.

See also: program.structure, add, run, runfiles, macros, library, libraries
$add program.libraries libraries
Program libraries hold the text of the programs called by the LIBRARY command.
SHOW DEVICES lists the program libraries assigned to your session just as it
lists other devices; you assign them via ASSIGN, and will usually find at
least one such library, common to all users at a given installation, assigned
automatically by the startup file.

SHOW PROGRAMS lists all the programs in all libraries you have assigned.  You
can ADD further programs to a library (HELP ADD gives details of the format
required); you can LIST them, COPY them, RENAME them and DELETE them.  You can
not at present edit them within a Semper session, but you can output them to a
file with LIST PROGRAM 'progname' NAME 'filename', leave Semper to edit them
(with the command SPAWN if available locally), return to Semper and reload the
edited version with ADD.

You create program libraries via ASSIGN NEW; you can use DIRECTORY to inspect
the amount of used and free space; you can COMPRESS libraries to recover
fragmented free space; and you can delete them via DEASSIGN DELETE.

When you have more than one program library assigned, commands concerned with
individual programs normally search all of them, the most recent being
searched first etc.; if you need to, you can vary the order via the ORDER
command (see ORDER).
$add program.structure
A program POLARS destined for a Semper program library might read as follows:

   Polars()         |                          |    Polars: ! rp/xy conversion
   X=R*cos(THETA)   |  or, for compatibility   |    X=R*cos(THETA)
   Y=R*sin(THETA)   |  with previous releases  |    Y=R*sin(THETA)
   End              |  only..                  |    Return
                    |                          |    End

Program names may contain any characters other than space, and may be as long
as you wish (up to a local limit, usually around 30 characters). The brackets
following the name are obligatory; future releases are likely to provide for
argument transmission to programs at this point.

A more useful example, determining the minimum and maximum of a series of
pictures, and illustrating the use of local variables and terminal dialogue,
might read as follows

   Seriesrange()
   Local s,s2,m,m2
      If set(s) & set(s2) jump scan
      Ask 'First,last picture in series ' s,s2
      Unless set(s) & set(s2) Return
      Scan: Survey s notype; m=min,max; For n=s+1,s2; Survey n notype
            m=min(m,min),max(m2,max); Loop
      min=m max=m2; Type 'Series range ',min,max
   End

Programs must be complete in themselves: you can only JUMP to labels within
the program, and FOR loops you open must be closed by LOOP commands within the
program.  However, a program file loaded by the ADD command may contain
several programs one after the other; and once they have been ADDed to a
library, all programs may call each other freely regardless of where they came
from.
$add protection writeprotection wp readonly
You may prevent yourself accidentally altering or deleting individual
pictures with the WP (Write-Protect) command (see WP.COMMAND).

you can check the status of a given picture with EXAMINE.

You may also protect complete devices, by quoting WP when you ASSIGN them.

You check the status of a given device with SHOW DEVICES.  You usually need
to quote WP to get access to a file that belongs to another user, as most
installations allow only read-access to other people's files.
$add ranges minimum maximum
Whenever the minimum and maximum values present in a picture are found, for
example by DISPLAY or SURVEY, the information is recorded in the picture
'label' for future use; should anything subsequently alter pixel values, the
range record is deleted automatically.  (Real and imaginary parts of complex
pictures are treated as equivalent for the purpose of range determination.)

The range is used by several commands; for example, the DISPLAY command scales
the pixels displayed so that the black,white range corresponds to that
recorded for the picture - providing automatic contrast stretching by default
in all displays.

You can check the range of any picture via EXAMINE FULL, if it is recorded
in the label, and via SURVEY otherwise.
$add regions subregions
You can specify picture subregions in many different ways; Semper commands are
generally consistent in their use of the relevant keys and options, and only
departures from the standard pattern are noted in the description of how to
use each command.

Examples of 2-D regions:
  SIZE 50                   50 square centred at origin
  SIZE 300,200              300 by 200 centred at origin
  SIZE 100 TOP LEFT         100 square top left
  SIZE 100 RIGHT            ..abutting centre of right hand side
  SIZE 100 POSITION 10,20   ..centred at (10,20)
  SIZE 100 BOTTOM RIGHT POSITION -1,1 ..one pixel away from bottom right
  @REGION                   ..previously indicated with XWIRES

Examples of multi-layer regions:
  LAYER 3                   layer 3 only
  SIZE 256,256,1 NEAR       front layer only of multi-layer 256 square picture
  SIZE 50,50 LAYER 1,3      50 square regions taken from first three layers
  SIZE 50,50,3 POSITION 100,50,2    3 50 square layers centred at (100,50,2)
  @REGION LAYERS 5,6        two-layer region indicated with XWIRES

Regions are normally truncated (clipped) where they overflow the source
picture boundary.  The exceptions are CUT, PASTE and EXTRACT which behave
differently when the region overflows:

  CUT          substitutes a default pixel value (VALUE key)
  PASTE        does nothing
  EXTRACT      wraps-around
$
More formally, all three components of SIZE default to the source picture
size, except that
   (i) if the first (SIZE) is quoted, SI2 defaults to SIZE (so that you may
       abbreviate SIZE 50,50 as SIZE 50)
  (ii) if LAYER is quoted and LA2 is not quoted, LA2 defaults to LAYER (so
       that you may abbreviate LAYER 3,3 as LAYER 3).

The region is positioned initially with its centre at the source
picture origin; options LEFT or RIGHT cause it to be placed with its left or
right side coinciding with that of the source, while BOTTOM,TOP and FAR,NEAR
have a similar effect in the other two directions; finally an additional
displacement POSITION is added.

You can indicate the number of layers either by SI3 or by LAYERS,LA2.  You may
not quote SI3 and LAYER together.  Commands that perform single-layer
processing will fault any use of the keys/options SI3, PO3, NEAR, FAR, LAYER
and LA2.
$add startup initialisation setup
For information on options to the command SEMPER itself, which you use to
start Semper sessions, see SEMPER.

What is described here is the next stage of session initialisation, after
those options have been implemented.

Very little is assumed by Semper at the start of a session; the equivalent
of the command RUN NAME 'SEMPER' is executed automatically however, and you
establish your own environment accordingly by writing a small run file
called SEMPER (see PROGRAMS and RUN).

A typical minimal file might be:

   ! Semper 6.45 - personal setup commands
      Assign name 'pictures'            [ assign file of pictures
      cd=n                              [ set CD to the device number assigned
      assign display                    [ (perhaps) assign the display device
      assign help name 'helplib'        [ assign help library
      assign program name 'proglib' wp  [ assign shared program library

      partition 1                       [ define partition 1 (frame 1, lut 1)
      lut 1 create                      [ create lut 1 for viewing
      erase=yes                         [ enable erases before display output
      return

The startup file might also contain a command LIBRARY SETUP, calling commands
common to all users at an installation.
$add tapes magtapes archives archiving storage
This version of Semper does not directly support magnetic tapes.
$add titles
Picture labels include a title of up to 150 characters, which you can set by
the TITLE command, or add to by TITLE ADD, and which are copied automatically
from source to output during most operations.

You can check the title of any picture via EXAMINE (but EXAMINE BRIEF omits
titles), and DISPLAY writes the title on the display screen.  A list of
pictures whose title contains a given string can be obtained via @FIND '..'

See also: title.command
$add variables parameters numbers numerical set unset
Semper maintains a list of named numerical variables; a given variable may be
'unset', in which case it is not present in the list at all, or set with a
particular value (verified most easily via TYPE, e.g. TYPE X).  The command
SHOW VARIABLES lists the names and values of all variables currently set.

You set variables when you need to by 'assignments', e.g. X=3 or THETA=PI/6;
some commands also return information to you via variables (e.g., XWIRES sets
X,Y to the coordinates of the point you indicate), which you may then pass on
to other commands, e.g.

    XWIRES; TYPE X,Y; EXTRACT SIZE 256 @X,Y

Using keys and options to extension commands also sets the corresponding
variables, but in this case the setting is 'local', in the sense that the
original value or unset state is restored when the command is finished.

You may use freely most variables not used as keys/options to extension
commands, but a few have special meanings as follows:

  Protected (cannot be reset or unset):
    RIC     Release Identification Code
    YES     = 1
    NO      = 0
    PI      = 3.14159
    SELECT  current (default) picture number; the most recently produced or
            inspected picture at any given time
    DISPLAY current (default) display picture/partition number
    CFRAME  current (default) display frame number
    CLUT    current (default) viewing look-up-table number
    RC      return code from last command
    BATCH   batch mode flag (= 1, if no interactive input possible)

  Fixed (may be reset, but not unset):
    MIN,MAX picture range (set by SURVEY, DISPLAY; used for display scaling)
    MEAN,ME2,SD picture mean and sd (set by SURVEY FULL)
    CD      Current Device number - used anywhere you omit the device number
    FS      current (default) FrameStore device number (not useful to change
            in current Semper release however)
    TRAP    used in error handling (see ERRORS)

See also HELP/FULL KEYS and HELP/FULL OPTIONS for other variables with
special meanings.
$add verify.option verify verification
Many commands can output to the console some form of verification message to
confirm the sucessful completion of the operation carried out or to list the
results of that operation.  Whether or not results are verified in this way
depends, in a uniform way, on the VERIFY option.

For commands that normally verify their results, the NOVERIFY option can be
used to suppress verification.  For example, the ASSIGN command usually
outputs the message 'Device n assigned', but this will be suppressed if the
NOVERIFY option is used.

Other commands do not normally verify their results, so with these you must
use the VERIFY option to force to do so, e.g. WARP VERIFY.

Globally setting VERIFY to YES will ensure that all commands will output their
verification messages (if any).  You should note, however, that the commands
HP, LMEAN, PROJECT and SHARPEN will confuse this with their own VERTICAL
option, so be careful when globally setting the VERFIY option.  You can also
suppress all verfication output by globally setting VERIFY to NO.

The commands PDRAW and XWIRES also provide a verification facility that
depends on the VERIFY option, but in this particular case it is displayed in
graphical form.
$add viewing zoom scroll pan roam frames
Where the display hardware has the necessary capabilities, Semper
allows you to control which frame, partition or picture is presented
on the viewing screen, where, and at what magnification, via the VIEW
command (see VIEW.COMMAND).

Semper does not automatically switch viewing conditions when you refer to
different areas of the display memory, allowing you to remain in direct
control of these yourself.

Viewing conditions ARE switched however if you use the option VIEW with any
command concerned with the display, and you can set this globally if you
like (e.g. VIEW=YES).  (See VIEW.OPTION)
$add view.option view
You use the general option VIEW with commands involving display pictures,
partitions or frames, when you want the display concerned to be made visible
on the monitor as if you had executed an appropriate VIEW command.  This
applies to any processing command that operates on a display picture and also
the commands ERASE, MARK, RAMPS and XWIRES, which operate directly on the
display.  Note, however that the XWIRES command switches the viewing
conditions unless option VIEW is set to NO.  This ensures that the cursor is
made visible when no option is given.

Exx: DISPLAY 23 VIEW
     COPY TO DIS:3 VIEW
     SHARPEN DIS:2 VIEW
     MARK BORDER PARTITION DIS:7 VIEW
     RAMPS FRAME 3 VIEW

If you have set variables ZOOM, PAN and/or LUT, the viewing conditions are set
so as to honour these, just as for the VIEW command itself.
$add bclose.command bclose open close binary morphology structuring element
You use BCLOSE to carry out generalised binary closing of foreground regions.
The way in which the closing is carried out is determined by the structuring
element specified by means of the WITH key.  The output picture will contain
the binary, closed result, which represents the complement of the the area
swept out by the reflection of the structuring element about the origin,
whilst this is contained entirely within the background regions of the source
image.  Closing smoothes the boundary of foreground regions by filling in
small concavities, it fills in narrow gaps between regions and it removes
holes that are smaller than the structuring element.  Closing is idempotent -
closing an already closed image does not change the image.

BCLOSE has exactly the same keys and options as the commands BDILATE and
BERODE and it produces exactly the same result as using the command BDILATE
followed by BERODE with the same settings for the controlling keys and
options, but in less time.

Exx: CREATE 99 SIZE 3 VALUE 1; BCLOSE 1 WITH 99
       closes picture 1 with square, 3 by 3 structuring element.
     BCLOSE 1 2 WITH 99 TIMES 3
       equivalent to the following
     BDILATE 1 2 WITH 99 TIMES 3; BERODE 2 WITH 99 TIMES 3
$
Closing a binary image with a structuring element is equivalent to dilating
and then eroding the image with the same structuring element.  For example,

      0 0 0 0 0 0 0 0 0                   0 0 0 0 0 0 0 0 0
      0 0 0 0 0 0 0 0 0                   0 0 0 0 0 0 0 0 0
      0 0 0 1 0 1 1 0 0                   0 0 0 1 1 1 1 0 0
      0 0 1 0 1 1 1 0 0       1 1 1       0 0 1 1 1 1 1 0 0
      0 0 1 1[1]1 1 0 0  (.)  1[1]1   =   0 0 1 1[1]1 1 0 0
      0 0 1 0 0 0 0 0 0       1 1 1       0 0 1 1 1 1 1 0 0
      0 0 0 0 1 1 1 0 0                   0 0 0 0 1 1 1 0 0
      0 0 0 0 0 1 0 0 0                   0 0 0 0 0 1 0 0 0
      0 0 0 0 0 0 0 0 0                   0 0 0 0 0 0 0 0 0

where (.) denotes closing and [ ] marks the origin of the picture and the
structuring element.  Compare this with the result obtained by erosion
followed by dilation,

      0 0 0 0 0 0 0 0 0                   0 0 0 0 0 0 0 0 0
      0 0 0 0 0 0 0 0 0                   0 0 1 1 1 1 1 1 0
      0 0 0 1 0 1 1 0 0                   0 1 1 1 1 1 1 1 0
      0 0 1 0 1 1 1 0 0       1 1 1       0 1 1 1 1 1 1 1 0
      0 0 1 1[1]1 1 0 0  (+)  1[1]1   =   0 1 1 1[1]1 1 1 0
      0 0 1 0 0 0 0 0 0       1 1 1       0 1 1 1 1 1 1 1 0
      0 0 0 0 1 1 1 0 0                   0 1 1 1 1 1 1 1 0
      0 0 0 0 0 1 0 0 0                   0 0 0 1 1 1 1 1 0
      0 0 0 0 0 0 0 0 0                   0 0 0 0 1 1 1 0 0

      0 0 0 0 0 0 0 0 0                   0 0 0 0 0 0 0 0 0
      0 0 1 1 1 1 1 1 0                   0 0 0 0 0 0 0 0 0
      0 1 1 1 1 1 1 1 0                   0 0 0 1 1 1 1 0 0
      0 1 1 1 1 1 1 1 0       1 1 1       0 0 1 1 1 1 1 0 0
      0 1 1 1[1]1 1 1 0  (-)  1[1]1   =   0 0 1 1[1]1 1 0 0
      0 1 1 1 1 1 1 1 0       1 1 1       0 0 1 1 1 1 1 0 0
      0 1 1 1 1 1 1 1 0                   0 0 0 0 1 1 1 0 0
      0 0 0 1 1 1 1 1 0                   0 0 0 0 0 1 0 0 0
      0 0 0 0 1 1 1 0 0                   0 0 0 0 0 0 0 0 0

where (-) denotes erosion, (+) denotes dilation.

The source picture is treated as a binary image: zero values denote background
pixels and non-zero values denote foreground pixels.

Each layer of the picture specified by means of the WITH key defines a
structuring element to be applied to the source picture.  Non-zero pixels
define the components of the structuring element.  Any zero pixels are
ignored.  The origin of the picture defines the origin of the structuring
element.

For example,

      0 0 0 0 0                        0 0 1 0 0         1
      0 0 1 0 0          1             0 0 1 0 0         1
      0 1[2]1 0   =>   1[1]1           0 0 1 0 0   =>   [1]
      0 0 1 0 0          1             0 0 1 0 0         1
      0 0 0 0 0                        0 0 1 0 0         1

If there is more than one layer, the structuring elements thus defined are
applied in sequence, starting with layer 1. This allows you to specify large
structuring elements in decomposed form.  You can also use the TIMES key to
apply the sequence of structuring elements more than once.  The structuring
element that a decomposed set represents is obtained by combining the
decomposed set using dilation.

For example,

      1 1 1 1 1 1 1 1 1
      1 1 1 1 1 1 1 1 1
      1 1 1 1 1 1 1 1 1
      1 1 1 1 1 1 1 1 1       1 1 1       1 1 1       1 1 1       1 1 1
      1 1 1 1[1]1 1 1 1   =   1[1]1  (+)  1[1]1  (+)  1[1]1  (+)  1[1]1
      1 1 1 1 1 1 1 1 1       1 1 1       1 1 1       1 1 1       1 1 1
      1 1 1 1 1 1 1 1 1
      1 1 1 1 1 1 1 1 1
      1 1 1 1 1 1 1 1 1

      1 1 1                    1
      1[1]1   =   1[1]1  (+)  [1]
      1 1 1                    1

As you can see, the 9 by 9 structuring element can be decomposed into four 3
by 1 structuring elements and four 1 by 3 structuring elements.  As dilation
is a commutative operation, the structuring elements can be applied in any
order.  The simplest way to apply this example is to create a two-layer
picture with the 3 by 1 structuring element in one layer and the 1 by 3
structuring element in the other layer, specify this picture by means of the
WITH key and set the TIMES key to 4.

The MASK key can be used to restrict processing to specified regions of the
image.  The options SOURCE and OUTPUT and the EDGE key allow you to control
edge effects.  For more detailed information about these and related topics,
consult the documentation for the commands BERODE and BDILATE.

See also: bclose.syntax, berode, bdilate
$add bclose.syntax
Keys:
  [FROM]        source picture [SELECT]
  [TO]          destination picture [FROM]
  WITH          picture specifying structuring element data
  MASK          mask picture to restrict processing to specified region [none]
  TIMES         number of times to apply structuring element data [1]
  EDGE          edge value [0]

Options:
  SOURCE | OUTPUT  fix value of source/output edge pixels according to the
                   value of the EDGE key

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add bdilate.command bdilate dilate binary morphology structuring element
You use BDILATE to carry out generalised binary dilation of foreground
regions.  The way in which the dilation is carried out is determined by the
structuring element specified by means of the WITH key.  The result of
applying each structuring element is obtained by sweeping it over the source
image and combining all those instances where its origin coincides with a
non-zero pixel in the source image.  The technique is most often used to add
layers of pixels round the boundaries of foreground regions, which is why it
is called dilation.

Exx: CREATE 99 SIZE 3 VALUE 1; BDILATE 1 WITH 99 TIMES 1
       adds one layer of pixels to all foreground objects in picture 1
       (same result as DILATE 1 TIMES 1)
     CREATE 99 SIZE 3 VALUE 1; BDILATE 1 WITH 99 TIMES 4
  or CREATE 99 SIZE 9 VALUE 1; BDILATE 1 WITH 99 TIMES 1
  or CREATE 99 SIZE 3,3,4 VALUE 1; BDILATE 1 WITH 99 TIMES 1
       adds four layers of pixels to all foreground objects in picture 1
       (same result as DILATE 1 TIMES 4)
     CREATE 99 SIZE 9,9,2 VALUE 0; FOR I=-4,4; P I,0,-1=1; P 0,I,0=1; LOOP;
     BDILATE 1 WITH 99 TIMES 1
       dilates foreground objects in picture 1 with 9 by 9 square structuring
       element which has been decomposed into two much reduced structuring
       elements (gives same result as previous example but in less time)
$
The source picture is treated as a binary image: zero values denote background
pixels and non-zero values denote foreground pixels.

Each layer of the picture specified by means of the WITH key defines a
structuring element to be applied to the source picture.  If there is more
than one layer, the structuring elements thus defined are applied in sequence,
starting with layer 1.  Non-zero pixels define the components of a structuring
element.  Any zero pixels are ignored.  The origin of the picture defines the
origin of the structuring element.

For example,

      0 0 0 0 0                        0 0 1 0 0         1
      0 0 1 0 0          1             0 0 1 0 0         1
      0 1[2]1 0   =>   1[1]1           0 0[1]0 0   =>   [1]
      0 0 1 0 0          1             0 0 1 0 0         1
      0 0 0 0 0                        0 0 1 0 0         1

where [ ] marks the origin of the picture and the structuring element.

The process of dilating an object with a structuring element is very similar
to a "paintbrush" operation if you think of the structuring element as the
brush and the foreground pixels in the source image as defining the brush
positions.

For example,

      0 0 0 0 0                   0 1 1 1 0
      0 0 1 0 0       1 1 1       1 1 1 1 1
      0 1[1]1 0  (+)  1[1]1   =   1 1[1]1 1
      0 0 1 0 0       1 1 1       1 1 1 1 1
      0 0 0 0 0                   0 1 1 1 0

where (+) denotes dilation.

Dilation is a commutative operation so it is equally valid to think of the
source image as the brush and the structuring element as defining the brush
offsets.  The result is the union (logical OR) of the translates of the source
image where the position of each non-zero pixel in the structuring element
with respect to the origin defines an offset to be applied to the source
image.

For example,

      0 0 0 0 0                  0 0 0 0 0       0 0 0 0 0       0 0 0 0 0
      0 0 1 0 0                  0 0 1 0 0       0 0 0 1 0       0 0 1 1 0
      0 1[1]1 0  (+)  [1]1   =   0 1[1]1 0  (|)  0 0[1]1 1   =   0 1[1]1 1
      0 0 1 0 0                  0 0 1 0 0       0 0 0 1 0       0 0 1 1 0
      0 0 0 0 0                  0 0 0 0 0       0 0 0 0 0       0 0 0 0 0

where (|) denotes union.

With a multi-layer picture you can specify a series of structuring elements to
be applied in turn.  For example, the following result

      0 0 0 0 0 0 0                   0 0 1 1 1 0 0
      0 0 0 1 0 0 0                   0 0 1 1 1 1 0
      0 0 0 1 1 0 0       1 1 1       0 0 1 1 1 1 0
      0 0 0[0]1 0 0  (+)  1[1]1   =   0 1 1[1]1 1 0
      0 0 1 1 0 0 0       1 1 1       0 1 1 1 1 1 0
      0 0 0 0 0 0 0                   0 1 1 1 1 0 0
      0 0 0 0 0 0 0                   0 0 0 0 0 0 0

can be obtained with fewer operations by applying two simpler structuring
elements

      0 0 0 0 0 0 0                   0 0 0 0 0 0 0
      0 0 0 1 0 0 0                   0 0 1 1 1 0 0
      0 0 0 1 1 0 0       0 0 0       0 0 1 1 1 1 0
      0 0 0[0]1 0 0  (+)  1[1]1   =   0 0 0[1]1 1 0
      0 0 1 1 0 0 0       0 0 0       0 1 1 1 1 0 0
      0 0 0 0 0 0 0                   0 0 0 0 0 0 0
      0 0 0 0 0 0 0                   0 0 0 0 0 0 0

      0 0 0 0 0 0 0                   0 0 1 1 1 0 0
      0 0 1 1 1 0 0                   0 0 1 1 1 1 0
      0 0 1 1 1 1 0       0 1 0       0 0 1 1 1 1 0
      0 0 0[1]1 1 0  (+)  0[1]0   =   0 1 1[1]1 1 0
      0 1 1 1 1 0 0       0 1 0       0 1 1 1 1 1 0
      0 0 0 0 0 0 0                   0 1 1 1 1 0 0
      0 0 0 0 0 0 0                   0 0 0 0 0 0 0

Decomposing large structuring elements in this way can significantly reduce
the processing time.  A structuring element can be decomposed in this way if a
set of structuring elements can be found which result in the original
structuring element when they are combined by dilation.  The above example
illustrates this, that is,

      0 0 0       0 1 0       1 1 1
      1[1]1  (+)  0[1]0   =   1[1]1
      0 0 0       0 1 0       1 1 1

The processing time depends in part on the number of non-zero pixels in the
structuring element.  In the example above, there are nine in the original
version and six altogether in the decomposed version, a reduction of two-
thirds in the number of source image translations.  Set against this is the
fact that two iterations are required instead of one.  For such a small
example decomposing the structuring element has no advantage.  For a 21 by 21
structuring element decomposed in the same way, however, the time taken is
reduced by a factor or 4 or 5.

Decomposing structuring elements can be used to good advantage as the
following examples illustrate

      0 0 1 1 1 0 0
      0 1 1 1 1 1 0
      1 1 1 1 1 1 1     0 0 0     0 0 1     0 1 0     1 0 0     0 0 0
      1 1 1[1]1 1 1  =  0[1]1 (+) 0[1]0 (+) 0[1]0 (+) 0[1]0 (+) 1[1]0
      1 1 1 1 1 1 1     0 0 0     0 0 0     0 0 0     0 0 0     0 0 0
      0 1 1 1 1 1 0
      0 0 1 1 1 0 0               0 0 0     0 0 0     0 0 0
                              (+) 0[1]0 (+) 0[1]0 (+) 0[1]0
                                  1 0 0     0 1 0     0 0 1

      0 0 0 0 0 0 1 1 1
      0 0 0 0 0 1 1 1 1     0 0 0 0 0 0 1     0 0 0 0 0 0 0     0 0 0 0 0 0 0
      0 0 0 0 1 1 1 1 1     0 0 0 0 0 1 0     0 0 0 0 0 0 0     0 0 0 0 0 0 0
      0 0 0 1 1 1 1 1 0     0 0 0 0 1 0 0     0 0 0 0 0 0 0     0 0 0 1 0 0 0
      0 0 1 1[1]1 1 0 0  =  0 0 0[1]0 0 0 (+) 0 0 1[1]1 0 0 (+) 0 0 0[1]0 0 0
      0 1 1 1 1 1 0 0 0     0 0 1 0 0 0 0     0 0 0 0 0 0 0     0 0 0 1 0 0 0
      1 1 1 1 1 0 0 0 0     0 1 0 0 0 0 0     0 0 0 0 0 0 0     0 0 0 0 0 0 0
      1 1 1 1 0 0 0 0 0     1 0 0 0 0 0 0     0 0 0 0 0 0 0     0 0 0 0 0 0 0
      1 1 1 0 0 0 0 0 0

The whole process can be repeated by specifying the number of iterations with
the TIMES key.  The default is to carry out one iteration.  Processing is
stopped if no change is detected after applying one complete sequence of
structuring elements.

The MASK key can be used to restrict processing to specified regions of the
image, that is, wherever mask pixels are zero, the source pixel value is
output and elsewhere, the dilated result is substituted.  Of course, the mask
picture must have the same dimensions as the source picture.  For example, the
mask image

      0 0 1 0 0 0 0
      0 1 1 1 0 0 0
      0 1 1 1 0 1 0
      0 0 0 1 1 1 0
      0 0 0 1 1 1 0
      0 0 0 1 1 0 0
      0 0 0 0 0 0 0

when applied to one of the previous examples

      0 0 0 0 0 0 0                   0 0 1 1 1 0 0
      0 0 0 1 0 0 0                   0 0 1 1 1 1 0
      0 0 0 1 1 0 0       1 1 1       0 0 1 1 1 1 0
      0 0 0[0]1 0 0  (+)  1[1]1   =   0 1 1[1]1 1 0
      0 0 1 1 0 0 0       1 1 1       0 1 1 1 1 1 0
      0 0 0 0 0 0 0                   0 1 1 1 1 0 0
      0 0 0 0 0 0 0                   0 0 0 0 0 0 0

gives the modified result

      0 0 . 0 0 0 0     . . 1 . . . .       0 0 1 0 0 0 0
      0 . . . 0 0 0     . 0 1 1 . . .       0 0 1 1 0 0 0
      0 . . . 1 . 0     . 0 1 1 . 1 .       0 0 1 1 1 1 0
      0 0 0 . . . 0  +  . . . 1 1 1 .   =   0 0 0 1 1 1 0
      0 0 1 . . . 0     . . . 1 1 1 .       0 0 1 1 1 1 0
      0 0 0 . . 0 0     . . . 1 1 . .       0 0 0 1 1 0 0
      0 0 0 0 0 0 0     . . . . . . .       0 0 0 0 0 0 0

So far, the result for dilation has not been defined round the edges of an
image where any part of the structuring element falls outside the limits of
the source picture.  By default, the process of calculating the union of the
translates of the source image simply omits any undefined source pixels.  If
all the source pixels which contribute to the result for a particular output
pixel are undefined, the output pixel defaults to 0.

As an alternative, the SOURCE option allows you to specify a value for any
pixel positions outside the source image which contribute to a translate of
the source image.  You specify the actual value with the EDGE key.  All
non-zero values for the EDGE key imply an edge value of 1.  The combination
SOURCE EDGE 0 in fact produces the same result as the default case.

For example,

      0 0 1 0 0                 0 0 1 0 0       1 0 0 0 E       E E E E E
      0 1 0 0 0       1 0       0 1 0 0 0       1 1 1 0 E       0 0 1 0 0
      0 1[1]1 0  (+)  0[1]  =   0 1[1]1 0  (|)  0 0[0]0 E  (|)  0 1[0]0 0
      0 0 0 0 0       0 1       0 0 0 0 0       0 0 0 0 E       0 1 1 1 0
      0 0 0 0 0                 0 0 0 0 0       E E E E E       0 0 0 0 0

                                1 E 1 E E
                                1 1 1 0 E
                            =   0 1[1]1 E
                                0 1 1 1 E
                                E E E E E

where E represents the source edge value.

Instead of using the SOURCE option, you can, with the OUTPUT option and the
EDGE key, specify a value to assign to output pixels wherever the result
depends on undefined source pixels.

For example,

      0 0 1 0 0                 E E E E E
      0 1 0 0 0       1 0       1 1 1 0 E
      0 1[1]1 0  (+)  0[1]  =   0 1[1]1 E
      0 0 0 0 0       0 1       0 1 1 1 E
      0 0 0 0 0                 E E E E E

where E represents the output edge value.

See also: bdilate.syntax
$add bdilate.syntax
Keys:
  [FROM]        source picure [SELECT]
  [TO]          destination picture [FROM]
  WITH          picture specifying structuring element data
  MASK          mask picture to restrict processing to specified region [none]
  TIMES         number of times to apply structuring element data [1]
  EDGE          edge value [0]

Options:
  SOURCE | OUTPUT  fix value of source/output edge pixels according to the
                   value of the EDGE key

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add beep.command bell.command buzzer.command beep bell buzzer
The BEEP command (also known as BELL and BUZZER) will sound the local keyboard
alert if possible.  This can be useful to signal completion of a long process
or to draw the user's attention to a request for input.
$add beep.syntax bell.syntax buzzer.syntax
This command does not take any arguments.
$add berode.command berode erode binary morphology structuring element
You use BERODE to carry out generalised binary erosion of foreground regions.
The way in which the erosion is carried out is determined by the structuring
element specified by means of the WITH key.  The result of applying each
structuring element is obtained by positioning the origin of the structuring
element over each source pixel and outputing a 1 if the structuring element
matches the source image in that position.  The technique is most often used
to remove layers of pixels round the boundaries of foreground regions, which
is why it is called erosion.

Exx: CREATE 99 SIZE 3 VALUE 1; BERODE 1 WITH 99 TIMES 1
       removes one layer of pixels from all foreground objects in picture 1
       (same result as ERODE 1 TIMES 1)
     CREATE 99 SIZE 3 VALUE 1; BERODE 1 WITH 99 TIMES 4
  or CREATE 99 SIZE 9 VALUE 1; BERODE 1 WITH 99 TIMES 1
  or CREATE 99 SIZE 3,3,4 VALUE 1; BERODE 1 WITH 99 TIMES 1
       removes four layers of pixels from all foreground objects in picture 1
       (same result as ERODE 1 TIMES 4)
     CREATE 99 SIZE 9,9,2 VALUE 0; FOR I=-4,4; P I,0,-1=1; P 0,I,0=1; LOOP;
     BERODE 1 WITH 99 TIMES 1
       erodes foreground objects in picture 1 with 9 by 9 square structuring
       element which has been decomposed into two much reduced structuring
       elements (gives same result as previous example but in less time)
$
The source picture is treated as a binary image: zero values denote background
pixels and non-zero values denote foreground pixels.

Each layer of the picture specified by means of the WITH key defines a
structuring element to be applied to the source picture.  If there is more
than one layer, the structuring elements thus defined are applied in sequence,
starting with layer 1.  Non-zero pixels define the components of a structuring
element.  Any zero pixels are ignored.  The origin of the picture defines the
origin of the structuring element.

For example,

      0 0 0 0 0                        0 0 1 0 0         1
      0 0 1 0 0          1             0 0 1 0 0         1
      0 1[2]1 0   =>   1[1]1           0 0[1]0 0   =>   [1]
      0 0 1 0 0          1             0 0 1 0 0         1
      0 0 0 0 0                        0 0 1 0 0         1

where [ ] marks the origin of the picture and the structuring element.

The process of eroding an object with a structuring element can be explained
in simple terms if you think of the structuring element as a binary template.
The origin of the structuring element is positioned over each source pixel in
turn and a 1 is output if the structuring element matches the source image,
that is, if every non-zero component of the structuring element coincides with
a non-zero pixel in the source image.  Otherwise a 0 is output.  Erosion
functions just like a Hit or Miss transform where the structuring element
defines only "hits".  For more details about Hit or Miss transforms consult
the documentation for the BHMT command.

For example,

      0 0 0 1 0                  0 0 0 0 0
      0 1 1 0 0                  0 0 1 0 0
      0 0[1]1 1  (-)  1[1]   =   0 0[0]1 1
      0 1 1 0 0                  0 0 1 0 0
      0 1 0 0 0                  0 0 0 0 0

where (-) denotes erosion.

An equivalent definition for erosion can be obtained by combining translates
of the source image.  The result is the intersection (logical AND) of the
translates of the source image where the position of the origin of the
structuring element with respect to each non-zero pixel in the structuring
element defines an offset to be applied to the source image.

For example,

      0 0 0 0 0                  0 0 0 0 0       0 0 0 0 0       0 0 0 0 0
      0 0 1 0 0        0 1       0 0 1 0 0       0 0 0 0 0       0 0 0 0 0
      0 1[1]1 0  (-)  [1]0   =   0 1[1]1 0  (&)  0 1[0]0 0   =   0 1[0]0 0
      0 0 1 0 0                  0 0 1 0 0       1 1 1 0 0       0 0 1 0 0
      0 0 0 0 0                  0 0 0 0 0       0 1 0 0 0       0 0 0 0 0

where (&) denotes intersection.

With a multi-layer picture you can specify a series of structuring elements to
be applied in turn.  For example, the following result

      0 0 0 0 0 0 0                   0 0 0 0 0 0 0
      0 0 0 1 0 0 0                   0 0 0 0 0 0 0
      0 0 1 1 1 0 0       1 1 1       0 0 0 0 0 0 0
      0 1 1[1]1 1 0  (-)  1[1]1   =   0 0 0[1]0 0 0
      0 1 1 1 1 0 0       1 1 1       0 0 1 1 0 0 0
      0 1 1 1 1 0 0                   0 0 0 0 0 0 0
      0 0 0 0 0 0 0                   0 0 0 0 0 0 0

can be obtained with fewer operations by applying two simpler structuring
elements

      0 0 0 0 0 0 0                   0 0 0 0 0 0 0
      0 0 0 1 0 0 0                   0 0 0 0 0 0 0
      0 0 1 1 1 0 0       0 0 0       0 0 0 1 0 0 0
      0 1 1[1]1 1 0  (-)  1[1]1   =   0 0 1[1]1 0 0
      0 1 1 1 1 0 0       0 0 0       0 0 1 1 0 0 0
      0 1 1 1 1 0 0                   0 0 1 1 0 0 0
      0 0 0 0 0 0 0                   0 0 0 0 0 0 0

      0 0 0 0 0 0 0                   0 0 0 0 0 0 0
      0 0 0 0 0 0 0                   0 0 0 0 0 0 0
      0 0 0 1 0 0 0       0 1 0       0 0 0 0 0 0 0
      0 0 1[1]1 0 0  (-)  0[1]0   =   0 0 0[1]0 0 0
      0 0 1 1 0 0 0       0 1 0       0 0 1 1 0 0 0
      0 0 1 1 0 0 0                   0 0 0 0 0 0 0
      0 0 0 0 0 0 0                   0 0 0 0 0 0 0

Decomposing large structuring elements in this way can significantly reduce
the processing time.  A structuring element can be decomposed if a set of
structuring elements can be found which result in the original structuring
element when combined by dilation.  The above example illustrates this.

      0 0 0       0 1 0       1 1 1
      1[1]1  (+)  0[1]0   =   1[1]1
      0 0 0       0 1 0       1 1 1

where (+) denotes dilation.

For a precise definition of dilation and more information about decomposing
structuring elements, consult the documentation for the BDILATE command.

The whole process can be repeated by specifying the number of iterations with
the TIMES key.  The default is to carry out one iteration.  Processing is
stopped if no change is detected after applying one complete sequence of
structuring elements.

The MASK key can be used to restrict processing to specified regions of the
image, that is, wherever mask pixels are zero, the source pixel value is
output and elsewhere, the eroded result is substituted.  Of course, the mask
picture must have the same dimensions as the source picture.  For example, the
mask image

      0 0 0 0 0 0 0
      0 0 0 0 0 0 0
      0 0 0 0 0 0 0
      0 1 1 1 1 1 1
      0 1 1 1 1 1 1
      0 1 1 1 1 1 1
      0 0 0 0 0 0 0

when applied to one of the previous examples

      0 0 0 0 0 0 0                   0 0 0 0 0 0 0
      0 0 0 1 0 0 0                   0 0 0 0 0 0 0
      0 0 1 1 1 0 0       1 1 1       0 0 0 0 0 0 0
      0 1 1[1]1 1 0  (-)  1[1]1   =   0 0 0[1]0 0 0
      0 1 1 1 1 0 0       1 1 1       0 0 1 1 0 0 0
      0 1 1 1 1 0 0                   0 0 0 0 0 0 0
      0 0 0 0 0 0 0                   0 0 0 0 0 0 0

gives the following result

      0 0 0 0 0 0 0     . . . . . . .       0 0 0 0 0 0 0
      0 0 0 1 0 0 0     . . . . . . .       0 0 0 1 0 0 0
      0 0 1 1 1 0 0     . . . . . . .       0 0 1 1 1 0 0
      0 . . . . . .  +  . 0 0 1 0 0 0   =   0 0 0 1 0 0 0
      0 . . . . . .     . 0 1 1 0 0 0       0 0 1 1 0 0 0
      0 . . . . . .     . 0 0 0 0 0 0       0 0 0 0 0 0 0
      0 0 0 0 0 0 0     . . . . . . .       0 0 0 0 0 0 0

So far, the result for erosion has not been defined round the edges of an
image where any part of the structuring element falls outside the limits of
the source picture.  By default, the process of calculating the intersection
of the translates of the source image simply omits any undefined source
pixels.  If all the source pixels which contribute to the result for a
particular output pixel are undefined, the output pixel defaults to 1.

As an alternative, the SOURCE option allows you to specify a value for any
pixel positions outside the source image which contribute to a translate of
the source image.  You specify the actual value with the EDGE key.  All non-
zero values for the EDGE key imply an edge value of 1.  For erosion, an edge
value of zero effectively closes off all foreground regions which touch the
edge of the image.  A non-zero edge value leaves regions "open" - it is as if
regions extend indefinitely at right angles to the edges of the image.  The
combination SOURCE EDGE 1 in fact produces the same result as the default
case.

For example,

      0 1 0 0 0                 0 1 0 0 0       E E E E E       0 1 1 0 0
      0 1 1 0 0       1 0       0 1 1 0 0       E 0 1 0 0       0 1 1 1 0
      0 1 1 1 0  (-)  0[1]  =   0 1 1 1 0  (&)  E 0 1 1 0  (&)  0 1 1 0 1
      0 1 1 0 1       0 1       0 1 1 0 1       E 0 1 1 1       0 0 0 1 1
      0 0 0 1 1                 0 0 0 1 1       E 0 1 1 0       E E E E E

                                0 E 0 0 0
                                0 0 1 0 0
                            =   0 0 1 0 0
                                0 0 0 0 1
                                0 0 0 E 0

where E represents the source edge value.

Instead of using the SOURCE option, you can, with the OUTPUT option and the
EDGE key, specify the value to assign to output pixels wherever the result
depends on undefined source pixels.  A zero output edge value is particularly
useful when using erosion for templating operations.  It eliminates possible
edge effects because output pixels can only be set if the structuring element
lies fully inside the source image.  A non-zero pixel in the output image
means that the structuring element exactly matched the source image at that
position.

For example,

      0 1 0 0 0                 E E E E E
      0 1 1 0 0       1 0       E 0 1 0 0
      0 1 1 1 0  (-)  0[1]  =   E 0 1 0 0
      0 1 1 0 1       0 1       E 0 0 0 1
      0 0 0 1 1                 E E E E E

where E represents the output edge value.

See also: berode.syntax, bhmt, bdilate
$add berode.syntax
Keys:
  [FROM]        source picure [SELECT]
  [TO]          destination picture [FROM]
  WITH          picture specifying structuring element data
  MASK          mask picture to restrict processing to specified region [none]
  TIMES         number of times to apply structuring element data [1]
  EDGE          edge value [0]

Options:
  SOURCE | OUTPUT  fix value of source/output edge pixels according to the
                   value of the EDGE key

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add bhmt.command bhmt hit miss transform binary morphology +
     structuring element
You use BHMT to calculate generalised binary Hit or Miss transforms.  The
details of a particular transform are determined by the structuring element
specified by means of the WITH key.  The result of applying each structuring
element is obtained by positioning the origin of the structuring element over
each source pixel and outputing a 1 if the structuring element matches the
source image in that position.  Thickening and thinning transformations can be
achieved by specifying the ADD or SUBTRACT options.  An example of this is
obtaining the binary skeleton of the source image.  Hit or Miss transforms are
so called because the matching process can involve background pixels (Miss) as
well as foreground pixels (Hit).

Exx: CREATE 99 SIZE 2,1 VALUE 0; P 0,0=1; BHMT 1 WITH 99
       detects all pixels that lie on the lefthand edges of foreground
       regions of the binary image in picture 1
     BHMT 1 2 WITH 20 TIMES 0 ADD
       carries out on picture 1 the infinite thickening transformation defined
       in picture 20 and outputs the result to picture 2
     CREATE 99 SIZE 3 VALUE 1; BHMT 10 WITH 99 SUBTRACT
       leaves in picture 10 the four-connected outline of any foreground
       regions
$
The source picture is treated as a binary image: zero values denote background
pixels and non-zero values denote foreground pixels.

Each layer of the picture specified by means of the WITH key defines a
structuring element to be applied to the source picture.  If there is more
than one layer, the structuring elements thus defined are applied in sequence,
starting with layer 1.  A zero pixel value defines a Miss and a pixel value of
1 defines a Hit.  Any other values are ignored.  The origin of the picture
defines the origin of the structuring element.

For example,

      2 2 2 2 2                        2 2 0 2 2         0
      2 1 1 1 2        1 1 1           3 3 1 3 3         1
      2 2[1]2 2   =>    [1]            4 4[1]4 4   =>   [1]
      2 0 0 0 2        0 0 0           5 5 1 5 5         1
      2 2 2 2 2                        6 6 0 6 6         0

where [ ] marks the origin of the picture and the structuring element.

The Hit or Miss transform can be explained in simple terms if you think of the
structuring element as a binary template.  The origin of the structuring
element is positioned over each source pixel in turn and a 1 is output if all
the components of the structuring element match the source image, that is, if
zeros in the structuring element match zeros in the source image and ones in
the structuring element match non-zero pixels in the source image.  Otherwise
a 0 is output.

For example,

      0 0 0 1 1                  0 0 0 1 0
      0 1 1 0 0                  0 1 0 0 0
      0 1[1]1 1  (*)  0[1]   =   0 1[0]0 0
      0 1 1 0 1                  0 1 0 0 1
      0 0 1 1 0                  0 0 1 0 0

where (*) denotes a Hit or Miss transform.

An equivalent definition for Hit or Miss transforms can be obtained by
combining translates of the source image and its complement.  A Hit specifies
a translate of the source image itself.  A Miss specifies a translate of the
complement of the source image.  The result is the intersection (logical AND)
of the translates where the position of the origin with respect to each Hit or
Miss in the structuring element defines an offset to be applied to the source
image or its complement.

For example,

      0 0 0 0 0                  0 0 0 0 0       0 0 0 0 0       1 1 1 1 1
      0 0 1 0 0        0 1       0 0 1 0 0       0 0 0 0 0       1 1 1 1 1
      0 1[1]1 0  (*)  [1]    =   0 1[1]1 0  (&)  0 1[0]0 0  (&)  1 1[0]1 1
      0 0 1 0 0                  0 0 1 0 0       1 1 1 0 0       1 0 0 0 1
      0 0 0 0 0                  0 0 0 0 0       0 1 0 0 0       1 1 0 1 1

                                 0 0 0 0 0
                                 0 0 0 0 0
                             =   0 1[0]0 0
                                 0 0 0 0 0
                                 0 0 0 0 0

where (&) denotes intersection.

Apart from their use as template operators, Hit or Miss transforms are also
used to implement thickening and thinning transformations.  Here the result
obtained from the Hit or Miss transform is added to or subtracted from the
source image.  You specify a thickening or thinning transformation by setting
the option ADD or SUBTRACT.  More precisely, ADD causes the union (logical OR)
of the source and the Hit or Miss transform to be output, and SUBTRACT causes
the difference between the source and the Hit or Miss transform (logical AND
of source and complement of Hit or Miss transform) to be output.

With a multi-layer picture you can specify a series of structuring elements to
be applied in turn.  For example, here is a series of structuring elements
that you might specify for a thinning transfrom to obtain an eight-connected
skeleton

      0 0 0    0 0      0   1      1      1 1 1      1      1   0      0 0
       [1]     0[1]1    0[1]1    0[1]1     [1]     1[1]0    1[1]0    1[1]0
      1 1 1      1      0   1    0 0      0 0 0      0 0    1   0      1

Applying these eight structuring elements in turn represents one complete
iteration of the thinning transform, removing a layer of pixels from
foreground regions and leaving unchanged any boundary pixels which belong to
the skeleton.  To obtain the complete skeleton, several iterations of the
transform are required.

The whole process can be repeated by specifying the number of iterations with
the TIMES key.  The default is to carry out one iteration.  A zero value for
the TIMES key specifies an infinite number of iterations.  Processing is
stopped if no change is detected after applying one complete sequence of
structuring elements.  In the example above, you would specify a zero value
for the TIMES key to obtain the binary skeleton of the source image.  After a
certain number of iterations, the output image would no longer change and
processing would be stopped automatically.

The MASK key can be used to restrict processing to specified regions of the
image, that is, wherever mask pixels are zero, the source pixel value is
output and elsewhere, the result of the Hit or Miss transform is substituted.
Of course, the mask picture must have the same dimensions as the source
picture.  For example, the mask image

      0 0 0 0 0
      0 1 1 1 1
      0 1 1 1 1
      0 1 1 1 1
      0 0 0 0 0

when applied to one of the previous examples

      0 0 0 1 1                  0 0 0 1 0
      0 1 1 0 0                  0 1 0 0 0
      0 1[1]1 1  (*)  0[1]   =   0 1[0]0 0
      0 1 1 0 1                  0 1 0 0 1
      0 0 1 1 0                  0 0 1 0 0

gives the following result

      0 0 0 1 1     . . . . .       0 0 0 1 1
      0 . . . .     . 1 0 0 0       0 1 0 0 0
      0 . . . .  +  . 1 0 0 0   =   0 1 0 0 0
      0 . . . .     . 1 0 0 1       0 1 0 0 1
      0 0 1 1 0     . . . . .       0 0 1 1 0

So far, the result for the Hit or Miss transform has not been defined round
the edges of an image where any part of the structuring element falls outside
the limits of the source picture.  By default, the process of calculating the
intersection of the translates of the source image or its complement simply
omits any undefined source pixels.  If all the source pixels which contribute
to the result for a particular output pixel are undefined, the output pixel
defaults to 1.

For example,

      0 1 0 0 0                 1 0 1 1 1
      0 1 1 0 1        1 0      0 0 0 0 0
      0 1 1 1 0  (*)  [0]   =   0 0 0 0 1
      0 1 1 0 1                 0 0 0 1 0
      0 0 0 1 1                 0 0 1 0 0

Notice how the structuring element in this example matches any zeros in the
top row of the source image because here the top row of the structuring
element falls outside the source image and is ignored.

As an alternative, the SOURCE option allows you to specify a value for any
pixel positions outside the source image which contribute to a translate of
the source image or its complement.  You specify the actual value with the
EDGE key.  All non-zero values for the EDGE key imply an edge value of 1.  An
edge value of zero effectively closes off all foreground regions which touch
the edge of the image.  A non-zero edge value leaves regions "open" - it is as
if regions extend indefinitely at right angles to the edges of the image.

For example,

      0 1 0 0 0                 1 0 1 1 1       E E E E E       C C C C C
      0 1 1 0 1        1 0      1 0 0 1 0       0 1 0 0 0       0 1 1 1 C
      0 1 1 1 0  (*)  [0]   =   1 0 0 0 1  (&)  0 1 1 0 1  (&)  0 0 1 0 C
      0 1 1 0 1                 1 0 0 1 0       0 1 1 1 0       0 0 0 1 C
      0 0 0 1 1                 1 1 1 0 0       0 1 1 0 1       0 0 1 0 C

                                0 0 0 0 0
                                0 0 0 0 0
                            =   0 0 0 0 C
                                0 0 0 1 0
                                0 0 1 0 0

where E represents the source edge value and C its complement.

Instead of using the SOURCE option, you can, with the OUTPUT option and the
EDGE key, specify the value to assign to output pixels wherever the result
depends on undefined source pixels.  A zero output edge value is particularly
useful when using Hit or Miss transforms for templating operations.  It
eliminates possible edge effects because output pixels can only be set if the
structuring element lies fully inside the source image.  A non-zero pixel in
the output image means that the structuring element exactly matched the source
image at that position.

For example,

      0 1 0 0 0                 E E E E E
      0 1 1 0 1        1 0      0 0 0 0 E
      0 1 1 1 0  (*)  [0]   =   0 0 0 0 E
      0 1 1 0 1                 0 0 0 1 E
      0 0 0 1 1                 0 0 1 0 E

where E represents the output edge value.

See also: bhmt.syntax
$add bhmt.syntax
Keys:
  [FROM]        source picure [SELECT]
  [TO]          destination picture [FROM]
  WITH          picture specifying structuring element data
  MASK          mask picture to restrict processing to specified region [none]
  TIMES         number of times to apply structuring element data
                (0 => infinite) [1]
  EDGE          edge value [0]

Options:
  ADD | SUBTRACT   add or subtract result of Hit or Miss transform to source
                   image to produce output result
  SOURCE | OUTPUT  fix value of source/output edge pixels according to the
                   value of the EDGE key [SOURCE]

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add bmlut.command bmlut binary morphology neighbourhood transformation lut
You use BMLUT to generate mapping tables that can define any kind of 3 by 3
binary neighbourhood transformation.  A mapping table is applied with the
separate command BMMAP.  Once a mapping table has been created it can be used
any number of times.  With the option ERODE, DILATE or MEDIAN, you can
generate mapping tables that correspond exactly to any of the morphological
transformations supported by the commands ERODE, DILATE and MEDIAN.  More
general transformations can be defined by specifying logical expressions with
the keys IF and UNLESS to define the outcome for the 512 possible 3 by 3
neighbourhood configurations.  These logical expressions should include at
least one of the variables P0 to P8, N4, N8, C, C4 and C8 to characterise
the neighbourhood configurations as required for a particular morphological
transformation.

Exx: BMLUT 99 ERODE OUTLINE; BMMAP 1 2 WITH 99
       outputs outlines of foreground regions in picture 1 to picture 2
       (same result as ERODE 1 2 OUTLINE)
     BMLUT 99 IF (P4+N8) > 4
       outputs mapping table for binary median filter
       (same result as BMLUT 99 MEDIAN)
     BMLUT 99 IF (P4 & N8~=0) | (~P4 & N8=8); BMMAP 1 WITH 99
       remove salt-and-pepper noise from picture 1
     BMLUT 99 IF P4 & N8=1
       outputs mapping table to detect line ends
$
BMLUT lets you to set up any kind of transformation of a 3 by 3 binary
neighbourhood.  What you have to do is specify the outcome (a 0 or a 1) for
each of the 512 possible neighbourhood configurations.  BMLUT stores this
neighbourhood mapping table in a Semper picture for later use with the BMMAP
command.  Each configuration is represented by a 9-bit index value in the
range 0 to 511.  Each bit in the index value is associated with one of the
pixel locations in the 3 by 3 neighbourhood as follows

      0 3 6
      1 4 7
      2 5 8

where bit 0 is the least significant bit.  The index value points to the entry
in the mapping table where the result for that neighbourhood configuration is
stored.

You may decide to create mapping tables directly by creating a new picture of
the appropriate size and setting each mapping table entry with the PIXEL
command.  However, if the outcome for each neighbourhood configuration can be
specified in the form of a common logical expression, BMLUT can be directed to
generate the mapping table for you.

You specify the necessary logical conditions with the keys IF and UNLESS.
Either key accepts a general Semper logical expression which BMLUT evaluates
for each of the 512 neighbourhood configurations.  Each logical expression
must refer to at least one of the variables P0 to P8, N4, N8, C, C4 and C8
which BMLUT sets itself before it evaluates the expresssion.  The result
obtained determines the value stored in the mapping table.  If the IF
expression is true and the UNLESS expression is false, a 1 is output,
otherwise, a zero is output.

Two keys are provided for convenience in specifying some logical conditions
but exactly the same result could be achieved with just one key, that is

    BMLUT IF <if-expression> UNLESS <unless-expression>
    BMLUT IF <if-expression> & ~<unless-expression>
    BMLUT UNLESS ~<if-expression> | <unless-expression>

are all equivalent.  You may also omit either one of the two expressions

    BMLUT IF <if-expression>
    BMLUT UNLESS <unless-expression>

BMLUT sets the variables P0 to P8 according to the value of the pixels in a
particular neighbourhood configuration.  For example a neighbourhood index
value of 463

                         1 1 1
    463 = 111001111  =>  1 0 1
                         1 0 1

causes variables P4 and P5 to be set to zero (false) and the variables P0, P1,
P2, P3, P6, P7 and P8 to be set to 1 (true).

To create a mapping table which detects just this neighbourhood configuration
(a Hit or Miss tranform) you could specify the following logical expression
with the IF key

    P0 & P1 & P2 & P3 & P4 & ~P4 & ~P5 & P6 & P7 & P8

This would cause a mapping table to be output with all entries set to zero
except entry 463.

Of course, there are more useful neighbourhood transformations that can be
defined besides these simple Hit or Miss transforms (which, anyway, are more
efficiently carried out with the command BHMT).  In particular, you should
note that you are not restricted to pure logical expressions when using BMLUT.
For example, to create the mapping table to detect all neighbourhood
configurations where the central pixel is surrounded by exactly 4 non-zero
neighbours, you could specify the following logical expression

    ( P0 + P1 + P2 + P3 + P5 + P6 + P7 + P8 ) = 4

Logical expressions which count pixels in a 3 by 3 neighbourhood are very
common in defining the necessary conditions for many morphological transforms.
Consequently, BMLUT provides further variables N4, N8, C, C4 and C8 for added
convenience.  They are defined in the following way

    N4 = P1 + P3 + P5 + P7

    N8 = P0 + P1 + P2 + P3 + P5 + P6 + P7 + P8

    C  = (~P0 & P1) + (~P1 & P2) + (~P2 & P5) + (~P5 & P8) + (~P8 & P7)
                                 + (~P7 & P6) + (~P6 & P3) + (~P3 & P0)

    C4 = P1 + P3 + P5 + P7 - (P0 & P1 & P3) - (P2 & P1 & P5)
                           - (P6 & P3 & P7) - (P8 & P5 & P7)

    C8 = ~P1 + ~P3 + ~P5 + ~P7 - (~P0 & ~P1 & ~P3) - (~P2 & ~P1 & ~P5)
                               - (~P6 & ~P3 & ~P7) - (~P8 & ~P5 & ~P7)

N4 and N8 represent the number of 4-connected and 8-connected neighbours
around the central pixel.

C represents the neighbourhood "crossing number" which is the number of 0-1
transitions in the central pixel's surround.  This takes no account of
connectivity between neighbouring pixels in the central pixel's surround, so
the variables C4 and C8 are provided for this.  They represent the number of
separate 4-connected and 8-connected foreground regions which surround the
central pixel.  These two parameters are sometimes referred to as
"connectivity numbers" in the morphological literature.

Further parameters mentioned in the literature include the bond number and the
coefficients of curvature for 4-connected and 8-connected surrounds.  These
are not provided in variable form because they are less commonly used and are
easily derived from the variables described above

    bond number = N4 + N8

    4-connected coefficient of curvature = ( 4 - N4 ) - C4

    8-connected coefficient of curvature = ( 8 - N8 ) - ( C8 + C + C8 )

The 14 variables supported by BMLUT in logical expressions specified with the
keys IF and UNLESS provide a simple and elegant way to generate the mapping
tables for many useful morphological transformations, as the following
examples illustrate

    4-neighbour erode               BMLUT IF P4 & N4=4
    8-neighbour erode               BMLUT IF P4 & N8=8
    4-neighbour dilate              BMLUT IF P4 | N4~=0
    8-neighbour dilate              BMLUT IF P4 | N8~=0
    Hole detect                     BMLUT IF ~P4 & N4=4
    Interior pixel fill             BMLUT IF P4 | N4=4
    End detect                      BMLUT IF P4 & N8=1
    End remove                      BMLUT IF P4 UNLESS N8=1
    Isolated pixel detect           BMLUT IF P4 & N8=0
    Isolated pixel remove           BMLUT IF P4 UNLESS N8=0
    Salt-and-pepper noise remove    BMLUT IF (P4 & N8~=0) | (~P4 & N8=8)
    Spur detect                     BMLUT IF P4 & (N4 + N8) = 1
    Spur remove                     BMLUT IF P4 UNLESS (N4 + N8) = 1
    4-connected outline             BMLUT IF P4 UNLESS N8=8
    8-connected outline             BMLUT IF P4 UNLESS N4=4
    H detect                        BMLUT IF P4 & N8=6 & C4=2 & C8=2
    H break                         BMLUT IF P4 UNLESS N8=6 & C4=2 & C8=2
    Median filter                   BMLUT IF (P4 + N8) > 4

All of these examples have quite simple logical conditions.  BMLUT supports
general and quite lengthy logical expressions as in the following example
which generates the mapping table for obtaining the octagonal convex hull

    BMLUT IF P4 | (P1 & P3 & P5)                          +
                | (P3 & P5 & P7)                          +
                | (P5 & P7 & P1)                          +
                | (P7 & P1 & P3)                          +
                | (P1 & P3 & (P2 | P6) & ~P5 & ~P7 & ~P8) +
                | (P5 & P7 & (P2 | P6) & ~P1 & ~P3 & ~P0) +
                | (P1 & P5 & (P0 | P8) & ~P3 & ~P7 & ~P6) +
                | (P3 & P7 & (P0 | P8) & ~P1 & ~P5 & ~P2)

The first four lines of the logical expression can in fact be replaced with
just "P4 | N4 >= 3".

Some morphological operations require a series of morphological
transformations to be applied in turn (opening, for example, consists of
erosion followed by dilation).  BMLUT allows you to specify more than one
logical expression with the IF or UNLESS keys.  Each expression is used to
generate a separate mapping table which is stored as a separate row in the
output picture.  You use commas "," to separate the expressions.  For example,
a more rounded result for dilation can be achieved by making alternate use of
4-connected and 8-connected dilation.  The mapping table for this can be
generated in the following way

    BMLUT IF P4 | N4~=0, P4 | N8~=0

If the IF and UNLESS keys are used together and they specify a different
number of expressions, BMLUT will repeat the shorter set of expressions to
make up the same number as the longer set.  For example, quite a good thinning
transformation can be obtained with four mapping tables as follows

    BMLUT IF P4,P4,P4,P4 UNLESS C8=1 & N8~=1 & (~P1 & P7), +
                                C8=1 & N8~=1 & (~P7 & P1), +
                                C8=1 & N8~=1 & (~P3 & P5), +
                                C8=1 & N8~=1 & (~P5 & P3)

The string of expressions given by the IF key can be replaced with just P4 to
give the same result.

    BMLUT IF P4 UNLESS C8=1 & N8~=1 & (~P1 & P7), C8=1 & N8~=1 & (~P7 & P1), +
                       C8=1 & N8~=1 & (~P3 & P5), C8=1 & N8~=1 & (~P5 & P3)

The logical condition "UNLESS C8=1 & N8~=1" is the basic condition for eroding
pixels in order to thin objects down to an 8-connected skeleton (C8=1 selects
edge pixels that can be eroded without causing a break in the central pixel's
surround and N8~=1 protects line ends).  Because neighbourhood transformations
are applied in parallel to all the neighbourhoods in the source image, without
reference to the any changes that might occur in neighbouring pixel locations,
this is not enough to maintain the connectivity of the result.  This accounts
for the extra condition on the end of each expression which restricts the
erosion during each pass to one of the four cardinal directions and ensures
that two-pixel-wide features are not completely eroded.

Substituting C4 and N4 for C8 and N8 will give a similar, but 4-connected
result.

    BMLUT IF P4 UNLESS C4=1 & N4~=1 & (~P1 & P7), C4=1 & N4~=1 & (~P7 & P1), +
                       C4=1 & N4~=1 & (~P3 & P5), C4=1 & N4~=1 & (~P5 & P3)

These thinning transformations can be thought of as erosions which preserve
the connectivity of foreground regions and which do not erode line ends.  One
can easily modify these examples to model thickening transformations that
produce background skeletons.  Inverting the basic conditions for the
8-connected skeleton, you obtain the following command

    BMLUT IF P4 | (C8=1 & N8~=7 & (~P1 & P7)), +
             P4 | (C8=1 & N8~=7 & (~P7 & P1)), +
             P4 | (C8=1 & N8~=7 & (~P3 & P5)), +
             P4 | (C8=1 & N8~=7 & (~P5 & P3))

This preserves 8-connectivity of foreground regions - so the background
skeleton will be 4-connected.  For an 8-connected result, substitute C4 and N4
for C8 and N8, as before, but notice that the inequality involving N4 must
also be modified, that is

    BMLUT IF P4 | (C4=1 & N4~=3 & (~P1 & P7)), +
             P4 | (C4=1 & N4~=3 & (~P7 & P1)), +
             P4 | (C4=1 & N4~=3 & (~P3 & P5)), +
             P4 | (C4=1 & N4~=3 & (~P5 & P3))

If you invert the result obtained by applying the mapping tables generated by
this last example, you will end up with the 8-connected background skeleton,
or exo-skeleton.

If you omit the logical condition N4~=3, for protecting line ends, from the
last example, you will obtain, after inverting the processed result, the
8-connected skiz (skeleton by zones of influence) of the source image.

    BMLUT IF P4 | (C4=1 & (~P1 & P7)), P4 | (C4=1 & (~P7 & P1)), +
             P4 | (C4=1 & (~P3 & P5)), P4 | (C4=1 & (~P5 & P3))

BMLUT also has keys and options which allow you to generate mapping tables for
any of the neighbourhood transformations supported by the commands ERODE,
DILATE and MEDIAN (BMMAP is much faster to use than ERODE, DILATE or MEDIAN).
You select which command by setting the corresponding option and you append
exactly the same string of keys or options as you would use with the command
itself.  For example,

    BMLUT DILATE SEPARATELY

would generate the mapping tables that BMMAP would require to carry out
exactly the same morphological transformation as the command

    DILATE SEPARATELY

Note that user-defined mapping tables supplied to ERODE and DILATE,
by specifying the key WITH, are 8-bit mapping tables which refer only to the
central pixel's surround and have a different pattern of bits from that used
by BMLUT

      7 6 5
      0 * 4
      1 2 3

Note also that when using the commands ERODE SKELETONISE, ERODE ENDS and
DILATE SEPARATELY, the TIMES key automatically defaults to 0 (infinite number
of iterations).  With BMMAP, the default for the TIMES key is always 1, so you
must explicitly set it to zero in order to get the same result.

For more detailed information about these morphological transformations,
consult the documentation for the commands ERODE, DILATE and MEDIAN.

See also: bmlut.syntax, bmmap, bhmt, erode, dilate, median, expressions
$add bmlut.syntax
Keys:
  [TO]          destination picture to contain mapping table [SELECT]
  IF text       logical expression defining which neighbourhood configurations
                give a positive (non-zero) result
  UNLESS text   logical expression defining which neighbourhood configurations
                give a negative (zero) result
  NEIGHBOURS | WITH
                key that may accompany ERODE or DILATE option:
                  NEIGHBOURS  minimum no. clear/set neighbours to erode/dilate
                              centre pixel
                  WITH        picture containing user supplied mapping table

Options:
  ERODE | DILATE | MEDIAN
                generate mapping table for 3 x 3 neighbourhood transformation
                supported by command ERODE, DILATE or MEDIAN
  SKELETONISE | ENDS | NODES | OUTLINE | OL4
                option that may accompany ERODE option:
                  SKELETONISE  erode to 8-connected skeleton
                  ENDS         erode ends of protruding branches/hairs
                  NODES        erode skeleton node points, separating branches
                  OUTLINE      generate 8-connected outline
                  OL4          generate 4-connected outline
  SEPARATELY    option that may accompany DILATE option to dilate, preserving
                separation between foreground regions (reduces background to
                4-connected skeleton)

Keys IF/UNLESS and options ERODE/DILATE/MEDIAN are mutually exclusive.

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add bmmap.command bmmap binary morphology neighbourhood transformation
You use BMMAP to carry out generalised binary 3 by 3 neighbourhood
transformations.  The way in which the transfromation is carried out is
determined by one or more neighbourhood mapping tables contained in the
picture specified by means of the WITH key.  The result of applying each
mapping table is obtained by calculating the neighbourhood index for each
source pixel and using this index to look up the result in the mapping table.
The mapping table defines the result for all the 512 possible configurations
in a binary 3 by 3 neighbourhood.  The command BMLUT provides a convenient way
to generate mapping tables for use with BMMAP.

Exx: CREATE 99 SIZE 512,1 VALUE 0; ORIGIN LEFT; PIXEL 511 = 1;
     BMMAP 1 WITH 99 TIMES 1
       removes one layer of pixels from all foreground objects in picture 1
       (same result as ERODE 1 TIMES 1)
     BMLUT 99 ERODE OUTLINE; BMMAP 1 2 WITH 99
       outputs outlines of foreground regions in picture 1 to picture 2
       (same result as ERODE 1 2 OUTLINE)
     BMLUT 99 IF (P4 & N8~=0) | (~P4 & N8=8); BMMAP 1 WITH 99
       remove salt-and-pepper noise from picture 1
     BMLUT 99 DILATE SEPARATELY; BMMAP 1 WITH 99 TIMES 0 MASK 3
       dilate foreground regions in picture 1, keeping unconnected regions
       separate, until they fill the foreground regions in picture 3
     BMLUT 99 MEDIAN; BMMAP 1 WITH 99 TIMES 5
       apply binary median filter to picture 1
       (same result as FOR I=1,5; MEDIAN 1; LOOP)
$
The source picture is treated as a binary image: zero values denote background
pixels and non-zero values denote foreground pixels.

Each row of the picture specified by means of the WITH key contains a mapping
table which defines the result for each of the 512 possible binary 3 by 3
neighbourhood configurations.  A 9-bit neighbourhood index value is
constructed for each source pixel, where each bit in the index value is set
according to the state of the corresponding pixel in the neighbourhood.  The
neighbourhood bits are arranged in the following way

      0 3 6
      1 4 7
      2 5 8

Calculating the index value for a neighbourhood is equivalent to applying the
following linear convolution kernel

      2^0 2^3 2^6       1   8  64
      2^1 2^4 2^7   =   2  16 128
      2^2 2^5 2^8       4  32 256

provided that a pixel value in the neighbourhood is either 0 or 1 according to
whether the corresponding source pixel is zero or non-zero.

The index value is used to select the mapping table entry which defines the
result for the central pixel.  If the mapping table entry is set to zero, a
zero is output.  Otherwise, a 1 is output.  In this way, quite arbitrary 3 by
3 neighbourhood transformations can be carried out. It is important to note
that the output values do not affect the result for neighbouring pixels.  In
effect, the transformation is simultaneously applied to all the source pixels.

If the mapping table picture contains more than one row, a series of
neighbourhood transformations will be applied in turn.  For example, the
morphological opening with a 3 by 3 structuring element can be specified if
the first row of the picture contains the mapping table for erosion and the
second row contains the mapping table for dilation

    CREATE 1 SIZE 512,1 VALUE 0; ORIGIN LEFT; PIXEL 511 = 1
    CREATE 2 SIZE 512,1 VALUE 1; ORIGIN LEFT; PIXEL   0 = 0
    CREATE 3 SIZE 512,2
    PASTE 1 3 TOP
    PASTE 2 3 BOTTOM
    BMMAP ... WITH 3

The whole process can be repeated by specifying the number of iterations with
the TIMES key.  The default is to carry out one iteration.  Processing is
stopped if no change is detected after applying one complete sequence of
mapping tables.

The command BMLUT provides a convenient way to generate mapping tables.  For
example the mapping tables for morphological opening, as given in the previous
example, could be generated with the following command

      BMLUT 3 IF (P4 & N8 = 8),(P4 | N8 ~= 0)

The result for each neighbourhood configuration is defined as a logical
expression which is evaluated for each of the 512 possible configurations.
BMLUT also has keys and options which allow you to generate mapping tables for
any of the neighbourhood transformations supported by the commands ERODE,
DILATE and MEDIAN (BMMAP is much faster to use than either ERODE, DILATE or
MEDIAN).

The MASK key can be used to restrict processing to specified regions of the
image, that is, wherever mask pixels are zero, the source pixel value is
output and elsewhere, the result of the 3 by 3 neighbourhood transformation is
substituted.  Of course, the mask picture must have the same dimensions as the
source picture.  For example, the mask image

      0 0 0 0 0 0 0
      0 0 0 0 0 0 0
      0 0 0 0 0 0 0
      0 1 1 1 1 1 1
      0 1 1 1 1 1 1
      0 1 1 1 1 1 1
      0 0 0 0 0 0 0

when applied to the following example, where the neighbourhood transformation
produces the eight-connected outline of the source image

         source            result

      0 0 0 0 0 0 0     0 0 0 0 0 0 0
      0 0 0 1 1 0 0     0 0 0 1 1 0 0
      0 0 1 1 1 1 0     0 0 1 0 0 1 0
      0 1 1 1 1 1 0     0 1 0 0 0 1 0
      0 1 1 1 1 0 0     0 1 0 0 1 0 0
      0 1 1 1 1 0 0     0 1 1 1 1 0 0
      0 0 0 0 0 0 0     0 0 0 0 0 0 0

gives the following result

      0 0 0 0 0 0 0     . . . . . . .       0 0 0 0 0 0 0
      0 0 0 1 1 0 0     . . . . . . .       0 0 0 1 1 0 0
      0 0 1 1 1 1 0     . . . . . . .       0 0 1 1 1 1 0
      0 . . . . . .  +  . 1 0 0 0 1 0   =   0 1 0 0 0 1 0
      0 . . . . . .     . 1 0 0 1 0 0       0 1 0 0 1 0 0
      0 . . . . . .     . 1 1 1 1 0 0       0 1 1 1 1 0 0
      0 0 0 0 0 0 0     . . . . . . .       0 0 0 0 0 0 0

So far, the result for a 3 by 3 neighbourhood transformation has not been
defined round the edges of an image where any part of the neighbourhood falls
outside the limits of the source picture.  By default, source pixels round the
edges of the image are replicated outwards.

As an alternative, the SOURCE option allows you to specify a value for any
pixel positions outside the source image which contribute to the neighbourhood
of a pixel.  You specify the actual value with the EDGE key.  All non-zero
values for the EDGE key imply an edge value of 1.  For example, if a zero edge
value is specified, the neighbourhood transformation to produce the eight-
connected outline of the source image would result in closed outlines for all
regions.  If a non-zero edge value is specified, outlines of regions which
touch the edges of the picture are left open.

         source            result

      0 1 1 1 0 0 0     0 1 1 1 0 0 0
      1 1 1 1 0 0 0     1 0 0 1 0 0 0
      1 1 1 1 1 1 0     1 0 0 0 1 1 0
      0 1 1 1 1 1 1     0 1 1 0 0 0 1        SOURCE EDGE 0
      0 0 0 1 1 1 1     0 0 0 1 0 0 1
      0 0 0 0 1 1 1     0 0 0 0 1 0 1
      0 0 0 0 1 1 1     0 0 0 0 1 1 1

                        0 1 0 1 0 0 0
                        1 0 0 1 0 0 0
                        1 0 0 0 1 1 0
                        0 1 1 0 0 0 1        SOURCE EDGE 1
                        0 0 0 1 0 0 0
                        0 0 0 0 1 0 0
                        0 0 0 0 1 0 0

Instead of using the SOURCE option, you can, with the OUTPUT option and the
EDGE key, specify the value to assign to output pixels wherever the result
depends on undefined source pixels.  A zero output edge value is particularly
useful when using 3 by 3 neighbourhood transformations to detect particular
neighbourhood configurations.  It eliminates possible edge effects because
output pixels can only be set if the entire neighbourhood region lies inside
the source image.

See also: bmmap.syntax, bmlut, erode, dilate, median
$add bmmap.syntax
Keys:
  [FROM]        source picure [SELECT]
  [TO]          destination picture [FROM]
  WITH          picture containing one or more neighbourhood mapping tables
  MASK          mask picture to restrict processing to specified region [none]
  TIMES         number of times to apply neighbourhood mapping tables
                (0 => inifinite) [1]
  EDGE          edge value [0]

Options:
  SOURCE | OUTPUT  fix value of source/output edge pixels according to the
                   value of the EDGE key

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add bopen.command bopen open close binary morphology structuring element
You use BOPEN to carry out generalised binary opening of foreground regions.
The way in which the opening is carried out is determined by the structuring
element specified by means of the WITH key.  The output picture will contain
the binary, opened result, which represents the area swept out by the
structuring element whilst it is contained entirely within the foreground
regions of the source image.  Opening smoothes the boundary of foreground
regions by removing small protrusions, it breaks narrow isthmuses between
regions and it removes regions smaller than the structuring element.  Opening
is idempotent - opening an already opened image does not change the image.

BOPEN has exactly the same keys and options as the commands BERODE and BDILATE
and it produces exactly the same result as using the command BERODE followed
by BDILATE with the same settings for the controlling keys and options, but in
less time.

Exx: CREATE 99 SIZE 3 VALUE 1; BOPEN 1 WITH 99
       opens picture 1 with square, 3 by 3 structuring element.
     BOPEN 1 2 WITH 99 TIMES 3
       equivalent to the following
     BERODE 1 2 WITH 99 TIMES 3; BDILATE 2 WITH 99 TIMES 3
$
Opening a binary image with a structuring element is equivalent to eroding and
then dilating the image with the same structuring element.  For example,

      0 0 0 0 1 0 1                   0 0 0 0 1 0 0
      0 0 1 1 1 1 0                   0 0 1 1 1 1 0
      0 1 1 1 1 1 0         1         0 1 1 1 1 1 0
      0 1 1[1]1 1 0  (o)  1[1]1   =   0 0 1[1]1 1 0
      0 1 0 0 1 1 0         1         0 0 0 0 1 0 0
      0 0 0 1 1 1 0                   0 0 0 1 1 1 0
      0 0 0 0 1 0 0                   0 0 0 0 1 0 0

where (o) denotes opening and [ ] marks the origin of the picture and the
structuring element.  Compare this with the result obtained by erosion
followed by dilation,

      0 0 0 0 1 0 1                   0 0 0 0 0 0 0
      0 0 1 1 1 1 0                   0 0 0 0 1 0 0
      0 1 1 1 1 1 0         1         0 0 1 1 1 0 0
      0 1 1[1]1 1 0  (-)  1[1]1   =   0 0 0[0]1 0 0
      0 1 0 0 1 1 0         1         0 0 0 0 0 0 0
      0 0 0 1 1 1 0                   0 0 0 0 1 0 0
      0 0 0 0 1 0 0                   0 0 0 0 0 0 0

      0 0 0 0 0 0 0                   0 0 0 0 1 0 0
      0 0 0 0 1 0 0                   0 0 1 1 1 1 0
      0 0 1 1 1 0 0         1         0 1 1 1 1 1 0
      0 0 0[0]1 0 0  (+)  1[1]1   =   0 0 1[1]1 0 0
      0 0 0 0 0 0 0         1         0 0 0 0 1 0 0
      0 0 0 0 1 0 0                   0 0 0 1 1 1 0
      0 0 0 0 0 0 0                   0 0 0 0 1 0 0

where (-) denotes erosion, (+) denotes dilation.

The source picture is treated as a binary image: zero values denote background
pixels and non-zero values denote foreground pixels.

Each layer of the picture specified by means of the WITH key defines a
structuring element to be applied to the source picture.  Non-zero pixels
define the components of the structuring element.  Any zero pixels are
ignored.  The origin of the picture defines the origin of the structuring
element.

For example,

      0 0 0 0 0                        0 0 1 0 0         1
      0 0 1 0 0          1             0 0 1 0 0         1
      0 1[2]1 0   =>   1[1]1           0 0 1 0 0   =>   [1]
      0 0 1 0 0          1             0 0 1 0 0         1
      0 0 0 0 0                        0 0 1 0 0         1

If there is more than one layer, the structuring elements thus defined are
applied in sequence, starting with layer 1.  This allows you to specify large
structuring elements in decomposed form.  You can also use the TIMES key to
apply the sequence of structuring elements more than once.  The structuring
element that a decomposed set represents is obtained by combining the
decomposed set using dilation.

For example,

      1 1 1 1 1 1 1 1 1
      1 1 1 1 1 1 1 1 1
      1 1 1 1 1 1 1 1 1
      1 1 1 1 1 1 1 1 1       1 1 1       1 1 1       1 1 1       1 1 1
      1 1 1 1 1[1]1 1 1   =   1[1]1  (+)  1[1]1  (+)  1[1]1  (+)  1[1]1
      1 1 1 1 1 1 1 1 1       1 1 1       1 1 1       1 1 1       1 1 1
      1 1 1 1 1 1 1 1 1
      1 1 1 1 1 1 1 1 1
      1 1 1 1 1 1 1 1 1

      1 1 1                    1
      1[1]1   =   1[1]1  (+)  [1]
      1 1 1                    1

As you can see, the 9 by 9 structuring element can be decomposed into four 3
by 1 structuring elements and four 1 by 3 structuring elements.  As dilation
is a commutative operation, the structuring elements can be applied in any
order.  The simplest way to apply this example is to create a two-layer
picture with the 3 by 1 structuring element in one layer and the 1 by 3
structuring element in the other layer, specify this picture by means of the
WITH key and set the TIMES key to 4.

The MASK key can be used to restrict processing to specified regions of the
image.  The options SOURCE and OUTPUT and the EDGE key allow you to control
edge effects.  For more detailed information about these and related topics,
consult the documentation for the commands BERODE and BDILATE.

See also: bopen.syntax, berode, bdilate
$add bopen.syntax
Keys:
  [FROM]        source picture [SELECT]
  [TO]          destination picture [FROM]
  WITH          picture specifying structuring element data
  MASK          mask picture to restrict processing to specified region [none]
  TIMES         number of times to apply structuring element data [1]
  EDGE          edge value [0]

Options:
  SOURCE | OUTPUT  fix value of source/output edge pixels according to the
                   value of the EDGE key

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add box.command box parallelepiped classification
The BOX command classifies a picture using a box classifier (parallelepiped).

Exx: BOX 1 2 WITH 3
       perform a box classification of picture 1 into picture 2 using the
       training data from picture 3
$
A box classification of the source picture is carried out based on the ranges
of data described in the WITH picture.  You can generate this data by means of
the LEARN or COVARIANCE command.  The command will warn if it is possible for
multiple classifications to arise (because the boxes overlap), though this
does not mean that such classifications will occur.  The number of columns of
the with picture must be equal to the number of layers in the source picture.

The classification process will always take the first class that matches a
given pixel.  As with the LIKELIHOOD and MINDISTANCE commands unclassified
pixels will be given a value of zero in the output picture.  The same
limitations with respect to the number of classes applies.

The STRIDE key gives the stride across and down the picture allowing a fast
classification of the entire picture.  By default STRIDE has a value of 1 and
the whole picture will be classified.

See also: box.syntax, learn, covariance, likelihood, mindistance
$add box.syntax
Keys:
  [FROM]         source picture [SELECT]
  [TO]           output picture [FROM]
  WITH           training statistics [none]
  STRIDE         sampling interval across and down the picture [1]
  SIZE(2)        dimensions of subregion to be classified [whole picture]
  POSITION(2)    position/offset of subregion [0,0]

Options:
  LEFT | RIGHT   classify subregion abutting indicated picture border
  TOP | BOTTOM
$add break.command break
The command BREAK NAME causes Semper to resume execution just beyond the last
cycle of the named FOR loop.

Exx: FOR N=1,5; SELECT N; FOR Y 5,-5; FOR X -5,5; IF P(X,Y)=0 BREAK N
     LOOP X; LOOP Y; DISPLAY; LOOP
       display pictures with no zero pixels near the origin

If you omit the loop variable name, the innermost loop active is assumed; thus
in the example

   FOR N=1,10; FOR M=N,10; FOR X =-5,5; .. ; LOOP; BREAK; LOOP; LOOP

the BREAK command jumps beyond the M loop, and so to the next cycle of the N
loop.
$add cache.command cache disc access buffer virtual memory
You use the CACHE command to manage the way in which disc I/O is buffered in
memory.  This can lead to significant reductions in the amount of data traffic
to and from the hard disc and it can reduce the total number of I/O requests.
Data from a disc device can be buffered in a separate memory buffer allocated
to that device or it can be buffered in Semper's disc cache.  The disc cache
is a collection of memory buffers which are shared between all the disc
devices which are not separately buffered.  With the CACHE command you can
allocate and free separate memory buffers, display/change the number and size
of cache buffers and you can force buffered data to be flushed out to disc.

Exx: CACHE SHOW
       lists the current disc cache settings - number of cache buffers,
       buffer size and total cache size
     CACHE NUMBER 200
       changes the number of cache buffers to 200, keeping the buffer size the
       same
     CACHE NUMBER 20 SIZE 65536
       reconfigures the cache to consist of 20 buffers of 65536 bytes each
       giving a total cache size of 1310720 bytes
     CACHE NUMBER 0
       frees all cache buffers, effectively turning off disc caching
     CACHE FLUSH
       causes all data modified in the cache to be written to disc
     CACHE DEVICE 2 FLUSH
       causes all modified data associated with device 2 to be written to disc
     CACHE DEVICE 3 MEMORY
       causes all data in device 3 to be buffered in a separate dynamically
       allocated memory buffer
     CACHE DEVICE 3 FREE
       flushes and frees separate buffer associated with device 3
$
Data can be buffered, either in one or more cache buffers which are drawn from
a pool of cache buffers (the disc cache), or else in a buffer which is
permanently allocated to the file with which the data is associated.  The
first approach allows you to make optimum use of limited memory resources by
only caching data which needs to be accessed amongst all the disc files that
are currently open.  The second approach reduces actual disc i/o to an
absolute minimum - data is read in once only, and written out when the buffer
is flushed or freed.  On systems which support virtual memory, you must always
keep in mind the possibility that buffered data will be paged onto disc when
the amount of allocated virtual memory exceeds the amount of real physical
memory.

With the CACHE command you can, at any time, allocate and then free a separate
memory buffer for any disc device which is currently assigned.  You specify
the device number with the DEVICE key and you allocate or free the memory
buffer by specifying the MEMORY or FREE options respectively.  The device
number is determined by the ASSIGN command when you open the disc file.  When
such a buffer is allocated, all the data on disc is read just once into
memory.  All subsequent access to the data is made via the memory buffer,
thereby avoiding all disc I/O, until the buffer is freed or flushed.

There is no point in using the MEMORY option with a temporary or scratch disc
file unless you specifically intend to use the FREE option later during the
same Semper session.  If you do not intend to free the memory buffer before
closing and deleting the file, you may as well use the ASSIGN MEMORY command
to open a memory-based device which will not tie up space on the hard disc.

The CACHE command allows you to control the number and size of cache buffers
which make up the disc cache.  The buffer size must be at least a multiple of
8 bytes and, on some systems, it may also have to be a multiple of the
operating system's page size or some other unit of size.  The CACHE SHOW
command will list any constraints on the buffer size.

Semper will automatically create a certain size of disc cache at the start of
a session.  The default size of the cache will vary according to the host
system, but it should at least give reasonably good performance when
processing medium sized images.  Even when the cache is not large enough to
hold all the data being processed by a particular Semper command, the disc
cache can still provide some performance benefits because it reduces the
number of I/O requests.  On some systems, each I/O request can incur large
operating system overheads.

If the number of buffers or the buffer size is set to zero, disc caching is
disabled and disc data will be accessed directly from the hard disc.

On systems which support virtual memory, the size of the disc cache needs to
be managed so that it is not so large that it puts too heavy a burden on the
operating system.  If the size of the cache exceeds the amount of free
physical memory, data will be swapped out of memory to make room.  If this
leads to the point where the code for active processes has to be swapped out,
the performance of the whole system will suffer.


Some indication of the demands being made for memory can be got by invoking
the Unix command "gr_osview -a".  This continuously displays CPU activity and
memory usage in graphical form.

On systems which do not support virtual memory, the size of the disc cache
will be limited by the amount of available memory.  Also, allocating all of
the available memory to the disc cache may cause problems elsewhere when
further requests to allocate memory are refused.

With the FLUSH option you can cause all modified data in the cache to be
written to disc.  With the DEVICE key, you can restrict the operation of the
FLUSH option to a specified disc device.  Reconfiguring the disc cache causes
its contents to be written to disc, as if the FLUSH option had been specified.
If the disc cache is large, this could take a noticeable length of time.
Likewise, when a disc device is deassigned, its contents are flushed out to
disc, except when the file is to be deleted (either because the DELETE option
was specified in the DEASSIGN command or because the device is a temporary or
scratch disc).

The FLUSH command has the same effect as using the CACHE FLUSH command.

The SHOW option causes the current disc cache parameters to be listed on the
console output stream.

See also: cache.syntax, assign, deassign, flush
$add cache.syntax
Keys:
  NUMBER         number of cache buffers [current value]
  SIZE           cache buffer size (bytes) [current value]
  DEVICE         disc device number for use with FLUSH, MEMORY or FREE options

Options:
  FLUSH          flush contents of cache buffer or specified device to disc
  MEMORY         allocate permanent memory buffer for specified device
  FREE           free memory buffer associated with specified device
  SHOW           list current settings for disc cache parameters

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add calculate.command calculate arithmetic+
 compare add subtract multiply divide power+
 min max complex real imaginary conjugate cc phase modulus msq+
 cos acos sin asin tan atan root exp ln logarithm integer round nearest+
 gt lt eq and or not
CALCULATE allows you to calculate more or less arbitrary mathematical
combinations/functions of pictures reasonably efficiently - from simple
addition/subtraction upwards, using a syntax much the same as that used
by all numerical expressions (see EXPRESSIONS).

Exx: CALCULATE (:10+:11)/2 TO DISPLAY
       displays the average of pictures 10 and 11
     CALCULATE EXP(-RR/2/25^2)
       fills current pic with gaussian having sectional rms 25 pixels
     FOURIER; CALC :SEL*CC(:T)/(MSQ(:T)+.2); IMAGE
       applies a Wiener inverse filter to compensate the current picture
       for degradation with a spatial frequency response in picture T
$
You define the expression to be calculated with a first assumed key; if you
omit TO, output goes to the first picture mentioned in the expression, or to
SELECT if the expressions contains none.

The expression itself is interpreted once per row, not once per pixel, giving
reasonable efficiency; it has the same syntax as all Semper expressions,
except in the following respects:
   (i) items of the form :n or d:n are taken to denote pixels from the
       indicated picture, rather than constants (i.e. :5/2 means picture 5
       halved, while T/:2 means T times the reciprocal of picture 2);
  (ii) the names X,Y,Z and RR are interpreted as x,y,z coordinates and the
       squared distance from the picture origin respectively, rather than as
       constants (see second example above);
 (iii) the arithmetical operators + - * and / accept complex as well as real
       operands (though ^ does not)
  (iv) the following additional or different functions are recognised:
         C(x,y)        complex number x+iy
         RE(z),IM(z)   real,imaginary part of complex z
         CC(z)         complex conjugate of complex z
         PHASE,MODULUS take a single argument which may be complex, rather
                       than up to two real arguments

The first picture mentioned in the expression plays a marginally special role
in two respects: (i) it determines the default output number and form; and
(ii) it determines the coordinate origin used (the recorded origin of other
pictures being ignored).  If the expression involves no pictures, the output
is used for these purposes.

Where the expression to be calculated involves no pictures at all, e.g.
CALCULATE SIN(KX*X+KY*Y), the output picture must already exist so as to
define a coordinate system and picture dimensions.

Although CALCULATE can cope with most expressions, there is a limit to the
complexity of expressions which it can process.  First of all expressions are
limited by the need to stack intermediate results when evaluating nested
expressions.  If you encounter this limit, CALCULATE will return with error
18: "Expression stack overflow".  The size of the expression stack is equal to
the number of row buffers.  The second limitation is to do with the number of
references to pictures which may be contained in an expression.  The number of
pictures is limited to the size of Semper's logical picture table less one
entry for the destination picture.  If there are too many pictures referred to
in an expression, CALCULATE returns with error 56: "Too many pictures open
simultaneously".  You can find out how many row buffers and picture opens are
supported on your system by typing the command SHOW SYSTEM.

                                         Multi-layer pictures: fully supported
                                        Forms used internally: fp,complex

See also: calculate.syntax
$add calculate.syntax
Keys:
  [] text        expression to be calculated [none]
  TO             output picture [first picture mentioned in expression, if
                 any; SELECT otherwise]

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add cell.command cell
The command CELL  controls the creation  and  operations  of  the
Semper  6  Plus cell element.  The default  highlight  style  for
cells is FLASH.

Examples:
     CELL CREATE TEXT 'Circle' FLASH
     creates  a new text cell with the contents 'Circle' on   the
     current panel, with flash highlighting.
$
Semper  6  Plus supports four different styles  of  cell:  CHECK,
FLASH, INVERT and TICK. Each CELL style has a number of  possible
states.  The  state of a cell may be changed by the  use  of  the
CYCLE  key or when the cell is selected (either by  entering  the
cell or clicking on it).

Initially  cells  are created on a panel; however,  they  may  be
moved onto a menu  using the ADD key. In fact, the CREATE  option
and  ADD  key  may  be specified at the same  time as the command
processes  them  in  the correct order. Adding cells  to  a  menu
removes them from the panel on which they  were created.    Cells
which are not part of a menu exist on their panel as buttons.

There  are several different methods of positioning  cells  which
can  be slightly confusing to the unwary. There is  the  standard
POSITION key which defines the cell location with respect to  the
panel  that it is on. If the cell is to be placed on a menu  (the
ADD  key), it may located either by ROW and COLUMN or by  OFFSET.
When  cells are located by ROW/COLUMN, Semper 6  Plus  calculates
the maximum width of all the cells in a column before  displaying
a menu.

The  DROP option allows the menu on which the cell is located  to
be  de-activated  when  the  cell is  selected.  This  saves  the
function called having to deactivate the menu - less overhead  in
tracking menu identifiers.

The  TITLE  and  TEXT keys allow the contents of  a  cell  to  be
defined;  it is not sensible to give both at the same  time.  The
TITLE  key  will  copy up to the first  twenty  characters  of  a
picture title or will substitute 'Picture: n' if no title exists.
The  TEXT  key takes a normal text key and this is taken  as  the
contents of the cell.

The BOX option will cause the cell to be surrounded by a box. The
box is similar to that drawn when a cell is named. The BOX option
is  provided because NAME '' defines the cell as having  no  name
rather than a null length name.

The  actions  taken  when the mouse enters a cell,  the  cell  is
selected, and the mouse leaves the cell are detailed in the table
below:

       +==========+============+============+============+
       | Style    | Enters     | Selected   | Leaves     |
       +==========+============+============+============+
       | CHECK    | No change  | Cycle      | No change  |
       +----------+------------+------------+------------+
       | FLASH    | No change  | Cycle      | No change  |
       +----------+------------+------------+------------+
       | INVERT   | Cycle      | No change  | Cycle      |
       +----------+------------+------------+------------+
       | TICK     | No change  | Cycle      | No change  |
       +==========+============+============+============+
See also: cell.syntax, element.syntax, uif.element
$add cell.syntax
Keys:
  ADD            The cell is added to the menu with the given id.
  BACKGROUND     Specifies the background colour to be used for the cell.
  BEGINS text    The given string is set as the 'interaction begins' action
                 for the cell.
  CHANGES text   The given string is set as the 'state change' action for
                 the cell.
  CYCLE          The cell is cycled though its highlight states by a given
                 number of states.  For CHECK highlighting, the states are
                 'plus mark', 'no mark' and 'minus mark'.  For FLASH
                 highlighting, there is only one state ('not flashing', but
                 the use of CYCLE will cause the cell to flash a given number
                 of times.  For INVERT highlighting the states are 'normal
                 video' and 'inverse video'.  For TICK highlighting the states
                 are 'no mark' and 'plus mark'.  The 'state change' action is
                 not performed.
  COLUMN         The cell is to be positioned at the given column number in
                 its menu.
  ENDS text      The given string is set as the 'interaction ends' action
                 for the cell.
  FOREGROUND     Specifies the foreground colour to be used for the cell.
  ID             Defines the cell to use [ENO].
  IN             Defines the panel in which the cell is to appear.  Does
                 not reset the value of variable PNO [PNO].
  NAME text      Defines a name for the cell.
  OFFSET(2)      The cell is to be positioned with the currently set location
                 point at the given offset within its menu in device dependent
                 units.
  POSITION(2)    Defines the position of the currently set location point
                 of the cell in the requested panel.  Using POSITION once
                 a cell has been created moves the cell.
  ROW            The cell is to be positioned at the given row number in its
                 menu.
  SIZE(2)        Defines a minimum X and Y size for the cell.  If the
                 cell requires to be larger than the size specified, the
                 size given here will be overridden.
  TEXT text      The cell is to contain the given text.
  TITLE          The text of the cell is to be the first twenty characters of
                 the specified picture's title.

Options:
  BOX            The cell is to be surrounded by a box.
  CHECK          The cell is to use check marks for highlighting.
  CREATE         Creates a cell.  This is the first option that is
                 checked for when the command looks at its arguments.
  DESTROY        Destroys a cell.
  DROP           The cell, when selected, will cause its menu to be
                 deactivated.  Is ignored for fixed menus.
  FLASH          The cell is to flash for highlighting.
  INVERT         The cell is to use 'inverse video' for highlighting.
  TICK           The cell is to use tick marks for highlighting.

Variables set:
  ENO            Set by the CREATE option to the identifier of the cell.

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add chull.command chull convex hull deficiency
You use the CHULL command to generate the convex hull for the regions defined
in the binary source image.  If you imagine an elastic band stretched around
all foreground regions in the source picture, the convex hull is the area
enclosed by the elastic band.  The convex hull therefore includes in its
boundary all the extreme points of the source regions, and it has no
concavities.  You can detect the presence of concavities in binary objects by
looking at the difference between the objects and their convex hulls.  If
there is no difference between an object and its convex hull, the object must
be convex.  CHULL also returns the convex perimeter and area in the variables
P and A.

Exx: CHULL; TYPE 'Convex perimeter and area: ',P,A
       replaces the current picture with its convex hull and types the
       perimeter and area of the convex hull
     CHULL 1 2; CALCULATE :2 & ~:1
       calculates the convex deficiency of regions in picture 1 and puts the
       result in picture 2
$
The source picture is treated as a binary image: zero values denote background
pixels and non-zero values denote foreground pixels.  The output picture will
contain the convex hull of the foreground regions.  Note that the source image
may contain any number of separate foreground regions.  CHULL always produces
a single convex hull which includes all the foreground regions in the source
picture.

CHULL returns the perimeter and area of the convex hull in Semper variables P
and A.  The perimeter and area correspond exactly to the values which the
ANALYSE command would return for the convex hull.

The range of the final result is stored in the output picture label.

See also: chull.syntax, analyse
$add chull.syntax
Keys:
  [FROM]         source picture [SELECT]
  [TO]           output picture [FROM]

Variables set:
  P              perimeter of convex hull
  A              area (number of pixels) of convex hull

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add close.command close buffers
The intrinsic command CLOSE is used in some installations to release to the
display device material currently retained in main memory buffers. This is
usually were the display is a hardcopy device.
$add close.syntax
Close takes no arguments
$add cls.command cls clear
This command is used to clear the command line screen only. (To clear the
image display see the command ERASE).
$add cls.syntax
The CLS command takes no arguments
$add colour.command colour map rgb
You use COLOUR to convert a single or three layer image into a three layer
image, optionally applying a different value mapping to each layer. This
conversion is normally used to create RGB images from a combination of
monochrome image and a colourmap, but can also be used to remap an existing
RGB image.

Exx: COLOUR 1 TO 2
       converts picture 1 into 3 identical layers in picture 2

     INPUT 1 TIFF NAME 'image.tif' MAP 2
     TRAP=-1 SELECT 2; IF RC=0 COLOUR 1 WITH 2
       reads the index values from a TIFF image as picture 1 and any
       associated colourmap as picture 2. The COLOUR command is then
       used to create a correctly coloured RGB image if a MAP was read.
$
COLOUR operates in one of two modes. If the WITH keyword is not supplied
then the source picture is replicated into a three layer destination picture.

If WITH is given, it must be a single layer picture of width 256 pixels with
one or three rows of data and the source picture must be of BYTE form. The
data in each row of WITH is used to map the source picture to the
corresponding layer in the destination picture. On systems with a LUT length
of 256 (e.g. Windows Semper) the picture referenced by WITH can be a LUT.

See also: colour.syntax input
$add colour.syntax
Keys:
  [FROM]         source picture [SELECT]
  [TO]           output picture [FROM]
  WITH           picture containing (colour) map

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add commands.command summary commands
Variables and terminal dialogue
  name=val  Sets key/option/variable named to given value
  ASK       Seeks value(s) from the terminal with user-defined prompt
  BEEP      Sounds bell on terminal - also BELL, BUZZER
  CLS       Clears terminal screen and places cursor at home position
  ECHO      Directs logical output streams to terminal and/or log files
  EVENT     Provides access to event queues
  HELP      Provides on-line documentation during session
  INKEY     Waits for terminal keys to be pressed and returns key values
  LOCAL     Declares variables to be restored after program execution
  LOG       Prints text/values to log output stream
  P,PIXEL   Resets individual pixel(s) in picture to user-defined value(s)
  PAGE      Controls formatting and paging of terminal output
  POINTER   Defines pointer (i.e. mouse) gearing and sensitivity
  REPORT    Prints message for last reported/trapped error
  SHOW      Prints information on variables set, devices assigned, time, etc.
  SYNTAX    Prints keys and options for given command
  TIME      Prints elapsed time in seconds
  TYPE      Prints text/values to console output stream
  UNSET     Unsets variable(s) permanently

Program execution
  @name     Inserts named macro text in command line
  @number   Inserts numbered macro text in command line (executes macro)
  ADD       Adds new program(s) to program library
  BREAK     Resumes execution after end of FOR loop
  EDIT      Edits contents of numbered macro
  END       Last command in program or run file
  FOR       Repeats subsequent commands (up to corresponding LOOP)
  IF,UNLESS Makes command execution conditional
  JUMP      Resumes execution at given label
  LIBRARY   Executes program from program library
  LIST      Prints program text or numbered macro text
  LOOP      Terminating command for FOR loop
  MACRO     Causes rest of input line to be stored as numbered macro
  NEXT      Resumes execution at start of next cycle of FOR loop
  ORDER     Defines/prints search order for program libraries
  RENAME    Renames program in program library
  RETURN    Returns from program or run file
  RUN       Executes commands from named file (run file)
  STOP      Halts session - also EXIT and QUIT
  WAIT      Suspends execution until key pressed or specified time elapsed

Miscellaneous
  NULL      Default command (same as DISPLAY)
  PACK      Prints packed integer values for given names
  UNPACK    Prints three-character names for given packed integer values
  USER      Provides skeleton routine for users to add their own facilities

Picture display/inspection
  CONTOUR   Draws contour map on display (line graphical form)
  DISPLAY   Displays picture/region in various modes  (NB: Most commands
            can output directly to the display provided that variables MIN
            and MAX are suitably set, e.g. SHARPEN 1 TO DISPLAY)
  DRAG      Drags various kinds of graphics objects on the display
  EXAMINE   Prints picture size, class, data form, title, etc.
  HISTOGRAM Generates/draws grey-level histogram of picture/region
  LADJUST   Provides mouse-controled adjustment of look-up tables
  LSET      Generates/modifies look-up tables (colour scales, highlighting)
  LUT       Generates and manipulates monochrome/colour look-up tables
  MARK      Marks position(s), frame, circle or text on a display
  OVREAD    Reads image stored in the overlay into a picture
  OVWRITE   Writes a binary image into the overlay plane
  PFILTER   Reduces the data in a position list
  PICTURE   Returns picture size, class, data form, etc. in Semper variables
  POSTSCRIPT  Writes picture/display region to file in PostScript format
  PRINT     Prints small picture region in numerical form
  RGB       Converts a full colour image into monochrome/false colour form
  SHEET     Displays 2-D picture as height of solid sheet
  SKETCH    Records curve drawn free-hand via the display cursor as a plist
  SOLID     Displays thresholded 3-D picture as solid body
  SPC       SuperPoses Contour levels on picture
  SURVEY    Scans picture/region and sets variables MIN, MAX, MEAN, ME2 and SD
  VIEW      Selects viewing field, zoom factor and (mono, false or colour) lut
  XWIRES    Records position/direction/frame indicated via display cursor
  YMOD      Displays picture/region as surface height (line graphical form)

Picture management
  COPY      Copies picture or program
  CREATE    Allocates/initialises picture storage (not normally needed)
  DATA      Stores information in picture label
  DELETE    Deletes picture or program
  INPUT     Reads picture from external file in a variety of portable formats
  LETTER    Generates lettering on a 5 by 6 pixel matrix
  ORIGIN    Moves or resets picture coordinate origin
  OUTPUT    Writes picture to external file in a variety of portable formats
  PCB       Stores picture coordinate range, class, data form in variables
  READ      Reads picture from file outside Semper
  RECLASS   Changes recorded picture class without altering data
  RENUMBER  Changes picture number without altering data
  SAVE      Saves picture in binary file outside Semper
  SELECT    Selects new current picture
  TITLE     Sets or alters picture titles
  WP        Sets or unset picture write-protect flag
  WRITE     Writes picture to file outside Semper

Device management
  ASSIGN    Assigns disc file, tape, display, log file, program library or
            help library as device
  CLOSE     In some installations, outputs contents of display to hardware
  COMPRESS  Compresses disc device, collecting empty space together
  DEASSIGN  Deassigns device
  DIRECTORY Prints directory state for a disc device
  ERASE     Erases image or overlay memory for display region
  FLUSH     Forces disc memory buffers to be copied to physical disc
  PARTITION Assigns frames and positions for display partitions
  RAMPS     Fills display region with repeated grey-level ramps
  REINITIALISE  Re-initialises device, destroying any exising data

Point by point operations
  CALCULATE Calculates arbitrary arithmetical/relational/logical expression
            involving pixels, constants, variables and functions
  CORRECT   Forces picture modulus to supplied reference value
  FIT       Fits linear ramp to picture, and subtracts/divides to remove ramp
  GAUSSIAN  Generates single Gaussian-profile peak
  LORENTZIAN  Generates single Lorentzian-profile peak
  MAP       Processes picture with user-defined intensity mapping
  MASK      Resets pixels inside/outside circular or polygonal region
  NEGATE    Rescales picture interchanging MIN and MAX
  NOISE     Generates (Gaussian or Poisson) noise-limited pictures
  SCALE     Rescales picture, linearly or with histogram equalisation
  THRESHOLD Applies intensity threshold(s) to generate binary picture

Geometrical operations
  CUT       Cuts region out of picture
  EXPAND    Horizontally resamples a picture
  EXTRACT   Extracts sub-/super-region (magnified/rotated/skewed/warped)
  FIND      Finds lowest/highest pixel or centre-of-mass of picture/region
  FULLPLANE Converts half-plane Fourier picture to full-plane form
  HALFPLANE Converts full-plane Fourier picture to half-plane form
  MAGNIFY   Magnifies picture/region by integer factor
  PASTE     Inserts one picture into another
  PEAKS     Locates local peaks in picture and records positions in Plist
  ROTATE    Rotates picture by large angles relatively efficiently
  SEPARATE  Separates layers of multi-layer (3-D) picture as 2-D pictures
  STACK     Combines 2-D pictures as multi-layer (3-D) picture
  TRANSPOSE Transposes picture (i.e. interchanges rows and columns)
  TURN      Performs simple picture reflections/rotations

Local operations
  DIFFERENTIATE  Calculates picture derivatives via 3-point operator
  EDGE      Applies magnitude or Roberts edge operator
  FIR       Applies arbitrary small block (FIR) filter (with options for
            Gaussian smoothing and Laplacean sharpening)
  HP        Applies a square-block high-pass operator
  LMEAN     Calculates local block mean (smoothes picture)
  LSD       Calculates local block standard deviation
  LVARIANCE Calculates local block variance
  RANK      Applies local ranking (median, eroding or dilating) filter
  RF        Applies two point recursive (IIR) filter for smoothing/sharpening
  SHARPEN   Applies square-block edge-enhancing operator

Transformation/filtering
  BACKPROJECT  Back-projects 1-D picture into 2-D picture
  CTF       Generates/applies electron-optical transfer function
  FOURIER   Calculates Fourier transform (FTs)
  HILBERT   Calculates Hilbert transform
  IMAGE     Re-calculates image from Fourier or Walsh transform
  PHR       Resets Fourier transform phases to random values
  PS        Calculates a power spectrum (i.e. FT intensity)
  WALSH     Calculates Walsh transform
  WEIGHT    Applies radial filter defined in 1-D picture
  WINDOW    Applies window array filter (for lattice averaging)

Line, lattice and rotational averaging
  BASE      Least-squares fits lattice parameters to list of lattice sites
  FLC       Fits Lattice Components to FT peaks (for lattice averaging)
  LATTICE   Generates/marks positions of perfect lattice sites
  MOTIF     Calculates real-space average over given list of positions
  PROJECT   Calculates 1-D projections or averages
  SECTION   Extracts radial sections averaged over arbitrary sectors
  STRAIN    Deduces local strain levels for a distorted lattice

Correlation functions and alignment
  ACF       Calculates auto-correlation function
  OCF       Calculates angular correlation function (for rotational alignment)
  RCF       Calculates radial correlation function/phase residuals between
            two Fourier transforms
  XCF       Calculates (spatial) cross-correlation function

Particle analysis
  ANALYSE   Finds particles in picture according to given intensity thresholds
  PCALCULATE  Calculates further parameters for given particle
  PCURVE    Calculates equivalent particle parameters for area inside curve
  PDRAW     Edits picture by drawing cursor-defined lines
  PEDIT     Edits contents of particle parameter list and/or segmented map
  PEXTRACT  Extracts image of single particle from source picture
  PFERET    Calculates up to 9 feret diameters for given particle
  PHISTOGRAM  Generates histogram of given parameter for selected particles
  PID       Returns particle id corresponding to given picture position
  PMARK     Marks selection of displayed particles
  PMOMENT   Calculates invarient moments for given particle
  PSET      Stores specified particle parameters in variables
  PSHOW     Highlights selection of displayed particles
  PTYPE     Prints parameters for selected particle(s)

Morphology
  BCLOSE    Performs binary closure with a user defined structuring element
  BDILATE   Performs binary dilation with a user defined structuring element
  BERODE    Performs binary erosion with a user defined structuring element
  BHMT      Performs binary hit or miss transform
  BMLUT     Creates look-up table defining 3x3 neighbourhood transformation
  BMMAP     Applies arbitrary 3x3 neigbourhood transformation to binary image
  BOPEN     Performs binary opening with a user defined structuring element
  DCLOSE    Performs binary closure with circular structuring element
  DDILATE   Performs binary dilation with circular structuring element
  DERODE    Performs binary erosion with circular structuring element
  DILATE    Dilates simply or selectively, and grows objects without joining
  DOPEN     Performs binary opening with circular structuring element
  DT        Generates distance transform of regions in a binary image
  ERODE     Erodes simply or selectively, and generates outlines or skeletons
  FLOOD     Fills binary regions starting from given set of seed points or
            regions
  HFILL     Fills holes in regions of a binary image
  LABEL     Labels and counts separate regions in a binary image
  MEDIAN    Smoothes binary picture
  SKIZ      Generates skiz (skeleton by zones of influence)
  ZONE      Generates zones of influence of regions in a binary/labeled image

Remote Sensing
  BOX          Classifies picture using box or parallelipiped method
  COVARIANCE   Calculates covariance of multi-spectral picture
  DESTRIPE     Corrects picture for differences in line sensor characteristics
  LEARN        Calculates statistics of training areas prior to classification
  LIKELIHOOD   Classifies picture using maximum-likelihood method
  MINDISTANCE  Classifies picture using minimum-distance-to-mean method
  PCT          Calculates principal components transform of multi-spectral
               picture
  RHISTOGRAM   Calculates 2-D histogram between bands of multi-spectral
               picture
  WARP         Corrects picture for geometric distortions

User Interface Commands
  CELL      Controls creation and behaviour of cell element
  DEVICE    Returns limits of display, redraws screen, stacks cursor positions
  EXECUTE   Defines actions executed before/after each Semper command sequence
  JUSTIFICATION  Controls positioning of displayed objects
  MENU      Controls creation and behaviour of menu element
  MOUSE     Defines actions/positioning for mouse (pointing device)
  PANEL     Controls creation and behaviour of panels
  TEXTFIELD Controls creation and behaviour of textfields
  UIF       Controls loading, saving and execution of user interfaces
$add compress.command compress squish fragmented space
If a disc device contains a useful amount of free space, but is too badly
fragmented for Semper to be able to make use of it, you use COMPRESS to
collect all the data together at the beginning and all the free space together
at the end.  Also, if a program library has become full because of repeated
addition of new versions to the end, COMPRESS recovers the space occupied by
the 'deleted' versions.

Exx: COMPRESS
       compresses the current device CD
     COMPRESS DEVICE 4
       compresses device 4
$
Semper responds as soon as possible to abandon requests during COMPRESS
commands, but this is not usually immediately; the result is a partially
compressed disc in which some, but not all, pictures have been moved to the
beginning.

See also: compress.syntax
$add compress.syntax
Key:
  DEVICE         device to be compressed [CD]

Options:
  VERIFY         confirm compress operation on the console [YES]

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add contour.command contour isointensity
You use CONTOUR to draw picture intensity contours in a display overlay. [If
you want the contours recorded permanently in a picture, by alteration of its
pixels, use SPC instead.]

Exx: CONTOUR 52 TIMES 3
       draws a contour map in DISPLAY of picture 52 interpolated to three
       times the normal size.
     CONTOUR 52 TIMES 3 TO DIS:4
       does the same in DISPLAY:4
     CONTOUR DIS:3 LEVELS 9
       adds 9 contours to DISPLAY:3
$
You can contour a subregion only via the standard (multi-layer) subregion
keys/options; successive layers are output to successive display frames, just
as for DISPLAY.  To set your own contour heights, set MIN, MAX and LEVEL
suitably and quote PRESET: note that the contour levels do not include MIN
and MAX themselves however.

CONTOUR is in fact closely related to the DISPLAY command: the display
partition used is erased and/or lettered in exactly the same way; the size and
position of the display is identical, so that superposition as in the second
example is possible; and subsequent graphical annotation/cursor measurement is
made in the same coordinate system.

If the MARK key is set, the limits of the source region are marked on the
indicated display picture.
                                            Restrictions: not 1-D
                                         Display marking: source region
                                    Multi-layer pictures: fully supported
                                   Forms used internally: fp,complex

See also: contour.syntax
$add contour.syntax
Keys:
  [FROM]        picture to be displayed [SELECT]
  [TO]          output display picture [DISPLAY]
  TIMES         integral magnification factor [1]
  LEVELS        number of contour levels to mark [5]
  SIZE(3)       dimensions of subregion to be contoured [whole picture]
  POSITION(3)   displacement of subregion position [0,0,0]
  LAYER(2)      range of layers in subregion [all unless SI3/PO3 set]
  MARK          display to be marked with border indicating source region
                [none]

Options:
  PRESET        set contour range from current MIN,MAX [lowest,highest pixel
                values used]
  LETTER        letter top of partition with picture number, title, etc. [YES]
  BORDER        mark picture border [YES]
  LEFT | RIGHT
  BOTTOM | TOP  contour subregion abutting indicated picture border
  FAR | NEAR

Variables used:
  MIN,MAX       if PRESET, pixel range spanned by contours

Variables set:
  MIN,MAX       unless PRESET, pixel range within picture/region contoured

See SUBREGIONS for more details of subregion keys/options.
See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add copy.command copy fix float
You use COPY to copy a picture, or set of pictures, somewhere else; to copy
a program; or to change the form of a picture.

Exx: COPY DIS TO 3
       copies picture DISPLAY to picture 3
     COPY 100,200 TO 5:1
       copies any pictures numbered between 100 and 200 on the current device
       to 5:1, 5:2.. in succession
     COPY 2 INTEGER
       converts picture 2 to integer form
     COPY PROGRAM 'MYPROG' AS 'NEWVER'
       makes a copy of program MYPROG as a new program NEWVER, provided that
       NEWVER does not already exist
$
COPY works in two modes: picture (in default) and program (if you use the key
PROGRAM).  In picture mode, every characteristic of a source picture is copied
identically to the output except for the WP  status: the output is considered
a new picture by Semper, and must be protected explicitly if you want it
protected (e.g. COPY TO ..; WP). If the output form is changed (e.g. if
picture 1 is form fp and you use COPY 1 TO .. BYTE) then the range information
is deleted from the output picture.

In program mode, the output is copied within the device on which it is found,
and if you omit a new name for it Semper solicits one at the terminal.  You
can copy to a different device if you want to (e.g. COPY .. DEVICE 5), in
which case the output name defaults to the source name.  The program copied
is the first one found in the current device search order, if more than one
version exists.

                                         Multi-layer pictures: fully supported
                                        Forms used internally: all

See also: copy.syntax
$add copy.syntax
Keys:
  [FROM(2)]      source picture number, or first,last picture numbers if a
                 range of pictures is to be copied [SELECT,SELECT]
  [TO]           output picture number, or first number if a range of pictures
                 is to be copied [FROM]
  PROGRAM text   name of program to be copied [none; copies picture(s)]
  AS text        name to be given to new copy of program [original name, if
                 you indicate the destination device explicitly via DEVICE]
  DEVICE         number of program library to which program is to be copied
                 [first device in current search order]

Options:
  VERIFY         confirm copy operation on the console [YES]

The keys FROM and PROGRAM are mutually exclusive alternatives.
See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add correct.command correct
CORRECT resets the modulus of a Complex picture to that of a given 'reference'
picture, without altering the phase.  You use it frequently in iterative
phase-determination algorithms of the Gerchberg type.

Exx: CORRECT WITH 40
       alters the current picture to have the modulus indicated in picture 40
     CORRECT 1 TO 2 WITH 40
       applies the alteration to picture 1, storing the result as picture 2
$
Zero source pixels are copied unchanged.  A mismatch (error) criterion is
calculated, optionally printed on the console, and returned in the variable E,
consisting of the summed squared difference between the source modulus and the
reference, expressed as a fraction of the summed squared reference.

                                                 Multi-layer pictures: faulted
                                                 Form used internally: complex

See also correct.syntax
$add correct.syntax
Keys:
  [FROM]         source picture [SELECT]
  [TO]           output picture [FROM]
  WITH           picture containing 'reference' modulus

Options:
  VERIFY         print on the console the mismatch criterion

Variable set:
  E              mismatch criterion fractional summed squared difference

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add covariance.command covariance statistics
The COVARIANCE command forms the covariance matrix of a multi-layer picture.

Exx: COVARIANCE 1 2
       calculate the covariance matrix of picture 1, storing the result in
       picture 2
$
The covariance matrix of the input picture is calculated and output.  This
information can then be passed to the PCT command to carry out the Principal
Component transform or Hotelling transform.  Additionally the mean, standard
deviation and range of each layer are output to the picture.  The range
information may be used subsequently by the BOX command to carry out box
classifications.  The number of layers which this command can process is both
picture and system dependent; large (wide) pictures have to have fewer layers.

You can use the COVARIANCE command to identify rectangular training regions
for use in supervised classification.  The covariance data for the different
classes should be stacked together with the STACK command.  The LEARN command
may be used instead to generate covariance data for arbitrarily-shaped
training regions.

See also: covariance.syntax, learn, pct, box
$add covariance.syntax
Keys:
  [FROM]         source picture [SELECT]
  [TO]           output picture [FROM]
  SIZE(2)        dimensions of subregion to be processed [whole picture]
  POSITION(2)    position/offset of subregion

Options:
  LEFT | RIGHT   process subregion abutting indicated picture border
  TOP | BOTTOM

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add create.command create allocate initialise constant
You can use CREATE to initialise disc pictures to constant values, perhaps as
the object of later calculation or pasting operations, or to test whether
enough space is available for a given picture; also to 'redeclare' displays so
that the display memory is used in a different way.

Exx: CREATE 1 SIZE 256 BYTE; CALCULATE 100+.13*X-.096*Y
       generates a Byte picture 1 filled with a planar intensity ramp
     MIN=0 MAX=255; CREATE DISPLAY SIZE 512
       allows you to treat a 512x512 display, initially created with a
       different black-white range, as if its range were 0-255.
     CREATE 52 FOURIER COMPLEX SIZE 129,256 VALUE 0; ORIGIN LEFT; P 2,3=P,Q
       creates a half-plane Fourier picture containing a single non-zero
       Fourier coefficient at (2,3)
$
In default, the picture is created with the same size as the current picture
(SELECT), class Image and form Fp; if you want anything else, just quote the
size (up to three components) and/or class/form name you want.  CREATE does
not erase display partitions, regardless of variable ERASE.

If you are creating a Plist, the additional options LIST, CURVE, OPEN and
CLOSED can be used to force the type as follows:
   .. PLIST  or  .. PLIST LIST                list
   .. PLIST CURVE  or  .. PLIST OPEN CURVE    open curve
   .. PLIST CLOSED CURVE                      closed curve

You do NOT need to do any kind of 'pre-creation' of pictures before using them
as output for Semper commands generally: commands create their own output
pictures as necessary.

If you have Byte data on magnetic tape in files that do not have the standard
256-byte labels used by Semper, you can gain access to them if you use CREATE
to tell Semper the picture size; class Image and form Byte are assumed.  A
picture 'opened' this way is not opened permanently however; COPY it to
somewhere else as soon as possible.
                                         Multi-layer pictures: fully supported
                                        Forms used internally: all

See also create.syntax
$add create.syntax
Keys:
  []             picture to be created [SELECT]
  SIZE(3)        dimensions of picture [dimensions of SELECT]
  VALUE(2)       value to which pixels are to be initialised (as a pair if a
                 complex value is needed) [no pixel initialisation]
Options:
  IMAGE|FOURIER|SPECTRUM|CORRELATION|UNDEFINED|WALSH|HISTOGRAM|PLIST|LUT
                 class of picture [IMAGE]
  LIST | CURVE   type of Plist, if PLIST [LIST]
  OPEN | CLOSED  type of curve, if PLIST CURVE [OPEN]

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add ctf.command ctf contrasttransferfunction transferfunction
You can generate or apply via CTF the very complicated 'transfer functions'
(Fourier transform filters) that characterise imaging in high resolution
electron microscopy (conventional fixed beam TEM); you might use it in a
variety of different ways for image simulation or restoration.

Exx: LIBRARY EM
       runs a library program that prompts you for all relevant instrumental
       conditions etc.
     MIN=0 MAX=4; CTF SQUARED TO DISPLAY SIZE 128
       would display the intensity in the weak-phase object contrast c.t.f.
       for the current imaging conditions, perhaps allowing comparison with an
       experimental diffractogram
     CTF MULTIPLY 30 TO 31
       would multiply picture 30 by the t.f., placing the result in 31
$
CTF is inevitably a particularly complicated command.  The main options
control..
  1) what is done with the t.f..  CTF ADD and CTF MULTIPLY apply it as
     indicated to a source picture, but CTF alone simply stores the transfer
     function as the output - class Fourier, full plane unless you quote HALF,
     and dimensions given by SIZE (one or two components)
  2) what kind of t.f. is generated.  CTF alone (or CTF PHASE in fact)
     generates the weak-phase object c.t.f. 2sin(gamma).. while CTF AMP
     generates the weak-amplitude object c.t.f. 2cos(gamma).. and CTF WAVE
     generates the complex form exp(-i.gamma)..; CTF PHASE AMP generates the
     product of the two c.t.fs.  With any of these, SQUARED causes the squared
     modulus of the t.f. to be used, and CC its complex conjugate.
  3) whether the imaging conditions are specified in 'reduced' units; CTF
     alone assumes these (axial distances in scherzer units (Cs^.5lambda^.5),
     transverse in glaser units (Cs^.25lambda^.75), and angles in Gl/Sch; but
     while CTF PHYSICAL assumes all distances in nanometres and all angles in
     millradians.

The imaging conditions are largely specified by variables rather than
options or keys, except that you may use a key DEFOCUS to override the defocus
locally. The full set relevant is as follows; the simplest way to set them is
to use the Semper library program EM as in the first example.
  STEP Image sampling interval (half the minimum period in transform); a value
    for this is always required
  CS Spherical aberration coefficient (relevant/required only if PHYSICAL)
  KV Accelerating voltage in kV (relevant/required only if PHYSICAL)
  DEFOCUS Defocus (underfocus positive)
  ASTIGMATISM Astigmatism (maximum minus minimum underfocus)
  APHI Azimuth of maximum underfocus (clockwise from +X axis in radians)
  SWIDTH Illumination divergence (r.m.s. of equivalent gaussian profile)
  EWIDTH Focus spread (r.m.s. of equivalent gaussian profile)
  TILT Magnitude of primary beam tilt (w.r.t. optical axis)
  TPHI Azimuth..
  OARADIUS Objective aperture radius (w.r.t. optical axis)
  OADISPL Magnitude of objective aperture displacement
  OAPHI Azimuth..
  DRIFT Magnitude of linear specimen drift during exposure
  DPHI Azimuth..
  VIBRATION Lateral specimen vibration level (r.m.s.)
Except for STEP, CS and KV, zero is assumed for any variables not set.

                                                 Multi-layer pictures: faulted
                                                 Form used internally: complex

Outline of image formation theory and transfer function expressions
-------------------------------------------------------------------
Write 1+p for the wave leaving the specimen given perfectly collimated
monochromatic illumination (p being thus the scattered wave, arbitrarily
complex in general); a Fourier component of p crossing the diffraction plane
at k is transmitted to the image plane by the lens phase shifted by a 'wave
aberration function' g(k).  When the primary beam is inclined so as to pass
the diffraction plane at k0, the transform of the image intensity then takes
the form
   I(k) = d(k)  +  P(k)exp{-i[g(k0+k)-g(k0)]}
                +  P*(-k)exp{i[g(k0-k)-g(k0)]}  +  terms quadratic in P
{d is a delta function, P the transform of p, and * denotes - exceptionally -
a complex conjugate).  Neglecting the quadratic terms constitutes the weak-
object approximation, and these terms is not accommodated by CTF.  Averaging
this expression over incident beam direction and focus level leads, for the
narrow profiles typical of normal practice, to additional 'envelope' factors
E(k+k0,k0) and E(k-k0,k0) attenuating the terms in P(k) and P*(-k)
respectively.

The WAVE form of CTF is the factor multiplying P(k) in the above, including
the envelope factor; the intensity (CALC MSQ(..)) in the image wave after this
form of CTF is applied gives the image for an arbitrarily complex (but weak)
P(K). An arbitrarily strong P(k) can be accommodated by omitting the envelope
factor (set SWIDTH=0 and EWIDTH=0), and averaging the image wave intensities
for a series of distinct illumination components in turn. When illumination is
axial (k0=0), the expression simplifies to exp(-ig(k))E(k,0).

For weak-phase objects, p = ih with h measuring the (real) phase shifts; the
conjugate symmetry of the transform H(k) then means that the two terms above
can be combined to give H(k)i[exp{-i[g(k+k0)-g(k0)]} - exp{i[g(k-k0)-g(k0)]}];
the PHASE (or default) form of CTF is the factor multiplying H(k) here,
with the appropriate envelope factors incorporated.  When the imaging is
axial, this becomes 2sin(g(k))E(k,0).

For a weak-amplitude object, p itself is real, and the two terms combine to
give P(k)[exp{-i[g(k+k0)-g(k0)]} + exp{i[g(k-k0)-g(k0)]}]; the AMP form of CTF
is the factor multiplying P(k) here, with envelope factors incorporated as
before.  When the imaging is axial, it becomes 2cos(g(k)).

In reduced units, g(k) has the form pi.k^2(.5k^2-D), with D the effective
defocus at azimuth phi, DEF+(AST/2).cos{2(phi-APHI)}; the gaussian profiles
exp(-k^2/SWI^2) and exp(-d^2/2/EWI^2) used to model divergence and focus
spread lead to the form
   E(k,t) = exp{ -pi^2[.5EWI^2(k^2-t^2)^2 + SWI^2.|(k^2-D)k-(t^2-D)t|^2] }
(for zero astigmatism at least - CTF includes the effect of astigmatism
correctly, and the exact expressions are only omitted here for brevity).  When
imaging is axial, this simplifies to
   E(k,0) = exp{ -pi^2[.5EWI^2k^4 + SWI^2.((k^2-D)k)^2] }

Uniform specimen drift results in an additional factor sin(pi.DRI.k)/m.DRI
with k measured in the appropriate direction, and vibration, modelled by a
gaussian profile exp(-x^2/VIB^2), a factor exp(-2pi^2VIB^2k^2).

                                                 Multi-layer pictures: faulted
                                                 Form used internally: complex

See also ctf.syntax
$add ctf.syntax
Keys:
  [FROM]         source picture for ADD or MULTIPLY [SELECT]
  [TO]           output picture [FROM]
  SIZE(2)        picture dimensions if no source
  DEFOCUS        defocus (underfocus positive) [0]

Options:
  ADD | MULTIPLY add ctf to source, or multiply source by ctf [generate ctf
                 in new output picture]
  HALFPLANE      when no source, generate right half-plane output
  PHASE          generate weak-phase object ctf [assumed unless AMP or PHASE]
  AMPLITUDE      generate weak-amplitude object ctf
  WAVE           generate 'wave' form of ctf, i.e. exp-i{gamma}
  SQUARED        generate squared ctf (not necessarily modulus squared)
  CC             generate complex conjugate of ctf
  PHYSICAL       interpret variables describing imaging conditions in physical
                 units (nm,mrad) rather than reduced; requires CS,KV set
  VERIFY         list on the console the results of the computation

Variables used:
  STEP           image sampling interval (half minimum period in transform)
  CS             spherical aberration coefficient/mm; required if PHYSICAL
  KV             accelerating voltage/kV; required if PHYSICAL
  ASTIGMATISM    astigmatism (maximum minus minimum underfocus) [0]
  APHI           azimuth of max underfocus/mrad; clockwise from +X axis [0]
  SWIDTH         illumination divergence (rms of equiv gaussian profile) [0]
  EWIDTH         focus spread (rms of equivalent gaussian profile) [0]
  TILT           magnitude of primary beam tilt (w.r.t. optical axis) [0]
  TPHI           azimuth../mrad [0]
  OARADIUS       objective aperture radius (w.r.t. optical axis) [infinite]
  OADISPL        magnitude of objective aperture displacement [0]
  OAPHI          azimuth../mrad [0]
  DRIFT          magnitude of linear specimen drift during exposure [0]
  DPHI           azimuth../mrad [0]
  VIBRATION      lateral specimen vibration level (rms) [0]

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add cut.command cut extract subregion region section
You use CUT for simple picture subregion extraction - for rectangular regions,
with one or more layers.  [If any scaling, rotation, or shear is needed, try
MAGNIFY or EXTRACT instead.]  PASTE provides the complementary insertion
operation.

Exx: CUT 1 2 SIZE 200 TOP LEFT
       cuts out the top left 200 pixels square of picture 1 as picture 2
     XWIRES REGION; CUT @REGION TO 2
       cuts out from the current picture a region marked with the cursor
     CUT LAYER 1 TO 2
       cuts out the first (back) layer only
     PCB; SURVEY; CUT TO 2 SIZE NCOLS+20,NROWS+20 VALUE (MIN+MAX)/2
       makes a copy of the source image with a grey, 20 pixel wide border
$
The region to be cut out is indicated by the standard 2-D and multi-layer
subregion keys/options.  If the region overflows the source picture however,
it is padded rather than truncated, with a value specified by the VALUE key
(default is zero).

If the source picture origin is included in the region cut, it is recorded as
the origin of the output too.

If the MARK key is set, the limits of the region cut out of the source picture
is marked on the indicated display picture.
                                           Display marking: region cut
                                      Multi-layer pictures: fully supported
                                     Forms used internally: integer,fp,complex

See also: cut.syntax, paste
$add cut.syntax
Keys:
  [FROM]         source picture [SELECT]
  [TO]           output picture [FROM]
  SIZE(3)        dimensions of subregion to be cut [whole picture]
  POSITION(3)    displacement of subregion position [0,0,0]
  LAYER(2)       range of layers in subregion [all unless SI3/PO3 set]
  VALUE          default pixel value for padding output image [0]
  MARK           display to be marked with border indicating region cut [none]

Options:
  LEFT | RIGHT
  BOTTOM | TOP   subregion abutts indicated picture border
  FAR | NEAR

See SUBREGIONS for more details of subregion keys/options.
See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add data.command data picture parameters
Use the DATA command to store or retrieve an array of 10
floating-point values in the label of the specified picture.  The
values are passed via Semper variables V0, V1, V2, V3, V4, V5, V6,
V7, V8 and V9.  A zero value is stored for any variable that is unset.
Each floating-point value is stored as the four constituent byte
values, so the representation is not necessarily portable between
different systems where the floating-point format or the byte ordering
is not the same. Note that reading values from the label of a picture
that was not previously set may cause invalid floating point values to
be created.

Exx: V0=23.6; DATA SET
       stores 26.3 as the first floating-point value in the label of
       the current picture
     DATA 2:5 GET
       returns 10 floating-point values stored in picture 2:5 in
       variables V0, V1, V2, V3, V4, V5, V6, V7, V8 and V9
     DATA GET; V3=-V3; DATA SET
       negates the third floating-point value in the current picture

See also:data.syntax
$add data.syntax
Keys:
  [PICTURE]      source/destination picture [SELECT]

Options:
  SET            store the data values
  GET            retrieve the data values

Variables used:
  V0,V1,V2,V3,V4,V5,V6,V7,V8,V9

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add dclose.command dclose close
You use the DCLOSE command to close a binary source image with a circular disc
of arbitrary radius.  The output picture will contain the binary, closed
result, which represents the complement of the area swept out by the
structuring element whilst is is contained entirely within the background
regions of the source image.  You can select a different shape for the
structuring element by specifying one of the options DIAMOND, SQUARE or
OCTAGON.  In all cases, the size of the structuring element is specified with
the RADIUS key.

Exx: DCLOSE 1 2 RADIUS 11.2
       closes the binary image in picture 1 with a circular disc of radius
       11.2 pixel units and outputs the result to picture 2
     DCLOSE 1 SQUARE RADIUS 10
       closes the binary image in picture 1 with 21 by 21 square structuring
       element
     DCLOSE OCTAGON RADIUS 20
       closes the binary image in the current picture with an octagon of
       radius 20
$
The source picture is treated as a binary image: zero values denote background
pixels and non-zero values denote foreground pixels.

The DCLOSE command works by thresholding the distance transform of the source
image (see the DT command for more about distance transforms).  The point
about using distance transforms is that they can be obtained with just two or
four passes through the image which means that the time it takes to close the
source image does not depend on the size of the structuring element.  By
default, the Euclidean distance transform is evaluated, which means that the
source image can be closed with an exact circular disc of arbitrary radius.

In fact, the DCLOSE command is exactly equivalent to using the commands DT and
THRESHOLD in turn:

    DCLOSE <shape> RADIUS r  =>  DT <shape> BG; THRESHOLD LE r;
                                 DT <shape> FG; THRESHOLD GT r

    where <shape> = option DIAMOND, SQUARE, OCTAGON or CIRCLE (default)

However, the DCLOSE command is faster and easier to use.

When calculating the distance transform, the DCLOSE command may have to open a
temporary picture (see the DT command for details).

The DCLOSE command will fault any source picture which has a zero range.  On
successful completion, the range of the final result is stored in the output
picture label.

See also: dclose.syntax dt threshold
$add dclose.syntax
Keys:
  [FROM]         source picure [SELECT]
  [TO]           destination picture [FROM]
  RADIUS         size of structuring element

Options:
  DIAMOND | SQUARE | OCTAGON | CIRCLE
                 shape of structuring element [CIRCLE]

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add ddilate.command ddilate dilate
You use the DDILATE command to dilate a binary source image with a circular
disc of arbitrary radius.  The output picture will contain the binary, dilated
result, which represents the area swept out by the structuring element as its
centre traverses all the foreground regions in the source image.  You can
select a different shape for the structuring element by specifying one of the
options DIAMOND, SQUARE or OCTAGON.  In all cases, the size of the structuring
element is specified with the RADIUS key.

Exx: DDILATE 1 2 RADIUS 11.2
       dilates the binary image in picture 1 with a circular disc of radius
       11.2 pixel units and outputs the result to picture 2
     DDILATE 1 SQUARE RADIUS 10
       dilates the binary image in picture 1 with 21 by 21 square structuring
       element
     DDILATE OCTAGON RADIUS 20
       dilates the binary image in the current picture with an octagon of
       radius 20
$
The source picture is treated as a binary image: zero values denote background
pixels and non-zero values denote foreground pixels.

The DDILATE command works by thresholding the distance transform of the source
image (see the DT command for more about distance transforms).  The point
about using distance transforms is that they can be obtained with just two or
four passes through the image which means that the time it takes to dilate the
source image does not depend on the size of the structuring element.  By
default, the Euclidean distance transform is evaluated, which means that the
source image can be dilated with an exact circular disc of arbitrary radius.

In fact, the DDILATE command is exactly equivalent to using the commands DT
and THRESHOLD in turn:

    DDILATE <shape> RADIUS r  =>  DT <shape> BG; THRESHOLD LE r

    where <shape> = option DIAMOND, SQUARE, OCTAGON or CIRCLE (default)

However, the DDILATE command is faster and easier to use.

When calculating the distance transform, the DDILATE command may have to open
a temporary picture (see the DT command for details).

The DDILATE command will fault any source picture which has a zero range.  On
successful completion, the range of the final result is stored in the output
picture label.

See also: ddilate.syntax dt threshold
$add ddilate.syntax
Keys:
  [FROM]         source picure [SELECT]
  [TO]           destination picture [FROM]
  RADIUS         size of structuring element

Options:
  DIAMOND | SQUARE | OCTAGON | CIRCLE
                 shape of structuring element [CIRCLE]

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add deassign.command deassign free release detach close
You can DEASSIGN a device that you have finished with, releasing the
file/display for other users and/or freeing a 'device control block' if
you have exhausted these; an option allows you also to delete disc files
entirely.

Exx: DEASSIGN
       deassigns the current device CD
     DEASSIGN DEVICE FS
       deassigns device FS (the display)
     DEASSIGN DISPLAY
       deassigns the current display device
     DEASSIGN DELETE
       deassigns the current device CD and deletes the file

Any data buffered for the device is of course output to the device before it
is deassigned; if you are running interactively, (including library programs
that have been invoked interactively), confirmation is requested from the
terminal before a file is deleted, unless the device is a scratch workspace
in which case the device is deleted regardless.
$
You can deassign program and help libraries too; you may not however deassign
a program library on which a program that is currently active is stored!
You can not use the DELETE option on a device that is assigned WP.
Confirmation is given on the terminal that the device has been deassigned
or deleted.

See also: deassign.syntax, assign
$add deassign.syntax
Key:
  DEVICE         device to be deassigned [CD]

Option:
  DELETE         if disc device, delete device after deassigning
  DISPLAY        deassign the current display device
  VERIFY         confirm deassignment on the console [YES]

Since the variable DISPLAY is invariably set in Semper session, the 'option'
DISPLAY is in fact handled by testing the value of the assumed key $1.

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add delete.command delete
You use DELETE to delete pictures you no longer want, releasing space for
subsequent use, and to delete programs from program libraries.  Use WP to
protect any pictures you would be sorry to delete (or alter) accidentally.  To
wipe an entire picture disc device, use REINITIALISE.

Exx: DELETE
       deletes the current picture
     DELETE 100,199
       deletes any pictures in the range 100 to 199
     DELETE PROGRAM 'COMBINE'
       deletes program COMBINE from the program library/ies

To delete luts, use LUT DELETE; to delete partitions, use PARTITION DELETE;
to delete entire disc files, use DEASSIGN DELETE.
$
DELETE works in two modes, picture mode (in default) and program mode (if you
use the key PROGRAM).  In picture mode, you can delete one or a range of
pictures within a single device (DELETE 2:1,4:999 etc. does not work);  you
cannot of course delete pictures that are marked WP.  Space occupied by
deleted pictures is released at once, but you may find it necessary
occasionally to COMPRESS the device to re-group badly fragmented free space.

In program mode, the single program named is deleted from whichever program
library is found to contain it; if programs with the same name are found in
more than one library, the copy deleted is the same as the copy which would be
used by a LIBRARY command (i.e. whichever is first in the current search
order).  You cannot delete a program that is currently active.  Space occupied
by deleted programs is not in fact released until you COMPRESS the device.
The message confirming the deletion of a program can be suppressed with the
NOVERIFY option.

Deleting a display picture alters nothing physical, it merely resets Semper
records of partition usage.

If for any reason a picture label becomes corrupted, e.g. overwritten, Semper
becomes unable to do anything further with the picture, reporting a 'malformed
label' whenever you refer to it.  You can at least release the disc space
involved in such cases by using the option MALFORMED, e.g. DELETE 50
MALFORMED.

See also: delete.syntax
$add delete.syntax
Keys:
  [(2)]          picture to be deleted (first,last if range) [SELECT,SELECT]
  PROGRAM text   program to be deleted [none; deletes picture(s)]

Option:
  MALFORMED      delete picture even if label corrupted
  VERIFY         confirm deletion of program [YES]

The [(2)] and PROGRAM keys are mutually exclusive alternatives.
See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add derode.command derode erode
You use the DERODE command to erode a binary source image with a circular disc
of arbitrary radius.  The output picture will contain the binary, eroded
result, which represents the area swept out by the centre of the structuring
element whilst the structuring element is contained entirely within the
foreground regions of the source image.  You can select a different shape for
the structuring element by specifying one of the options DIAMOND, SQUARE or
OCTAGON.  In all cases, the size of the structuring element is specified with
the RADIUS key.

Exx: DERODE 1 2 RADIUS 11.2
       erodes the binary image in picture 1 with a circular disc of radius
       11.2 pixel units and outputs the result to picture 2
     DERODE 1 SQUARE RADIUS 10
       erodes the binary image in picture 1 with 21 by 21 square structuring
       element
     DERODE OCTAGON RADIUS 20
       erodes the binary image in the current picture with an octagon of
       radius 20
$
The source picture is treated as a binary image: zero values denote background
pixels and non-zero values denote foreground pixels.

The DERODE command works by thresholding the distance transform of the source
image (see the DT command for more about distance transforms).  The point
about using distance transforms is that they can be obtained with just two
or four passes through the image which means that the time it takes to erode
the source image does not depend on the size of the structuring element.  By
default, the Euclidean distance transform is evaluated, which means that the
source image can be eroded with an exact circular disc of arbitrary radius.

In fact, the DERODE command is exactly equivalent to using the commands DT and
THRESHOLD in turn:

    DERODE <shape> RADIUS r  =>  DT <shape> FG; THRESHOLD GT r

    where <shape> = option DIAMOND, SQUARE, OCTAGON or CIRCLE (default)

However, the DERODE command is faster and easier to use.

When calculating the distance transform, the DERODE command may have to open a
temporary picture (see the DT command for details).

The DERODE command will fault any source picture which has a zero range.  On
successful completion, the range of the final result is stored in the output
picture label.

See also: derode.syntax dt threshold
$add derode.syntax
Keys:
  [FROM]         source picure [SELECT]
  [TO]           destination picture [FROM]
  RADIUS         size of structuring element

Options:
  DIAMOND | SQUARE | OCTAGON | CIRCLE
                 shape of structuring element [CIRCLE]

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add destripe.command destripe instrumentation.error correction
The DESTRIPE command destripes a source picture.

Exx: DESTRIPE 1 2 LINES 6
       destripe all bands (layers) of picture 1 using 6 line sensors and only
       correcting by the average value
     DESTRIPE 1 2 LINES 6 MODE
       as above but correct using the standard deviation too
$
The source picture is destriped, either by subtracting the mean value or using
the standard deviation and mean of a reference line.  The LINES key specifies
the number of lines over which destriping is to occur, for example a LANDSAT
image would require LINES 6 because of the way that its sensor is made.  The
LINES key must have a value of at least 2.  If neither the RSD nor the RMEAN
keys are given then the output picture is adjusted by the mean of a reference
line (sensor) thus:

     XNI = XOI - (MI - MR)

where MI is the mean of the current sensor and MR is the mean of the reference
sensor.

If the MODE option is specified, the output picture is corrected thus:

     XNI = (OR / OI)(XOI - MI) + MR

where MI and MR are as before, OI is the standard deviation of the current
sensor and OR is the standard deviation of the reference sensor.

If the RMEAN and RSD keys are specified, their values are used as the
reference values, rather than those from one of the sensors.

If the LAYER key is omitted then all layers of the picture will be destriped
and the output picture will contain the same number of layers as the source
picture.

See also: destripe.syntax
$add destripe.syntax
Keys:
  [FROM]        source picture [SELECT]
  [TO]          output picture [FROM]
  LINES         number of lines over which destriping is to occur [none]
  RMEAN         reference mean required for all sensors [derived from source
                picture]
  RSD           reference standard deviation required for all sensors [derived
                from source picture]
  LAYER         layer of picture to be destriped [all layers]

Options:
  MODE          destriping should take account of the standard deviation
                of the sensors, not just the mean

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add device.command device
The command DEVICE  defines  the  devices  with  which    display
interaction  will  take place.

Examples:
     DEVICE QUERY 2
     determines  the  size of the framestore and  the  number  of
     colours that it supports.
$
Devices are referred to by number.  The device numbers  currently
defined are:

       Device 0 : All devices
       Device 1 : The display on the host
       Device 2 : The framestore

If  the Semper variable CDI is not changed, the default  location
is   the display  attached  to the host. If panels, etc.  are  to
appear on the framestore the variable CDI should be set to 2.  If
DEVICE  ACTIVE is not used, element selection is allowed on  both
displays.   If  the  framestore  is  used  to   display   panels,
there  may be hardware restrictions on the colours available  for
display.

The QUERY key allows a program to find out about its environment,
returning  the  size  of the display and the  number  of  colours
supported by the display. This is useful when a program starts to
define  a user interface, so that it can position and colour  all
the objects correctly.

The  SAVE/RESTORE keys provide an alternative method  of  storing
the  cursor  position  to the MOUSE command (when using the QUERY
option  and POSITION key). The DEVICE SAVE/RESTORE keys have  the
advantage   that  calls  may  be  stacked,   easing   programming
requirements.

The  REFRESH key re-draws the screen, after clearing it. This  is
useful after UIF GO has been issued as it removes all the  Semper
start up messages.

See also: device.syntax, mouse
$add device.syntax
Keys:
  ACTIVE         Element selection will only be allowed on the given device.
  QUERY          Sets the size of the given device into UIX and UIY in device
                 dependent coordinates, and the number of colours supported
                 into NCO.
  REFRESH        Re-draws the currently defined user interface on the given
                 device.
  RESTORE        Restores the previously SAVEd cursor position of the given
                 device.
  SAVE           Saves the current cursor position of the given device.
                 Positions are stacked, so several SAVE/RESTORE calls may be
                 used.

Variables set:
  UIX,UIY        Set by DEVICE QUERY to the size of the requested device.
  NCO            Set by DEVICE QUERY to the number of colours on the display.

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add diagnostic.command diagnostic output stream warning error messages
You use the DIAGNOSTIC command if you want to write messages to the diagnostic
output stream.  It has exactly the same syntax as the TYPE command.

Ex: DIAGNOSTIC 'Unexpected error ',x,' reading data'

See also: log, type, textstring
$add differentiate.command differentiate derivative gradient
You can use DIFFERENTIATE to calculate picture derivatives in any direction,
using a three-point local operator on Images, with special treatment of
Fourier transforms.

Exx: DIFFERENTIATE 1 TO 2
       differentiates 1 w.r.t. X, replacing each pixel by the difference
       between its right-hand neighbour and it.
     XWIRES LINE; MIN=-40 MAX=40; DIFF TO DISPLAY ANGLE THETA
       differentiates the display in a direction marked with the cursor
$
ANGLE, which establishes the differentiation direction, is measured in radians
anticlockwise from the positive X axis; zero is assumed if ANGLE is not set or
if the source is 1-D.

For most picture classes, a 3-point local convolution operator of the form
                  c.p(x+1,y) + s.p(x,y+1) - (c+s).p(x,y)
in which s=sin(ANGLE) and c=cos(ANGLE); for Fourier pictures however, the
source is multiplied instead by phase shifting factor exp(2.pi.i.k), with k
measured in the appropriate direction, which is equivalent to differentiating
the corresponding Image, but rather differently approximated.

                                             Multi-layer pictures: faulted
                                            Forms used internally: fp,complex

See also: differentiate.syntax
$add differentiate.syntax
Keys:
  [FROM]         source picture [SELECT]
  [TO]           output picture [FROM]
  ANGLE          differentiation direction in radians, anticlockwise from
                 positive X axis [0]

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add dilate.command dilate morphology
You use DILATE for various morphological (shape) manipulations on binary
pictures, treating zero pixels as background, and non-zero pixels (normally 1)
as connected objects.  Several modes are available, both adding pixels at
object borders depending on the geometry of 3x3 pixel neighbourhoods.

Exx: DILATE DISPLAY
       adds a one-pixel wide border to all objects (by setting clear pixels
       which have a set neighbour)
     DILATE 50 TO 51 TIMES 3
       adds a three-pixel border to all objects (repeats DILATE 3 times)

A zero value for TIMES causes indefinite repetition until the picture
stabilises (or until you 'abandon' the operation); this is faster than
repeated use of DILATE in a FOR loop, as the command is able to omit in later
passes picture rows that have already stabilised.

Options/keys select various more selective modes of dilation, described
separately; see also ERODE.WITH (sic).  The sequence ERODE;DILATE is a common
way of smoothing object borders.

                                        Form used internally: integer (binary)

See also: dilate.neighbours, dilate.separately, dilate.syntax
$add dilate.syntax
Keys:
  [FROM]       source picture [SELECT]
  [TO]         output picture [FROM]
  TIMES        force repeat count for dilation process [0 if SEPARATELY,
               1 otherwise]
  NEIGHBOURS   dilate points with given minimum number of clear neighbours [1]
  WITH         picture containing user-supplied map function(s)

Options:
  SEPARATELY   dilate objects preserving separation (via 4-connected skeleton
               background)

WITH and SEPARATELY are mutually incompatible alternatives.

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add dilate.neighbours dilate
DILATE NEIGHBOURS 4
  adds border pixels at sites which have at least 4 set neighbours (which
  fills point and line holes in objects without affecting their 'real' edge.
DILATE NEIGHBOURS 8
  fills isolated point holes only

In default, DILATE sets pixels with at least one set neighbour.  You can
change this minimum number via the key NEIGHBOURS however, and perform more
and more selective dilation as you increase it towards the maximum of 8.  The
default mode of DILATE is in fact DILATE NEIGHBOURS 1.  The command is exactly
equivalent to ERODE NEIGHBOURS .. with object and background interchanged, and
you may find the further examples given by HELP ERODE.NEIGHBOURS helpful
$add dilate.separately dilate
DILATE SEPARATELY
  dilates objects but preserving (4-)connectivity of background, so that
  objects and object points initially separated remain so

        111111..111111                        1111111.111111
        111111...11111                        1111111.111111
        111111...11111   dilate separately    1111111..11111
        11111....11111  ------------------->  1111111.111111
        11111...111111                        111111..111111
        11111...111111                        111111.1111111
        1111....111111                        111111.1111111

Objects are dilated in sequences of four passes, in which pixels are removed,
without affecting the 4-connectivity of the backround, from the top, the
bottom, the left and the right in turn; in default the sequence is repeated
until the pictures stabilises, but you can limit the number of sequences if
you wish via the key TIMES.
$add directory.command directory freespace space
DIRECTORY prints directory information about a picture disc device or a
program library, summarising the used and free space.

Exx: DIRECTORY
       prints information about the current device CD
     DIRECTORY DEVICE 4
       prints information about device 4

For a picture disc, the information printed includes the number of directory
slots used and free, the amount of disc space used and free, the size of the
largest contiguous segment free, and the first unused picture number.

For a program library, the information printed summarises directory slot,
directory space and disc space usage under the three headings 'active',
'deleted'  and 'free'; COMPRESS can be used to make deleted space free.

See also: directory.syntax
$add directory.syntax
Key:
  DEVICE         device about which information is required [CD]

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add display.command display
You use DISPLAY to display pictures; the command includes several features
beyond what is achieved by COPY .. TO DISPLAY: automatic scaling, contrast
reversal, lettering, borders, subregion display and magnification, 1-D graphs
and histograms, and character form displays on the console or log output
stream.

Exx: DISPLAY NEGATED
       displays the current picture with reversed contrast
     XWIRES REGION; DISPLAY DIS @REGION TIMES 5 TO DIS:2
       enlarges five times on to DIS:2 a region of the current display
       indicated with the cursor
     DISPLAY LAYER 1,1 TYPE WIDTH 60
       displays the first (back) layer on the console, with a width of 60
     EXTRACT 50 51 SIZE 256,1 ANGLE PI/4; DISPLAY
       displays a diagonal line scan from picture 50
     MIN=0 MAX=1E7; DISPLAY PRESET
       displays with the black-white range forced
$
DISPLAY differs from COPY .. TO DISPLAY in the following respects:
1) (multi-layer) subregion facilities, like CUT (though not for Histograms)
2) magnification facilities (including REPEATING), like MAGNIFY
3) automatic grey scaling: the actual range of the data displayed is found
   (estimated if you 'abandon' while Semper is scanning the data); the range
   is returned in MIN,MAX, and used to set display black and white levels; if
   PRESET however, the current values of MIN,MAX are used instead; if NOSCALE,
   unit scaling is applied; and if NEGATED, the black and white levels are
   interchanged
4) outlining of the display (unless you force NOBORDER), and lettering (unless
   NOLETTER) including the picture number, size (in brackets if subregion),
   title and black-white range
5) line graphical display of 1-D pictures (on the display overlay), to same
   lateral scale as 2-D display; also of histograms; use key HEIGHT to force
   graph height (in display pixels) if you want to (TIMES to increase width,
   though only by integer factors)
6) character-form alternative displays (TYPE or LOG) for 2-D, 1-D and
   histogram forms of display
7) - a subtle point! - subregions are displayed as independent pictures like
   any other as far as their coordinate system is concerned, just as if CUT
   instead; but they retain the source picture coordinate system for later
   graphical purposes (XWIRES, MARK etc.)
8) all layers of the source picture are assumed (use LAYER keys to arrange
   otherwise); if more than one layer, the layers are displayed on successive
   frames as usual (for colour viewing, if red, green, blue data is stored in
   first three layers) as are 1-D pictures
9) the partition into which the picture is written may have more frames
   allocated to it than there are output layers, in which case the output
   of picture layers resumes with the first and successive layers until all
   of the frames in the partition have been filled - this facility allows you
   to handle single layer pictures on a full colour framestore with the
   minimum of fuss, simply by creating partitions that are three frames deep

If the MARK key is set, the limits of the source region are marked on the
indicated display picture.
                                         Display marking: source region
                                    Multi-layer pictures: fully supported
                                   Forms used internally: all

See also: display.syntax
$add display.syntax
Keys:
  [FROM]         source picture [SELECT]
  [TO]           output display picture [DISPLAY]
  TIMES          integral magnification factor [1]
  SIZE(3)        dimensions of subregion to be displayed [whole picture]
  POSITION(3)    displacement of subregion position [0,0,0]
  LAYER(2)       range of layers in subregion [all unless SI3/PO3 set]
  HEIGHT         if 1-D picture, height of graph in framestore pixels
                 [lesser of half graph width and half partition height]
  ASPECT         for character form displays, aspect ratio (no. columns/inch
                 divided by no. lines/inch) of character grid [default given
                 by PAGE command]
  WIDTH          for character form displays, the number of characters
                 per line [default given by PAGE command]
  MARK           display to be marked with border indicating source region
                 [none]

Options:
  PRESET         set display black,white levels from MIN,MAX [lowest and
                 highest pixel present used]
  SCALE          when negated (NOSCALE), forces unit intensity scaling [YES]
  NEGATED        interchange display black,white levels [NO]
  REPEATING      repeat pixels when magnifying instead of interpolating [NO]
  LETTER         letter partition top with picture number, title, etc. [YES]
  BORDER         mark picture border [YES]
  LEFT | RIGHT
  BOTTOM | TOP   display subregion abutting indicated picture border
  FAR | NEAR
  TYPE | LOG     picture is output in character form on console or to log
                 output stream [picture is displayed on display device]

Variables used:
  MIN,MAX        if PRESET, pixel range scaled to black,white

Variables set:
  MIN,MAX        unless PRESET, pixel range within picture/region displayed

See SUBREGIONS for more information on subregion keys/options.

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add dopen.command dopen open
You use the DOPEN command to open a binary source image with a circular disc
of arbitrary radius.  The output picture will contain the binary, opened
result, which represents the area swept out by the structuring element whilst
it is contained entirely within the foreground regions of the source image.
You can select a different shape for the structuring element by specifying one
of the options DIAMOND, SQUARE or OCTAGON.  In all cases, the size of the
structuring element is specified with the RADIUS key.

Exx: DOPEN 1 2 RADIUS 11.2
       opens the binary image in picture 1 with a circular disc of radius
       11.2 pixel units and outputs the result to picture 2
     DOPEN 1 SQUARE RADIUS 10
       opens the binary image in picture 1 with 21 by 21 square structuring
       element
     DOPEN OCTAGON RADIUS 20
       opens the binary image in the current picture with an octagon of
       radius 20
$
The source picture is treated as a binary image: zero values denote background
pixels and non-zero values denote foreground pixels.

The DOPEN command works by thresholding the distance transform of the source
image (see the DT command for more about distance transforms).  The point
about using distance transforms is that they can be obtained with just two or
four passes through the image which means that the time it takes to open the
source image does not depend on the size of the structuring element.  By
default, the Euclidean distance transform is evaluated, which means that the
source image can be opened with an exact circular disc of arbitrary radius.

In fact, the DOPEN command is exactly equivalent to using the commands DT and
THRESHOLD in turn:

    DOPEN <shape> RADIUS r  =>  DT <shape> FG; THRESHOLD GT r;
                                DT <shape> BG; THRESHOLD LE r

    where <shape> = option DIAMOND, SQUARE, OCTAGON or CIRCLE (default)

However, the DOPEN command is faster and easier to use.

When calculating the distance transform, the DOPEN command may have to open a
temporary picture (see the DT command for details).

The DOPEN command will fault any source picture which has a zero range.  On
successful completion, the range of the final result is stored in the output
picture label.

See also: dopen.syntax dt threshold
$add dopen.syntax
Keys:
  [FROM]         source picure [SELECT]
  [TO]           destination picture [FROM]
  RADIUS         size of structuring element

Options:
  DIAMOND | SQUARE | OCTAGON | CIRCLE
                 shape of structuring element [CIRCLE]

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add drag.command drag cursor input line arc circle region curve
You use DRAG to position a variety of graphical objects on the display.
Graphical objects have an origin or anchor position whose initial position is
determined by the POSITION key.  The final position of the origin is returned
in the variables X and Y.  The following graphical objects are supported:
lines, arcs, circles, all types of sub-regions and open or closed curves.

Exx: DRAG LINE POSITION 20,30 TO 100,170
        drags line with initial start point at (20,30) and end point at
        (100,170), returning the final start position in variables X and Y
     DRAG PARTITION DIS:2 CIRCLE RADIUS 50
        drags circle with radius 50 from centre of display partition 2
     DRAG DIS:2 SIZE 200 TOP LEFT
        drags 200 by 200 sub-region initially positioned at the top left of
        display picture DIS:2
     DRAG FRAME CURVE WITH 2:90 @XY CLOSED TO 2:91
        drags the closed curve specified by picture 2:90 with the initial
        position of the curve's origin at (X,Y), and outputs the shifted
        result as another position list in picture 2:91
$
The DRAG command supports three sets of display coordinates: picture,
partition or frame coordinates.  You select which one to use by specifying one
of the options PICTURE, PARTITION or FRAME.  The PICTURE option is assumed if
no option is given.  You can also specify which display picture, partition or
frame to use.  For display pictures and partitions the DISPLAY variable
supplies the default picture or partition number.  For frame coordinates, the
CFRAME variable supplies the default frame number.

On complex display pictures, where the real and imaginary parts of the image
are displayed side by side, dragging normally takes place with respect to the
real part of the image.  If, however, you specify the option IM, dragging will
be carried out with respect to the imaginary part of the image.  By default,
the final position of the dragged object is verified by marking it on both the
real and imaginary parts.  If you specify the option RE or IM, verification is
restricted to just the real or imaginary part.

The graphical object to be dragged first appears exactly as if the MARK
command had been used to draw it using the same keys and options as specified
in the DRAG command (with the one exception of the POSITION key specifying an
offset for a curve, a facility which the MARK command does not support).  The
POSITION key defines the initial position of the object's origin or anchor
position, except for justified sub-regions (options LEFT/RIGHT and
TOP/BOTTOM), where the POSITION key defines an offset from the initial
justified position.  The anchor position for each type of graphical object is
as follows:

    Line               Start point of line
    Arc or circle      Centre point of arc or circle
    Sub-region         Centre of sub-region
    Curve              Origin of curve

The type of graphical object is determined by the presence of the keys WITH
(open or closed curve), TO (line), RADIUS (arc or circle) and SIZE
(sub-region), in that order.  The options LINE, ARC, CIRCLE and CURVE are
ignored and have only been included to allow you to improve the readability of
the DRAG command.  Note that the WITH key takes precedence over the TO key
because the TO key may be used in conjunction with the WITH key to specify an
output picture number.

For curves, the option OPEN or CLOSED may also be specified.  If the option
CLOSED is specified, an line is drawn from the end of the curve to the start
point to ensure that the curve always appears closed.  The keys SAMPLING and
ANGLE may be used to specify scaled and angled sub-regions.  If the option UV
is given in conjunction with the SIZE key, this specifies a skewed sub-region
where the sampling lattice vectors are obtained from the variables U,U2 and
V,V2.

Once the object appears on the display you should be able to move it around
interactively by moving the mouse or by pressing any of the cursor keys.  When
you have finally positioned the object, press a mouse button or a key on the
keyboard to terminated the DRAG command.  The final position of the object's
anchor point will be returned in variables X and Y.  The final position of the
end point of a line is also returned in variables XN and YN.  When dragging
curves, you have the option to output a new position list which describes the
curve in its final position.  You specify the picture number for the position
list with the TO key.  By default, the object is redrawn in its final
position.  You can prevent this from happening by specifying the option
NOVERIFY.

Whilst the DRAG command allows you to drag literally any shape of object (with
a position list), the speed of response of the dragging process will depend on
the complexity of the object (number, length and orientation of line
segments).  A reasonable approximation of an arc, circle or curve can be
obtained by specifying the TOLERANCE key.  This reduces an object to the
smallest set of line segments which departs from the original object by no
more than the distance given by the TOLERANCE key.  By default, a tolerance
value of 1.0 is assumed.

The DRAG command is designed to be compatible with other commands such as
XWIRES, SKETCH and MARK, which operate with the different types of graphical
objects supported here.  The key, option and variable names used are also
compatible with the named macros @XY, @LINE, @ARC, @CIRCLE and @REGION.  For
example, you could specify a circular arc on the current display frame with
the XWIRES command and immediately drag it with the DRAG command in the
following way:

    XWIRES FRAME ARC NOVERIFY; DRAG FRAME @ARC

As a final example, you could use the SKETCH and DRAG commands to obtain the
distance between two similar objects in an image like this:

    DISPLAY 3:10                    Display source image

    SKETCH TO 3:11 CLOSED           Sketch around first object

    DRAG WITH 3:11                  Drag outline and align with second object

    TYPE 'Object separation = ',ROOT(X^2+Y^2)

See also: drag.syntax, xwires, sketch, mark
$add drag.syntax
Keys:
  []            picture/partition/frame on which to drag object [DISPLAY if
                picture or partition; CFRAME if frame]
  POSITION(2)   initial position of anchor point [0,0]
                if WITH set,   curve origin
                if TO set,     start point of line
                if RADIUS set, circle/arc centre
                if SIZE set,   sub-region centre position (or sub-region
                               offset, if options LEFT/RIGHT, TOP/BOTTOM used)
  WITH          drag open/closed curve defined in given Plist picture [none]
  TO(2)         if WITH set, TO specifies output picture number for Plist to
                             contain final instance of dragged curve [none]
                otherwise,   drag line with given end point [none]
  RADIUS        drag circle/arc with given radius [none]
                if ANGLE set, arc
                otherwise,    circle
  SIZE(2)       drag sub-region with given dimensions [none]
  ANGLE(2)      if RADIUS set, start/end angles for anti-clockwise arc [none]
                if SIZE set,   ANGLE specifies orientation angle of sub-region
  SAMPLING      sampling (magnification) factor for sub-region [1]
  TOLERANCE     arc-to-chord tolerance for arcs, circles and curves [1]

Options:
  PICTURE | PARTITION | FRAME   use indicated coordinate system [PICTURE]
  [ LINE | CIRCLE | ARC | REGION | CURVE ]  drag specified object [do nothing]
  OPEN | CLOSED  if CLOSED set, curve displayed with line joining first and
                                last point in Plist [CLOSED if Plist contains
                                closed curve, otherwise, OPEN]
  LEFT | RIGHT   if SIZE set, sub-region justified on indicated border
  BOTTOM | TOP
  UV             sub-region has sampling lattice defined by variables U,U2
                 and V,V2
  RE | IM        drag object with respect to real or imaginary part of complex
                 display picture [drag object with respect to real part]
                 if VERIFY set, mark final dragged position on real or
                 imaginary part of complex display picture [mark both parts]
  VIEW           switch view to make display region visible [NO]
  VERIFY         leave object displayed in final dragged position [YES]

Variables used:
  U,U2,V,V2      if UV set, sampling lattice vectors for skewed sub-region

Variables set:
  X,Y            final position of anchor point
  XN,YN          final position of end point of line

The options LINE, CIRCLE, ARC, REGION and CURVE may be omitted.  They can be
included in the DRAG command for better readability.

See SUBREGIONS for more details of subregion keys/options.

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add dt.command dt distance transform euclidean erode dilate open close
You use the DT command to find the shortest distance between each foreground
pixel and the nearest background pixel.  With the BG option, the same can be
done for background pixels with respect to foreground regions.  The option
DIAMOND, SQUARE or OCTAGON may be specified to obtain distances based on
4/8-connected metrics in less time than for the exact Euclidean distance.

Exx: DT 1 2
       finds the shortest distance between foreground pixels and the nearest
       background pixel in picture 1 and outputs the result to picture 2
     DT 1 2 SQUARE
       finds the shortest 8-connected distance between foreground pixels and
       the nearest background pixel in picture 1
     DT 1 2 OCTAGON BG
       finds the shortest octagonal distance for background pixels with
       respect to forground regions in picture 1
$
The source picture is treated as a binary image: zero values denote background
pixels and non-zero values denote foreground pixels.

By default the DT command calculates the Euclidean distance transform for
foreground or background regions.  The distances for most pixels are the exact
diagonal distances to the nearest background or foreground pixel.  In a few
very rare cases, the algorithm used may pick the wrong pixel as the nearest
pixel, but the distance to this pixel is guaranteed not to differ from the
correct value by more than 0.1 pixel unit.

When calculating Euclidean distances, the DT command has to open a temporary,
two layer, integer form picture with the same X and Y dimensions as the source
picture.  The final result is output in floating-point form.

The BG option may be specified to cause the distance transform to be evaluated
for background pixels.  In this case, all foreground pixels will return a zero
result.  The options FG and BG are mutually exclusive.

By default, the distance transform is calculated as if regions touching the
edges of the image continue to infinity.  This corresponds to the option OPEN.
With the CLOSED option, regions can be closed off round the edges of the
image, with the result that all distance contours are closed.

The DT command will fault any source picture which has a zero range.  On
successful completion, the range of the final result is stored in the output
picture label.

In addition to Euclidean distances, the DT command also provides options to
evaluate the distance transform using more simple metrics based on 4 and
8-connected distances:

(1) DIAMOND - 4-connected or "city-block" distance.  This distance is
              always greater than the true Euclidean distance.

(2) SQUARE  - 8-connected distance.  This distance is always less than the
              true Euclidean distance.

(3) OCTAGON - alternating use is made of 4 and 8-connected distances to
              provide a closer approximation to the true Euclidean distance.

All of these distance transforms are 2 to 3 times faster to evaluate than the
Euclidean distance transform.  They do not require a temporary picture to be
opened unless the output picture is a display picture, in which case a
temporary, single layer, integer form picture is opened.  All the distance
values will be exact integers.

The options DIAMOND, SQUARE, OCTAGON and CIRCLE (default) denote the shape of
the result when applied to a single background pixel, as can clearly be seen
in the examples below if you ignore all values greater than 4 (say)

        DT DIAMOND                 DT SQUARE                  DT OCTAGON

    8 7 6 5 4 5 6 7 8          4 4 4 4 4 4 4 4 4          6 5 4 4 4 4 4 5 6
    7 6 5 4 3 4 5 6 7          4 3 3 3 3 3 3 3 4          5 4 4 3 3 3 4 4 5
    6 5 4 3 2 3 4 5 6          4 3 2 2 2 2 2 3 4          4 4 3 2 2 2 3 4 4
    5 4 3 2 1 2 3 4 5          4 3 2 1 1 1 2 3 4          4 3 2 2 1 2 2 3 4
    4 3 2 1 0 1 2 3 4          4 3 2 1 0 1 2 3 4          4 3 2 1 0 1 2 3 4
    5 4 3 2 1 2 3 4 5          4 3 2 1 1 1 2 3 4          4 3 2 2 1 2 2 3 4
    6 5 4 3 2 3 4 5 6          4 3 2 2 2 2 2 3 4          4 4 3 2 2 2 3 4 4
    7 6 5 4 3 4 5 6 7          4 3 3 3 3 3 3 3 4          5 4 4 3 3 3 4 4 5
    8 7 6 5 4 5 6 7 8          4 4 4 4 4 4 4 4 4          6 5 4 4 4 4 4 5 6

    . . . . 4 . . . .          4 4 4 4 4 4 4 4 4          . . 4 4 4 4 4 . .
    . . . 4 3 4 . . .          4 3 3 3 3 3 3 3 4          . 4 4 3 3 3 4 4 .
    . . 4 3 2 3 4 . .          4 3 2 2 2 2 2 3 4          4 4 3 2 2 2 3 4 4
    . 4 3 2 1 2 3 4 .          4 3 2 1 1 1 2 3 4          4 3 2 2 1 2 2 3 4
    4 3 2 1 0 1 2 3 4          4 3 2 1 0 1 2 3 4          4 3 2 1 0 1 2 3 4
    . 4 3 2 1 2 3 4 .          4 3 2 1 1 1 2 3 4          4 3 2 2 1 2 2 3 4
    . . 4 3 2 3 4 . .          4 3 2 2 2 2 2 3 4          4 4 3 2 2 2 3 4 4
    . . . 4 3 4 . . .          4 3 3 3 3 3 3 3 4          . 4 4 3 3 3 4 4 .
    . . . . 4 . . . .          4 4 4 4 4 4 4 4 4          . . 4 4 4 4 4 . .

                                   DT CIRCLE

             5.657 5.000 4.472 4.123 4.000 4.123 4.472 5.000 5.567
             5.000 4.243 3.606 3.162 3.000 3.162 3.606 4.243 5.000
             4.472 3.606 2.828 2.236 2.000 2.236 2.828 3.606 4.472
             4.123 3.162 2.236 1.414 1.000 1.414 2.236 3.162 4.123
             4.000 3.000 2.000 1.000 0.000 1.000 2.000 3.000 4.000
             4.123 3.162 2.236 1.414 1.000 1.414 2.236 3.162 4.123
             4.472 3.606 2.828 2.236 2.000 2.236 2.828 3.606 4.472
             5.000 4.243 3.606 3.162 3.000 3.162 3.606 4.243 5.000
             5.657 5.000 4.472 4.123 4.000 4.123 4.472 5.000 5.567

             ..... ..... ..... ..... 4.000 ..... ..... ..... .....
             ..... ..... 3.606 3.162 3.000 3.162 3.606 ..... .....
             ..... 3.606 2.828 2.236 2.000 2.236 2.828 3.606 .....
             ..... 3.162 2.236 1.414 1.000 1.414 2.236 3.162 .....
             4.000 3.000 2.000 1.000 0.000 1.000 2.000 3.000 4.000
             ..... 3.162 2.236 1.414 1.000 1.414 2.236 3.162 .....
             ..... 3.606 2.828 2.236 2.000 2.236 2.828 3.606 .....
             ..... ..... 3.606 3.162 3.000 3.162 3.606 ..... .....
             ..... ..... ..... ..... 4.000 ..... ..... ..... .....

Using option SQUARE generates a result that is equivalent to applying the
command ERODE or DILATE as many times as it takes to empty or fill the source
image.  Thresholding the result obtained with the FG option, to retain all
pixels greater than N gives the result for N erosions.  Thresholding the
result obtained with the BG option, to retain all pixels less than or equal to
N gives the result for N dilations.  Thresholding the Euclidean distance
transform makes it possible to erode or dilate objects by non-integer
distances.

In fact, thresholding the distance transform is equivalent to eroding or
dilating with a structuring element whose shape corresponds to the option
specified for the distance transform and whose radius is the threshold value
used.  Combining erosion with dilation (or vice versa) allows you to obtain
the opening and closing of a binary image with the same structuring element.
The commands DERODE, DDILATE, DOPEN and DCLOSE can be used to do this directly
and in less time than it would take with the DT and THRESHOLD commands.

See also: dt.syntax derode ddilate dopen dclose erode dilate threshold
$add dt.syntax
Keys:
  [FROM]         source picure [SELECT]
  [TO]           destination picture [FROM]

Options:
  FG | BG        evaluate distance transform for foreground/background pixels
                 with respect to background/foreground regions [FG]
  CIRCLE | DIAMOND | SQUARE | OCTAGON
                 evaluate true Euclidean/4-connected/8-connected/octagonal
                 distance transform [CIRCLE]
  OPEN | CLOSED  treat edges of image as being open or closed [OPEN]

If the CIRCLE option is selected, a temporary, two-layer, integer form
picture will be opened.  If the CIRCLE option is not selected and the output
picture is a display picture, a temporary, single layer, integer form picture
will be opened.

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add echo.command echo reflection verify verification
You use the ECHO command to control the output of text from Semper.  There are
six different classes of output text, each one of which is directed to a
separate logical output stream (console, diagnostic, log, monitor, command and
input).  The ECHO command specifies where output to each these streams will
end up.  This could be any of the following: standard output stream (the
terminal), standard error stream and one or more log files.  Log files are
opened with the ASSIGN FILE command and are subsequently referred to by their
device number.  All output to a log file is turned off when the file is
assigned.  By default, console, diagnostic and monitor output is sent to the
standard output stream.

Exx: ECHO COMMANDS TERMINAL; LIBRARY LATTICE
       causes the commands in program LATTICE to be echoed to the standard
       output stream (the TERMINAL option is a synonym for STANDARD OUTPUT)
     ASSIGN FILE NAME 'ERRORS'; ECHO DIAGNOSTICS DEVICE N
       opens the file ERRORS.LOG to log all error messages
     ASSIGN FILE NAME 'RESULTS'
     ECHO CONSOLE DEVICE N; LIBRARY MEASURE; ECHO NONE DEVICE N
     DEASSIGN DEVICE N
       captures the results listed by the program MEASURE in the file called
       RESULTS.LOG
$
Text is sent to one of six logical output streams according to the nature of
the information to be output:

     Console    - normal output text, results, etc.
     Diagnostic - unsolicited output - error and warning messages
     Log        - results, etc. that would not normally be output to the
                  standard output stream
     Monitor    - diagnostic information for debugging purposes
     Command    - command reflection
     Input      - non-command input, e.g. response to ASK, etc.

The ECHO command specifies which of these is to be 'echoed' to the standard
output stream (STANDARD OUTPUT or TERMINAL options), or to the standard error
stream (STANDARD ERROR option) or to an output log file (DEVICE key).  The
STANDARD OUTPUT (or TERMINAL) option, the STANDARD ERROR option and the DEVICE
key may not be used in the same command.  When used, the DEVICE key must point
to a device that is a log file (see assign.file).

You may then specify which logical output streams should be turned on or off
by means of a suitable combination of the options CONSOLE, DIAGNOSTIC, LOG,
MONITOR, COMMAND and INPUT, together with the options ALL or NONE.

Echoing is turned on by specifying the appropriate option, and turned off by
prefixing the option with NO, e.g. NOCONSOLE NOLOG turns off echoing of
console and log.  The blanket options ALL or NONE turn all echoing on or off,
and can be combined with the specific options, e.g. ALL NOLOG echoes
everything except log output, NONE CONSOLE echoes only console output.

Each use of the ECHO command modifies the current state of affairs, i.e.
echoing of output streams not mentioned is not altered.

Use the command SHOW ECHO to list the current echo settings for the standard
output and standard error streams and for any assigned log files.

Note that the ECHO command itself does not echo when echoing of commands is
enabled.

See also: echo.syntax
$add echo.syntax
Options:
  STANDARD OUTPUT  change echo settings for standard output stream
  TERMINAL         synonym for STANDARD OUTPUT
  STANDARD ERROR   change echo settings for standard error stream
  [NO]CONSOLE      turn console echo on/off
  [NO]DIAGNOSTIC   turn diagnostic echo on/off
  [NO]LOG          turn log echo on/off
  [NO]MONITOR      turn monitor echo on/off
  [NO]COMMAND      turn command echo on/off
  [NO]INPUT        turn non-command input echo on/off
  ALL | NONE       turn all echoing on/off

Keys:
  DEVICE           change echo settings for assigned log file

Restrictions:
  STANDARD OUTPUT (or TERMINAL) option, STANDARD ERROR option and DEVICE key
  are mutually exclusive.
$add edge.command edge roberts gradient
You use EDGE to apply one of two forms of edge-detecting operator: a 3-point
gradient magnitude, or the 4-point Roberts 'larger absolute diagonal
difference'.

Exx: EDGE 1 TO 2
       puts the edge magnitude of picture 1 in 2
     EDGE ROBERTS
       applies the Roberts edge operator to the current picture
$
Thresholding (e.g. CALCULATE :SEL>10 ) may be useful for making yes/no edge
decisions on the basis of the output of EDGE.

The default operator is the magnitude of the gradient vector estimated via
          |( p(x+1,y)-p(x) , p(x,y+1)-p(x) )|
while the Roberts operator is
          max{ |p(x+1,y+1)-p(x,y)| , |p(x+1,y)-p(x,y+1)| }
In either case, the top row and right hand column are simply set to zero.

                          Multi-layer pictures: layers processed independently
                          Form used internally: fp

See also: edge.syntax
$add edge.syntax
Keys:
  [FROM]         source picture [SELECT]
  [TO]           output picture [FROM]

Option:
  ROBERTS        obtain 4 point Roberts operator output [gradient magnitude]

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add edit.command edit
You can NOT edit programs inside Semper sessions at present; the best you
can do is something like the following:
   LIST PROGRAM 'progname' NAME 'filename'          [write program to file
   STOP  [or, in some installations, SPAWN]         [leave Semper
   ..edit the file..                                [with any editor you like
   SEMPER  [or command to cancel effect of SPAWN]   [restart Semper
   ADD NAME 'filename'                              [reload the program

You can however use EDIT inside Semper sessions, to alter the text of an
existing numbered macro, or to create a new one.

Ex: EDIT 4                                 [ Enter editor
    Editor ready                           [
      For N=N1,N2; Examine N; Display A2   [ Initial macro text
     :>>>>>>>>>>>>>>>>####>>>>>>>####      [ move pointer / erase chars
    ..N=N1,N2; Exa N; Dis A2               [ .. indicates omitted text
                        :e/A2/N/ c/; Wait  [ change A2 to N; add new text
    ..N=N1,N2; Exa N; Dis N; Wait          [
                        :W                 [ write output and stop
    Editing complete
$
If you give an output only, e.g. EDIT TO 901, you enter the editor with no
existing text, and can create a new macro.  There is no default source picture
number accordingly.

EDIT invokes a sub-system with its own (simple) command decoder, which retains
control until you type W or Q - the latter being an 'abandon' exit that leaves
the original text unchanged.  You see a 'window' of the macro text verified,
with '..' at the beginning or end in place of text you can't see, and a colon
(:) marking a current position; use L to List the entire text if you need to,
and ? for a list of editing directives.

Editing directives:
   ?  Help - type this list
   N  move to Next command (0N moves to end of macro)
   P  move to Previous command (0P moves to start of macro)
   D  Delete (rest of) command
   L  List full macro text
   W  Write text to output and quit
   Q  Quit without output (i.e. abandon editing)

   F/s/      Find (move to next occurrence of) string s
   S         repeat last Search (F command)
   C/s/      Continue macro with string s (i.e. append to end)
   A/s1/s2/  After string s1 insert string s2
   B/s1/s2/  Before string s1 insert string s2
   E/s1/s2/  Exchange: change s1 to s2
   X         repeat last eXchange (A,B,E command)
   G/s1/s2/  Perform exchange Globally (throughout macro text)

   >  Move one char right
   #  Delete next char
   _  Replace char by space
   %  Change char to upper case
   $  Change char to lower case

A,B,E operate from the prompt to the end of the visible window, without moving
this; all string matching is case-independent; empty strings match at the
current position (e.g. B//text/ inserts at the current position).

Directives can be entered several to a line if desired, as in the example
above, with no special separator and in upper or lower case.  Directives
involving strings use the character immediately following the directive itself
as the delimiting character (/ is used in the example), even if this is space.
A repeat count may preceded individual directives or sequences enclosed in
brackets, e.g. 3N 12(F/JUMP/5>3$); a zero count gives indefinite repetition.

                                                 Form used internally: integer

See also: edit.syntax
$add edit.syntax
Keys:
  [FROM]         source Macro 'picture' [none]
  [TO]           output Macro 'picture' [FROM if set; otherwise none]

Options:
  VERIFY         confirm completion of editing session on the console [YES]

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add erase.command erase clear image overlay
You use ERASE to erase a display 'manually' if you want to, to erase an image
or overlay memory without erasing the other, or to erase a display subregion.

Exx: ERASE
       erases the current display picture, irrespective of the value of
       variable ERASE
     XWIRES DIS:3 REGION; ERASE @REGION
       erases the region of picture DIS:3 indicated with the cursor
     ERASE PARTITION DIS:5 IMAGE SIZE 100 TOP LEFT
       erases the image memory only of the top left 100 pixels square of
       partition DIS:5
     ERASE FRAME 2 OVERLAY VIEW
       erases the overlay memory only of frame 2, and presents the blank frame
       on the monitor

For information on the general option ERASE, see ERASE.OPTION
$
In default, ERASE works on DISPLAY, in picture coordinate mode; however, you
can also use it in PARTITION or FRAME mode -

     e.g., ERASE PARTITION DIS:7 (see GRAPHICS)

You may specify a subregion if you wish with the standard 2-D subregion
keys and options.

For complex display pictures, where the real and imaginary parts of the image
are displayed side by side, ERASE would normally clear both parts.  If,
however, you specify the option RE or IM, only the real or imaginary part
will be cleared.

See also: erase.syntax, erase.option
$add erase.syntax
Keys:
  []               picture/partition/frame to be erased [DISPLAY if picture
                   or partition; CFRAME if frame]
  SIZE(2)          dimensions of subregion to be erased [whole region]
  POSITION(2)      position/offset of subregion [0,0]

Options:
  PICTURE | PARTITION | FRAME  use indicated coordinate system [PICTURE]
  IMAGE | OVERLAY  erase image or overlay memory only [both if neither set]
  LEFT | RIGHT     erase subregion abutting indicated border
  BOTTOM | TOP
  RE | IM          erase real or imaginary part of complex display picture
                   [erase both parts]
  VIEW             switch view to make display region visible [NO]

See SUBREGIONS for more details of subregion keys/options.

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add erode.command erode morphology
You use ERODE for various morphological (shape) manipulations on binary
pictures, treating zero pixels as background, and non-zero pixels as connected
objects.  Several modes are available, removing pixels from objects depending
on the geometry of 3x3 pixel neighbourhoods.

Exx: ERODE DISPLAY
       strips a one-pixel wide border off all objects (by clearing pixels
       which have a clear neighbour)
     ERODE 50 TO 51 TIMES 3
       strips a three-pixel border off all objects (repeats ERODE 3 times)
     ERODE 4 SKELETONISE
       erode picture 4 down to an 8-connected skeleton

A zero value for TIMES causes indefinite repetition until the picture
stabilises (or until you 'abandon' the operation); this is faster than
repeated use of ERODE in a FOR loop, as the command is able to omit in later
passes picture rows that have stabilised against further erosion.

Options/keys select various more selective modes of erosion, described
separately.  The sequence ERODE;DILATE (see DILATE) is a common way of
smoothing object borders.

                                        Form used internally: integer (binary)

See also: erode.syntax, erode.neighbours, erode.skeleton, erode.ends

See also: erode.nodes, erode.outline, erode.ol4, erode.with
$add erode.syntax
Keys:
  [FROM]        source picture [SELECT]
  [TO]          output picture [FROM]
  NEIGHBOURS    erode points with given minimum number of clear neighbours [1]
  WITH          picture containing user-supplied mapping tables [none]
  TIMES         force repeat count for erosion process [0 if SKELETONISE or
                ENDS set, 1 otherwise]

Options:
  SKELETONISE   erode object down to 8-connected skeleton
  ENDS          erode protruding branches/hairs from ends
  NODES         erode intersections from skeleton, separating branches
  OUTLINE       erode interior of objects, leaving (8-connected) outline
  OL4           erode interior of objects, leaving 4-connected outline

Except for TIMES, all keys and options are mutually incompatible alternatives.

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add erode.neighbours erode
ERODE NEIGHBOURS 5
  strips off border pixels which have at least 5 clear neighbours (which
  removes isolated points and lines without affecting the edge of
  extended objects)
ERODE NEIGHBOURS 8
  clears isolated set pixels only

In default, ERODE clears pixels with at least one clear neighbour.  You can
change this minimum number via the key NEIGHBOURS however, and perform more
and more selective erosion as you increase it towards the maximum of 8.  The
default mode of ERODE is in fact ERODE NEIGHBOURS 1.
$
point  line hole  concave  straight   convex  outward  lines  line  isolated
holes    ends     edges     edges     edges   corners         ends   points
<-------------------------------------1------------------------------------>
          <--------------------------------2------------------------------->
                    <----------------------------3------------------------->
                                      <-------------------4---------------->
  sets of features for which                  <---------------5------------>
  object borders are eroded for                        <----------6-------->
  the various different clear neighbour counts                 <-----7----->
                                                                    <---8-->
Examples for particular object configurations:
............    ............    ............    ............    ............
..1...111...    ............    ............    ......111...    ......111...
.....11111..    ............    ......111...    .....11111..    .....11111..
...1.11.11..    ............    ......1.1...    .....11.11..    .....11.11..
......1111..    ............    .......1....    ......1111..    ......1111..
..111111....    ............    ............    ......11....    ..111111....
............    ............    ............    ............    ............
  Original         Default         Neigh 3         Neigh 5         Neigh 8
$add erode.skeleton erode
ERODE SKELETON
  thins objects down to (8-connected) skeleton lines/curves

    ......................                       ......................
    .111............111...                       ..1...................
    ..11.....1111111111...                       ...1.............11...
    ....1111111111111.....      skeletonise      ....11....1111111.....
    .....111111....1111...    --------------->   ......1111......1.....
    .......1111.....111...                       ..........1......11...
    .........1111.........                       ...........11.........
    ......................                       ......................

Objects are thinned in sequences of four passes, in which pixels are removed,
without affecting the 8-connectivity of objects, from the top and left, the
bottom and right, the bottom and left and the top and right in turn; in
default the sequence is repeated until the pictures stabilises, but you can
limit the number of sequences if you wish via the key TIMES.
$
The skeleton produced is not strictly a minimal 8-connected skeleton; the
algorithm used (in the interests of speed) can leave a few additional pixels,
particularly at T-junctions.  Border erosion is quite close to isotropic:
circular objects are successfully eroded to points via a series of smaller
circles.
$add erode.ends erode
ERODE ENDS
  strips away all free ends (branches, hairs) from a skeleton or extended
  object

        ................                     ................
        ..1.11111111....                     ....11111111....
        ...1........1...                     ...1........1...
        ....11....111111    erode ends       ....11....111111
        ......1111...... ----------------->  ......1111......
        .....1....1.....                     .....1..........
        ...11......11...                     ...11...........
        ..1.............                     ..1.............

Branches reaching the picture border are not eroded.  In default, end pixels
are eroded one by one in successive picture passes until no further change
takes place; you can use the key TIMES to limit the number of passes, and
hence the amount eroded, if you wish.
$add erode.nodes erode
ERODE NODES
  deletes pixels from a skeleton at intersections, separating branches -
  e.g. for separate measurement

        ..1.............                      ..1.............
        ..1.............                      ..1.............
        ...1............                      ...1............
        ....11....111111     erode nodes      ....11....111111
        ......1111......  ----------------->  ......111.......
        ..........1.....                      ..........1.....
        ...........111..                      ...........111..
        ..............11                      ..............11
$add erode.outline erode
ERODE OUTLINE
  erodes interior points of objects (in a single pass) leaving (minimal 8-
  connected) outlines
$add erode.ol4 erode
ERODE OL4
  erodes interior points of objects (in a single pass) leaving outlines only;
the outlines are 4-connected rather than 8-connected
$add erode.with dilate.with erode dilate
ERODE DISPLAY WITH 21
  applies a user-defined operation defined in 'picture' 21
CREATE 51 SIZE 256,1 VALUE 0; ORIGIN LEFT; P 255=1; ERODE DIS WITH 51
  generates and applies a map equivalent to the default action of ERODE
  (eroding set pixels that have any clear neighbours)
STACK 3,6 TO 7; DILATE 50 WITH 7
  applies the maps in pictures 3-6 in turn to dilate objects in picture 50

All modes of ERODE and DILATE rely on a 256 or 512 element map (table) which
provides replacement values for pixels on the basis of an index constructed
from their 3x3 neighbour geometry; for most modes the map is generated
internally, but you can use the information following to construct your your
own if you wish, and supply it to ERODE/DILATE via the key WITH.
$
          In the commoner case of a 256 element map, the map          0 1 0
  7 6 5   index is constructed by combining bits (0 or 1 for          0   0
  0   4   zero or non-zero) for each neighbouring pixel as an 8-      1 1 0
  1 2 3   bit number (0-255) with the bit numbering scheme left    = 01000110
          (0=lsb,7=msb); the example right should make this         = 64+4+2
          clear.                                                     = 70

The map takes the form of a one row picture; the elements taken from left to
right provide replacement values for pixels at the centre of configurations
with index 0,1..255.  The central pixel itself need not be included in the
map, as ERODE only considers pixels for which the centre is 1 and DILATE only
pixels for which the centre is 0.  You should be able now to understand the
second example above.

          If you supply a 512 element map instead, the central
          pixel is used as well, to provide a nineth index bit        0 1 0
  7 6 5   (b8, the most significant bit), and no account is           0 1 0
  0 8 4   taken of whether you use ERODE or DILATE to apply the       1 1 0
  1 2 3   map.  The purpose of this is to accommodate             = 101000110
          operations which simultaneously clear some pixels and   = 128+64+4+2
          set others; the MEDIAN command is of this type, for        = 198
          example.

The results for all pixels are established in parallel on the basis of the
original 3x3 geometry, i.e. a change in one pixel does not affect the
neighbourhood of adjacent pixels horizontally or vertically until the next
pass.

You can supply several maps to be applied in turn, as successive layers of the
map picture, as in the last example.

You may find the library program GENBMMAP useful for generating maps of your
own; you can of course edit it to provide your own variants.
$add ?1:
This error can occur if there are serious problems with a disc file, or if
a locally written command attempts to access non-existent areas of a picture
disc file.
$add ?2:
This error is not used on this system - please submit a Report Form if it occurs.
$add ?3:
Error 3 means that the variable or keyword named in the message has an
inappropriate value, e.g. a negative radius for a circle; it may be caused
indirectly by omitting a vital key for which there is no useful default, as
this is usually equivalent to giving it value zero. Remember that only the
first three letters of the name will appear in the message.
$add ?4:
Error 4 is reported when Semper acknowledges an 'abandon' request from the
terminal, and is not truly an error condition at all.
$add ?5:
Likely causes for error 5 include:
- Zero or negative picture dimensions requested
- Picture row length too great for internal row buffers (SHOW SYSTEM lists
  maximum lengths for each form)
- Non-factorisable dimensions in operation such as ROTATE (i.e., dimensions
  not factorisable into factors 2,3,4 and 5 with at least one factor 4;
  SHOW SIZES lists the acceptable sizes)
- Dimensions not a power of two in operation involving Fourier or Walsh
  transformation
- Inappropriate picture dimensionality, e.g. 2-D picture where 1-D required.
$add ?6:
Error 6 means that you have tried to apply an operation to data to which it is
not appropriate; typical examples include:
- Fourier transforming a picture which is already a transform
- Calling an Image picture as a macro (e.g. @56)
- Displaying a Macro, or doing almost anything except LIST or EDIT it
- Histogram equalising with an Image rather than a Histogram
- Loading a non-Lut picture as a look-up-table
- Using another class where a Plist is needed, e.g. as a mask boundary
Probably you have typed a wrong picture number; otherwise, you may have
misunderstood how the command you are using works, and should ask HELP about
it again (perhaps using HELP/FULL..)
$add ?7:
Error 7 means that you (or a macro or program you are using) have tried to
jump to the label indicated, but that the label cannot be found; the error
context printout will tell you whether the problem is inside a program. Likely
causes include:
- a mistyped name in the label or JUMP command
- trying to jump to a label outside the program
- trying to jump into a FOR loop
- trying to jump to a previous or subsequent line interactively
$add ?8:
Likely causes for error 8 include:
- inability to read/write information on a damaged/dirty disc
- hardware failure in a disc drive/controller
- writing to a file to which you have read access only (indicates a problem in
  the primitive MCDC61)
Little useful response is possible; no data loss will occur if the error
arises during reading, but its extent is not usually very serious in any case,
normally resulting in directories or picture data being 'backed-up' to their
state shortly before the error.

In VAX installations, disc access is integrated with the memory paging, and
actual disc errors may be accompanied by paging error messages.
$add ?9:
Likely causes for error 9 include:
- using or setting a pixel with coordinates that are out of range
- using a bad layer number
- using a subregion that does not overlap the picture at all
- setting a picture coordinate origin outside the picture
- mistakes in new Fortran routines of your own writing
$add ?10
Is not in fact reported by Semper; commands that produce very specialised
error messages of their own follow these by returning error 10 to the
interpreter, which responds by returning to the terminal for fresh
instructions as usual, but without printing any further message.
$add ?11 ?37 ?42
Errors 11, 37 and 42 all reflect problems creating new pictures on disc
devices. You may not always be aware when you are creating a new picture in
fact, since even when you process 'in situ' (e.g. LMEAN 50 rather than LMEAN
50 TO 51), a new picture is created if you change the dimensions (e.g. EXTRACT
50 SIZE 400) or form (e.g. SHARPEN 50 INTEGER); in addition, some commands
create intermediate pictures internally for various reasons(e.g. FOURIER 50 TO
51).

Error 11 means that there is insufficient free space left on a disc device for
a new picture you are creating. The things you might try in response are
- deleting unwanted pictures from the device in question
- using a more compact form for your output picture (e.g. LMEAN 50 BYTE)
- storing other pictures in more compact forms (e.g. COPY 41 BYTE)
- creating a new disc device, temporarily if necessary, with sufficient space
  (e.g. ASSIGN NEW NAME '..' SIZE ..  or ASSIGN SCRATCH SIZE ..)
It is NOT worth trying to COMPRESS the device; the error message means that
there is insufficient space in total, not simply that it is fragmented.

Error 42 means that there is sufficient space in total on a disc device for a
new picture you are creating, but that the space is broken into several
fragments none of which is individually large enough to accommodate the
picture; COMPRESSing the device before continuing will cure the problem.

Error 37 means that insufficient space remains in the directory of a disc
device for the recording of a new picture you are creating; it is likely only
when the device is a SAVE file, or when the directory has been deliberately
created with a small number of slots (to save space), - but is possible more
generally if you have very large numbers of pictures within a device; you can
ask DIRECTORY about current directory slot usage. COMPRESSing the device may
help, as each empty segment of disc requires a directory slot to record it.
$add ?12
Error 12 means that some kind of picture scaling operation is impossible,
because the picture minimum and maximum values are equal. Likely causes
include:
- displaying a picture (or subregion) in which all pixels are constant
- setting MIN, MAX equal when specifying PRESET (e.g. SCALE PRESET RANGE 1,10
  when MIN and MAX as both zero)
- using correlation functions to register two images one or both of which has
  all pixels equal
$add ?13
Error 13 has two likely causes:
- you have tried to reset a 'protected' variable such as PI (HELP VARIABLES
  tells you about these)
- you have tried to set too many variables simultaneously (SHOW SYSTEM tells
  you the maximum number supported by your installation); use UNSET to clear
  those you don't really need
$add ?14
Error 14 means that your command (after any prefixed labels, conditionals and
assignments have been stripped off) begins with a name that is not a currently
defined command. Probably you mistyped it; if in doubt, try SHOW COMMANDS,
which lists all commands recognised by your installation.
$add ?15
Error 15 means that you have tried to recover picture data from the display
device in an installation where your display hardware is not capable of
reading back such data. Note that trying to process a display picture 'in
situ' (e.g. SHARPEN DISPLAY) in fact involves this kind of read-back, as the
picture data must be recovered by your computer before the sharpened version
can be calculated.
$add ?16
Error 16 means that you have used an unrecognised function name in an
expression, e.g. TYPE SIX(THETA) instead of TYPE SIN(THETA). It can also be
provoked by mistyping however: for example, EXTRACT ANGLE T(2 instead of
EXTRACT ANGLE T*2 tries to treat T as a function name because of the bracket
following it. HELP FUNCTIONS lists all functions recognised by Semper.
$add ?17
Error 17 means that Semper cannot understand a command; possible reasons
include:
- mistyping commands so that they are unrecognisable, e.g. P X 2 or [ X=2 for
  P X=2
- omitting essential items from commands, e.g. JUMP without a label name
- including spurious additional items, e.g. EXTRACT ANGLE=.3 (which should
  have no = sign)
- typing name# without a following subscript variable
$add ?18
Error 18 means effectively that an expression you have used is too complicated
for Semper. It is more likely to occur in CALCULATE commands (for which each
intermediate result in fact involves a whole picture row) that elsewhere, but
is rare in either case. To cure the problem, simply split your expression
into two simpler ones evaluated in turn.
$add ?19
Error 19 is reported if you try to UNSET one of the 'protected' variables such
as PI (see VARIABLES for a list). Unsetting a 'fixed' variable does not
cause error 19, and simply has no effect.
$add ?20
Error 20 means that an expression you have used is wrongly constructed, e.g.
COS(), S+*6 or ROOT(2,3). HELP EXPRESSIONS explains the syntax of expressions
if you are in doubt.
$add ?21
Error 21 means that a macro expansion would cause the command line to exceed
the maximum permitted length. SHOW SYSTEM will tell you the maximum length
allowed. Note that numbered macros are an old feature that will be removed
in a later release. Converting the macro into a library program using the
command ADD should remove the problem.
$add ?22
Likely causes for error 22 include:
- division by zero, e.g. TYPE 1/X when X is zero, or CALCULATE :SEL/:2 when
  some pixels of picture 2 are zero
- taking the ln or square root of a negative number, e.g. MARK RADIUS ROOT(T)
  when T is -2
$add ?23
This error is not used on this system - please submit a Report Form if it occurs.
$add ?24
Error 24 means that you have 'nested' a RUN call from within a run file. If
you require to invoke other programs from a run file load them into a program
library file and invoke them using the LIBRARY command.
$add ?25
Likely causes for error 25 include:
- using an unset variable as a key value or in an expression, e.g. IF X>T when
  T is unset
- providing no value for a key which you are required to set because no useful
  default can be provided
- neglecting to set variables needed by a command, e.g. SPC LEVELS H3 LIST
  when H3 is unset
- syntax errors, e.g. ASK 'VALUE ',X for ASK 'VALUE ' X (in the former, X is
  treated as part of the prompt string
$add ?26
This error is not used on this system - please submit a Report Form if it occurs.
$add ?27
This error is not used on this system - please submit a Report Form if it occurs.
$add ?28
Likely causes for error 28 include:
- using a zero or negative picture number, e.g. 3:0
- using a picture number greater than 999
- using a display picture number greater than the maximum for your
  installation
- using a zero or negative device number
- using a device number greater than the maximum for your installation
$add ?29
Error 29 means that you have tried to do something to a device or picture
inappropriate to its storage medium (disc, display, help library);
likely causes include:
- RENUMBERing a display picture
- COMPRESSing a display device, or asking for DIRECTORY information about one
- doing anything to a help library other than ASSIGNing and DEASSIGNing it
- MARKing subregions on a disc picture
$add ?30
Most commonly, error 30 simply means that you have referred to a disc
picture that does not exist; try EXAMINE ALL or EXAMINE DEVICE .. to check
what does exist.  Note that a display partition may exist without having a
picture in it, so SHOW PARTITION DIS:3 can report details of the partition
even when EXAMINE DIS:3 reports error 30.
$add ?31
Error 31 means that a 'tab' setting used in a TYPE or ASK command, or in the
value for a textual key, requests a character position that is negative or too
far right, e.g.
  TYPE 'Values ',#H,X,#V,Y
when H is zero or V is 1e5.
$add ?32
This error is not used - please submit a Report Form if it occurs.
$add ?33
Error 33 means that you have attempted to recover a picture from, or process
'in situ', a display picture which has been undersampled to make it fit its
partition and which therefore no longer actually has all the pixels it ought
to have.
$add ?34
Error 34 means that you have tried to do something to a device number which
is not currently assigned, and does not therefore refer to any particular
disc or display; SHOW DEVICES confirms the current list of assigned
devices. Probably you have simply mistyped a picture number.
$add ?35
Error 35 means that you have used a command that expects to find programs on
a device that does not have them, for example LIST ALL DEVICE 3 when device 3
is a picture disc or help library.
$add ?36
Likely causes for error 36 include:
- Syntax errors in a FOR command, e.g. FOR N=1;
- Too many FOR loops active at once, e.g. FOR..; FOR..; FOR..; FOR..; FOR..
- Bad loop increment values, e.g. FOR N 1,2,0
$add ?38
Error 38 means that you are trying to display a multi-layer picture - probably
full colour - for which each layer is output to a separate (successively
numbered) display frame, and have run out of hardware display frames. If your
installation provides four frames, for example, you can display full colour
pictures in partitions defined in frames 1 and 2 (for which frames 1-3 and 2-4
respectively would in fact be used), but not in partitions in frames 3 or 4.
$add ?39
Error 39 means that you are trying to process a display picture 'in situ' in
a way that requires two display pictures of different sizes to co-exist during
the processing, e.g. EXTRACT DISPLAY SIZE 400 when the display is 300 square.
(Differences in form do not cause problems, except that Complex pictures, for
which real and imaginary parts are displayed side by side, are incompatible
with non-Complex pictures.)
$add ?40
Likely causes for error 40 include:
- hardware failure in the display device or interface
- using false or full colour look-up-tables in installations where the
  hardware does not support them
- using zoom factors or pan settings unsupported by your display hardware
$add ?41
Likely causes for error 41 include:
- altering a protected picture (processing it 'in situ', e.g. LMEAN 51, using
  the P command to change pixels, changing the title etc.)
- using an output picture that already exists and is protected, e.g. LMEAN 50
  TO 51 when 51 is protected
- deleting a protected picture
- altering anything at all on a protected device
If in doubt about whether a picture is protected, ask EXAMINE; for devices,
ask SHOW DEVICE instead. Picture level protection can be removed or imposed
via the WP command; device level protection is established when the device is
ASSIGNed and cannot be altered without a DEASSIGN step.
$add ?43
Error 43 means that you are trying to use or store data whose form (byte,
integer, fp or complex) is unsuitable in some way, e.g. applying an operation
only meaningful for complex data to a non-complex picture.
$add ?44
Error 44 is reported for any kind of problem arising during assigning or
deassigning devices; common causes include:
- mistyping the name of a disc file you are ASSIGNing
- ASSIGNing without option WP a disc file you are not authorised to alter
- deleting (via DEASSIGN DELETE) a disc file you are not authorised to delete
- ASSIGNing a NEW disc file for which space cannot be found
$add ?45
Error 45 means that you have tried to assign too many devices at once. SHOW
SYSTEM tells you the maximum number permitted in your installation, and SHOW
DEVICES lists the devices you have assigned already. You need to DEASSIGN
some other device before trying again.

Note that the SAVE command assigns a further device temporarily (for the save
file), and so can also give rise to this error.
$add ?46
Error 46 means that you have tried to RENUMBER a picture to a new number that
is not in fact currently unused.
$add ?47
Error 47 usually means that Semper's internal row buffers are not large enough
to process rows of the picture indicated in the form your command uses
internally. This form is not under your control, and even when your source
and output pictures are in byte form, the routine may in fact process pixels
in fp form, and rows that fit the buffers in byte form may not do so in fp
form.

The only real solutions are breaking pictures up into smaller sub-pictures, or
recompiling the entire system with longer row buffers.
$add ?48
Error 48 means that the display indicated is of a type (2-D, 1-D, histogram,
etc.) inappropriate to your command. Likely causes include:
- using the cursor in modes only possible for 2-D pictures (e.g. defining a
  closed curve) on a 1-D graph or histogram
- using a 1-D graph or histogram as source to a command, e.g. COPY DIS:2 TO 23
  (the data cannot be recovered from these display types)
$add ?49
Likely causes for error 49 include:
- mistyping the name of a macro, e.g. @REFION for @REGION
- using the @ character accidentally
$add ?50
Error 50 should not normally happen in Semper, and is likely to indicate a
mistake in Fortran code of your own writing; specifically, it indicates that
the low level routine DISC has been asked to read or write an out-of-range
block number on the device indicated.
$add ?51
Error 51 means that a command needing temporary work space on disc has been
unable to find any or enough; likely causes include:
- no disc devices assigned at all
- no disc device with sufficient contiguous space available
- all disc devices are write-protected
Only a few commands (amongst them LMEAN, LVARIANCE, LSD, SHARPEN and HP) are
in fact dependent on such work space.
$add ?52
Error 52 should not normally happen in Semper, but might occur following a
disc hardware fault. Specifically, it indicates that the 'label' of the
indicated picture, which contains all the crucial information about the
picture (dimensions, form, etc.) is corrupt; the only useful response is to
delete the picture via DELETE .. MALFORMED.
$add ?53
Error 53 means that you have used the indicated display picture or partition
number without having defined where the partition is stored and how large it
is. If you have not simply mistyped the number, use the PARTITION command
appropriately before continuing.
$add ?54
Error 54 can arise when you are magnifying a subregion with DISPLAY, and means
that you have magnified it so many TIMES that it would not fit into the output
region specified, i.e. display partition or terminal window (TYPE option) or
log file (LOG option). Try again with a reduced value for TIMES.
$add ?55
Error 55 means that a histogram you are creating has too many channels for the
counts to fit Semper's internal buffers. Try again with a smaller value for
the CHANNELS key.
$add ?56
Error 56 means that a command uses too many pictures at once. It may occur in
a CALCULATE command, e.g. CALCULATE :1+:2=:3+:4+:5+:6+:7+:8.., in which case
you must split the command into two simpler commands; otherwise it should not
normally happen in Semper, but may arise in new commands of your own writing.
SHOW SYSTEM tells you the maximum number that may be open at once in your
installation.
$add ?57
Error 57 means that your command is wrongly constructed in some way; likely
causes include:
- you have used an illegal (possibly mistyped) name for a key or option, e.g.
  EXTRACT ANFLE .3
- you have omitted altogether a required key name
$add ?58
Error 58 means that you have applied a command to a group of pictures (e.g.
EXAMINE 20,40 or COPY 1,10 .. or SAVE 3:20,3:99) when no pictures exist in the
indicated range
$add ?59
Error 59, which occurs only rarely, means that the output from your command is
stored in the same place as the source, and that the processing operation
being carried out fails in such circumstances.  Semper only re-allocates the
same storage if there is no change of picture number, dimensions and form, so
you cure the problem by directing output somewhere else (e.g. EXTRACT 50 TO 51
rather than simply EXTRACT 50).
$add ?60
Error 60 means that the two keys or options indicated are mutually
incompatible, invoking strictly alternative modes - e.g. CTF ADD adds to the
source, and CTF MULTIPLY multiplies by it, but CTF ADD MULTIPLY is faulted.
$add ?61
Error 61 should not normally occur in Semper, but may occur in new routines of
your own writing if you accidentally refer to picture layers that do not
exist.
$add ?62
Error 62 means that the command indicated currently makes no provision for
multi-layer pictures in any simple way (such as repeating the operation for
each layer, or effecting a 3-D generalisation of the 2-D operation). This
error may be expected to occur more rarely in later releases of Semper.
$add ?63
Likely causes for error 63 include:
- setting a picture coordinate origin outside the picture bounds (in new
  routines of your own writing)
- using a Fourier picture whose origin is neither at the centre nor at the
  centre of the left hand column
$add ?64
Error 64 means that you have used an option inappropriate to the particular
use of the command, e.g. LUT 2 RED .. when lut 2 is monochrome.
$add ?65
Likely causes for error 65 include:
- using a FIR filter kernel (FIR WITH..) with no non-zero values
- no other causes at present
$add ?66
Likely causes for error 66 include:
- using an FIR filter kernel with too many points in each row (the limit is
  installation dependent, but is at least 21)
- using an FIR filter kernel with too many points in total (the limit is the
  maximum number of fp values that fit a row buffer; use SHOW SYSTEM to find
  the limit for the current system)
- offering a 2-D FIR filter kernel for SEPARABLE application
$add ?67
Error 67 means that the Plist picture indicated should define a closed curve
and does not - perhaps because you have mistyped the picture number; for
example, MASK WITH .. requires a closed curve to define the boundary of the
region inside/outside which the picture is to be masked. See XWIRES.CURVE
for how to create such Plists if necessary.
$add ?68
Error 68 indicates that you have used an out-of-range look-up-table number -
negative, zero or greater than the maximum permitted for your installation
(use SHOW SYSTEM to find this limit).
$add ?69
Likely causes for error 69 include:
- VIEWing with a lut you have not created (use LUT to create luts)
- using LUT to recover or alter a lut you have not created
SHOW LUTS lists the luts currently defined.
$add ?70
Error 70 means that you have used a display partition number that is illegal
in some way; likely causes include:
- using a negative or zero partition number
- omitting the display device number (e.g. typing an ambiguous 4 for DIS:4)
SHOW PARTITIONS lists the partitions currently defined.
$add ?71
Error 71 means that you have tried to do something intended only for display
devices (e.g. ERASE) to the disc indicated.
$add ?72
Likely causes for error 72 include:
- using the list Plist indicated when a curve is needed, e.g. MARK WITH ..
- using the curve Plist indicated when a list is needed, e.g. EXTRACT WITH ..
$add ?73
Likely causes for error 73 include:
- using a non-display device number when a display is needed, e.g. MARK 2:3
  when 2 is a disc device
- using an out-of-range partition number (negative, zero or beyond the maximum
  your installation permits - use SHOW SYSTEM to find the limits)
$add ?74
This error is not used - please submit a Report Form if it occurs.
$add ?75
Error 75 is caused by using an out-of-range frame number (negative, zero or
beyond the maximum your installation permits - see SHOW DEVICES).
$add ?76
Error 76 means that the indicated device number is illegal - negative, zero or
beyond the maximum permitted for your installation (use SHOW SYSTEM to find
the limits).
$add ?77
Is similar to error ?10, except that the command also provides an error
message for Semper. This message is available for subsequent SHOW LAST ERROR
and REPORT ERROR commands.
$add ?78
Error 78 can arise in XWIRES CIRCLE or XWIRES ARC, which seek to define a
circle or a circular arc, if you mark three points in a straight line, as
these would require an infinite radius.
$add ?79
Error 79 means that the vectors (U,U2) and (V,V2), used by your command, are
parallel and must not be so - e.g. because they are supposed to be base
vectors of a 2-D lattice.
$add ?80
Error 80 arises in XWIRES if so many points are marked (list mode) or
generated (curve or graph mode) that internal workspace tables overflow.
The only useful response is to repeat the operation with a smaller number
of points.
$add ?81
Error 81 means that you have used XWIRES GRAPH on a display which is not a 1-D
graph; probably you have simply mistyped the display number. (XWIRES GRAPH
only operates on an existing graph; if you have none initially, use something
like CREATE 1 SIZE 500,1 VALUE 0; MIN=0 MAX=30; DISPLAY PRESET to create one,)
$add ?82
Error 82 means that the first point you marked in a XWIRES GRAPH command was
unsatisfactory: draw graphs from the left hand side to the right.
$add ?83
Error 83 means that you have used an illegal zoom factor for display viewing -
particularly a negative or zero value.
$add ?84 ?85 ?86
Errors 84, 85 and 86 should not normally occur; they indicate a fault in the
System Generation program SEMGEN, which should ensure than no Verb Descriptor
can have more keys, options or open requests than can be accommodated by
the interpreter's internal tables.
$add ?87
This error is not used on this system - please submit a Report Form if it occurs.
$add ?88
Error 88 means that you have attempted to use a rotated, resampled or skewed
sub-region with more than one layer. (SEMPER currently only supports 2-D
operations on such regions).
$add ?89
Error 89 means that you have referred to a display (picture, partition or
frame) sub-region that is entirely outside the display. Likely causes include
- mistyping the value of a POSITION key
- confusing one partition with another (be explicit, e.g. ERASE FS:4 .. if in
  doubt)
(SHOW PARTITION N reports the size and position of partition N.)
$add ?90
Error 90 means that you have tried to apply a picture processing or inspection
operation, or simply EXAMINE etc., to a device that contains text (e.g. a
Help Library) rather than pictures. Likely causes include:
- mistyping a device number
- using EXAMINE on a Help Library (use HELP/TOPICS instead)
(SHOW DEVICES tells you about all the devices you have currently assigned.)
Error 92 means that a calculation has used or created an unrepresentable
value (infinity, 0/0 etc.).
Likely causes include:
- using a form fp picture you have CREATEd but not yet filled with any
  particular values
- using a half-processed output picture following an abandoned operation
$add ?95
Error 95 means that the divisor in an arithmetic operation was found to be
zero.
  e.g.
      A=0 B=1/A
   or
      CALC :2/:3   where picture 3 contains some zero pixels
$add ?96
Error 96 means that the argument to ROOT was found to be negative.
  e.g.
      A=-1 B=ROOT(A)
   or
      CALC ROOT(:9) where picture 9 contains some negative pixels
$add ?97
Error 97 means that the argument to LN was not positive
  e.g.
      A=-1 B=LN(A)
   or
      CALC ROOT(:9) where picture 9 contains some negative or zero pixels
$add ?98
Error 98 means that the argument to ACOS or ASIN did not lie in the range
-1 to 1.
  e.g.
      A=-PI B=ACOS(A)
   or
      CALC ASIN(:4) where picture 4 contains some pixels with a value greater
                    than 1 or less than -1.
$add ?99
Error 99 means that an attempt to raise a negative value to a non-integer
power was detected.
  e.g.
      A=-PI B=1.5 C=A^B
   or
      CALC (:4^.5) where picture 4 contains some negative pixels
$add ?100
Error 100 means that the directory on a program library has filled. Try
COMPRESSing the device if DIRECTORY indicates deleted slots, otherwise create
a new program library with more slots (use the SLOTS keyword in ASSIGN NEW)
and copy the programs across to the new library.
$add ?101
Error 101 means that the text area on a program library has filled. Try
COMPRESSing the device if DIRECTORY indicates deleted space, otherwise create
a new program library with more space (use the SIZE keyword in ASSIGN NEW) and
copy the programs across to the new library.
$add ?102
Error 102 is a rare error, indicating that a program has more FOR, LOOP and
label commands than can be buffered internally. Either restructure the program
to remove unnecessary labels, or split out part of it as a new program which
can then be invoked from the remainder of the original.
$add ?103
Error 103 means that you have a LOCAL statement directly inside a FOR loop.
LOCAL statements are allowed inside programs called from within a FOR loop,
but must be outside of any FOR loops within that program.
$add ?104
Error 104 means that the local variable table had overflowed (use SHOW SYSTEM
to find the size of the table). Local variables are used to save the state of
keys and options quoted in a command, variables used as FOR loop indices,
explicit LOCAL variables and also from code within some processing commands.
$add ?105
Error 105 means that a LOOP command does not match the enclosing FOR index.
Likely causes for this error are:
- Having a FOR loop in a macro accessed from a program
- Having a LOOP command with the wrong index in a conditional expression.
  (You should use NEXT or BREAK to conditionally affect FOR loops)
$add ?106
Error 106 means the interpreter can not find a matching LOOP to a FOR command.
This is more likely in a program, as you will be prompted for terminating
LOOPs interactively. Other possible causes are:
- Using the wrong loop index, e.g. FOR I 1,10 ... LOOP J
- Having a FOR loop in a macro accessed from a program
$add ?107
Error 107 means you have a RUN command within a program or FOR loop.
The RUN command is used to select input from a new source, as a side effect
the current command line is lost. Any FOR loop or active program would then be
left in limbo. Include the contents of the run file as a program and use
LIBRARY instead.
$add ?108
Error 108 means you have exceeded the maximum nesting of LIBRARY commands
that are allowed. One possible cause of this is unterminated recursion,
either directly (LIB XXX within program XXX) or indirectly (LIB XXX within
program YYY and LIB YYY within program XXX). Look at the error context
messages to find out the likely cause. Use SHOW SYSTEM to find the local
maximum nest level.
$add ?109
Error 109 means you have exceeded the maximum nesting of FOR loops
that are allowed. Use SHOW SYSTEM to find the local maximum nest level.
$add ?110
Error 110 means that a NEXT or BREAK command has been encountered
with an index variable that is not in use by any active FOR loop, or
there are no active FOR loops at all.
$add ?111
Error 111 means a LOOP command has been encountered when there was no
active FOR loops.
$add ?112
Error 112 means that you have tried to JUMP to a label that is within
a FOR loop that is not currently active.
$add ?113
Error 113 means that you have attempted to DEASSIGN or REINITIALISE a
device that has an active program on it. This error will only occur
within a program. Look at the error context to determine which program
is active on the device.
$add ?114
Error 114 means that no help library has been assigned, which means that
no help information can be provided on specified topics. The command
HELP by itself prints some text which explains how to use the command and
describes other Semper commands that can provide information about your
Semper session.
$add ?115
Error 115 means that no topics matching the keywords following the HELP
command were found in any of the assigned help libraries. Try using the
/TOPICS option to determine what topics are available.
$add ?116
Error 116 means that the value of a numerical expression either before or
after the colon ':' operator is out of range. Device numbers must lie in
the range 1 to the maximum allowed for the system (type SHOW SYSTEM to find
out what is the maximum) and picture numbers must lie in the range 1 to 999.
$add ?117
Error 117 means that you attempted to create a new HELP library within Semper
At present new HELP libraries can only be created using the (separate) Help
Manager utility (usually called HELPMAN)
$add ?118
Error 118 occurs when you attempt to reassign a display device that is
already assigned. If you wish to change the characteristics of a display
device you must DEASSIGN it first. Currently the display is forced to be
device 1, but this will change in future versions.
$add ?119
Error 119 usually occurs when an attempt is made to ASSIGN a file that is
not a Semper disc file. e.g. attempting to assign a log file
$add ?120
Error 120 only occurs in demonstration versions of Semper. Any disc devices
created by a demonstration version can only be reassigned by the full version
of Semper. This allows demonstration versions to be used to collect and
process images without data loss, pending the delivery of a full version of
Semper.
$add ?121
Error 121 results when the device number specified to ASSIGN is already in
use. Use SHOW DEVICES to find out which devices are assigned.
$add ?122
Error 122 means that some of the options or keywords given to a command
require another keyword should also be quoted.
$add ?123
Error 123 means that Semper has been unable to create a unique workspace area
after 20 retries. Possible reasons for this are:
  (1)  The system time-of-day clock has failed.
  (2)  Too many other Semper users are attempting to create workspace
       devices at the same time (Networked/Multiuser systems only).
  (3)  The primitive routine WAITS is not performing correctly.
  (4)  The primitive routine MCTIME is not performing correctly.
  (5)  The primitive routine MCDC61 is not performing correctly.

If the problem does not appear to be (1) or (2) contact Synoptics.
$add ?124
Error 124 means that a picture device, display or help library
has been used in a context that requires a program library device.
$add ?125
Error 125 means that the specified program is not available on any of
the currently assigned program library devices. Use SHOW PROGRAMS to
produce a list of available programs.
$add ?126
Error 126 means that an attempt has been made to COPY or RENAME a program
onto an existing program. If this is really what you want to do, delete the
existing program first.
$add ?127
Error 127 means that an attempt has been made to delete a program while the
program is still in use. This can happen if one program invokes another
one that then tries to delete the first one.
$add ?128
Error 128 should not normally happen, as it means that the program library
index is corrupt or has been written back incorrectly. Possible causes
include system crashes when adding a new program or incompatible versions
of Semper on the same host machine.
$add ?129
Error 129 can be produced by any command that accesses the file
input/output system. The I/O error number should be looked up in your
local Fortran IOSTAT or run-time I/O error tables. On some systems Semper
will also produce a more meaningful interpretation of the error number as a
supplementary message.
$add ?130
Error 130 means that the indicated file could not be found and/or opened
for input. On some systems the local PATH environment is used to locate
input files, and this can result in unreadable versions of files being
found before the one intended. In these conditions give the complete local
pathname for the file.
$add ?131
Error 131 occurs when a data files ends unexpectedly. This can happen when
using the commands READ,INPUT etc. if the original file was incorrectly
written or is in the wrong format.
$add ?132
Error 132 means that a command which requires a title for a picture was
unable to locate one.
$add ?133
Error 133 means that a program name had some invalid characters in it.
The normal valid characters are a-z,0-9 and $.
$add ?134
Error 134 means that the local Semper i/o system has run out of file
handles. This is usually caused by opening excessive numbers of files.
$add ?135
Error 135 occurs when a command that outputs a file finds that the file
already exists. In general these commands will take an option NEW to allow
the file to be overwritten, or an option OLD to allow the file to be re-used.
The OLD option should also be used for write-only files or devices (such as
printers).
$add ?136
Error 136 means that a filename has been incorrectly specified. Check for
overlong names or invalid characters.
$add ?137
Error 137 means that an internal buffer has overflowed while trying to
construct a file name. Possible causes include:
 (1) An error in the specification of the PATH in the local environment
 (2) The current directory being at the end of a very long chain
 (3) The user specifying a very long file name component
If (2) or (3) can not be avoided please submit a Report Form.
$add ?138
Error 138 means that the range, text, class and form combination used in a
directory examine did not find a match.
$add ?139
Error 139 means that an immediate command, such as TEXTFIELD EXECUTE, has
caused the delayed command line buffer to overflow. The usual cause of
this error is a user written routine making excessive use of the Semper
function OBEYCL without returning to the command interpreter.
$add ?140
Error 140 indicates that the required security device is missing or
inoperable. Check that the device has not been accidently removed.
$add ?141
Error 141 indicates that the security device does not match the software
release. Check that the correct device is connected.
$add ?142 ?143 ?144
This error indicates a security problem (security device malfunction or
violation, too many users, out of date etc.). If you can not locate the
source of the problem please submit a Report Form or contact your technical
support service.
$add ?145
This error indicates a syntax error in the command syntax file. There is more
than one open statement referring to the specified LP number. Modify the
syntax entry and rebuild Semper.
$add ?146
This error indicates a syntax error in the command syntax file. An open
statement for a new image references an unopened LP in the comparison field.
(e.g. open(lp2,new,lp1) where there is no open for LP1).
Modify the syntax entry and rebuild Semper.
$add ?147
This error should not normally happen in Semper. It is a less severe form
of error 52, and indicates that one or more crucial fields in an existing
picture 'label' have corrupt values. The first corrupt field found and the
erroneous value are reported in the error message. As with error 52 the
only really useful response is to delete the picture.
$add ?148
This error indicates an attempt to write a picture 'label' that has one or
more crucial fields with values that are out of range (e.g. dimensions with
zero size, invalid picture form). This can happen when attempting to import
external data files that are in the wrong format or which have an incorrectly
produced Semper label in them. If this is the case the image may still be
recoverable by identifying the field Semper is complaining about (given in
the error message) and correcting the value - either by correcting the
program sourcing the file or by patching the file with a suitable text or
disc editing utility.
$add ?149
Error 149 indicates an attempt to write a totally corrupt picture 'label' to
disc. This can happen when attempting to import external data files that are
in the wrong format. It can also happen when user written code overwrites
the label data before writing it out to disc.
$add ?150
Error 150 means that there are too many particles intersected by a picture
row. This could be caused by too much noise in the source image. Some
additional processing to clean up the source image or adjustment of the
threshold values given to Analyse might help to reduce the number of spurious
particles. If, however, all the particles are genuine, the last resort is to
break down the source image into several smaller pictures.
$add ?151
Error 151 means that the particle parameter list is not big enough to hold
the results for all the particles found by Analyse. The size of the particle
parameter list is limited by the row buffer size.
The AREA key can be used to screen out particles less than a certain size.
Analyse can also be made to output the results for only those particles which
fall within a specified sub-region of the source picture (using the 2-D
sub-region keys when invoking Analyse).
$add ?152
This error is not used - please submit a Report Form if it occurs.
$add ?153
Error 153 will occur if a byte-formatted segmented picture is requested and
there is too much detail in the source image. No more than 255 particles can
be recorded in a byte-formatted segmented picture. Depending on the
complexity of the particles, this limit may be lower during the scan through
the source image.
$add ?154
Error 154 means that a negative pixel value has been encountered in a
segmented picture. A segmented picture should only contain zero (background)
and positive (particle id) pixel values.
$add ?155
Error 155 means that the specified particle id was not found in the particle
parameter list.
$add ?156
Error 156 means that the coordinate limits of the curve supplied to Pcurve
exceed the range -32000 to 32000.
$add ?157
Error 157 means that the operation to be carried out with the specified
display picture requires that a 2-D image be displayed.
$add ?158
Error 158 means that none of the particles described in the particle parameter
list satisfy the constraints given by the IF and UNLESS keys.
$add ?159
Error 159 means that there were no pixel positions generated inside the
specified closed curve. This means that results that depend on summing values
at all the pixel positions, e.g. total intensity, are not defined.
$add ?160
Error 160 means that there are no pixels in the segmented picture set to the
specified particle id.
$add ?161
Error 161 is an internal error that indicates problems in the low level
event interface routines. If the error persists please submit a Report Form.
$add ?162
Error 162 means that a command that expects a list of devices (e.g. ORDER)
has found a particular device used more than once in the list.
$add ?163
Error 163 means that a command that requires an active lookup table (e.g.
LUT KEYS) did not find one.
$add ?164
Error 164 means that the command CTF with the option WAVE was given a half
plane Fourier picture as a source.
$add ?165
Error 165 means that a call to a kernel function (e.g. SEMROW) has been made
with an LP number that is out of the valid range 1 to NLPS.
This usually indicates an error in locally written code. For instance passing
the wrong variable as the LP number.
$add ?166
Error 166 means that a call to a kernel function (e.g. SEMROW) has been made
with an LP number that does not refer to an open picture.
This usually indicates an error in locally written code. For instance passing
the wrong variable as the LP number or failing to open a picture before
accessing it. Check that any implicit OPENs that the local code expects are
present in the command descriptor.
$add ?167 ?168 ?169 ?170
This error is not used - please submit a Report Form if it occurs.
$add ?171 ?172 ?173 ?174 ?175 ?176 ?177 ?178 ?179 ?180
This error is not used - please submit a Report Form if it occurs.
$add ?181 ?182 ?183 ?184 ?185 ?186 ?187 ?188 ?189 ?190
This error is not used - please submit a Report Form if it occurs.
$add ?191
This error is not used - please submit a Report Form if it occurs.
$add ?192 ?193
This error is not used - please submit a Report Form if it occurs.
$add ?194 ?195 ?196 ?197 ?198 ?199
This error is not used - please submit a Report Form if it occurs.
$add ?250
You should not normally get this error but you might get it when
performing operations on elements with ENO set incorrectly.
$add ?251
Error 251 means that you have issued a user interface command
before giving the 'UIF ENABLE' command. This command sets up
various internal variables.
$add ?252
Error 252 means that that there are too many windows. A window is
a panel - so you are using too many panels. There are a fixed
number of panels available; use the 'UIF STATUS' command to find
what the number is. In future systems other objects may be
introduced which will also be windows.
$add ?253
Error 253 means that that there are too many panels. There are a
fixed number of panels available; use the 'UIF STATUS' command to
find out what the number is. Don't forget that pulldown and popup
menus use up (hidden) panels.
$add ?254
Reserved for future use.
$add ?255
Error 255 means that that there are too many cells. There are a
fixed number of cells available; use the 'UIF STATUS' command to
find out what the number is.
$add ?256
Error 256 means that that there are too many menus. There are a
fixed number of menus available; use the 'UIF STATUS' command to
find out what the number is.
$add ?257
Error 257 means that that there are too many textfields. There
are a fixed number of textfields available; use the 'UIF STATUS'
command to find out what the number is.
$add ?258
Error 258 means that you tried to do something with a panel when
it was visible. This may be because of:
     * attempt to add a new element to the panel
     * attempt to alter any of the characteristics of the panel
$add ?259
Reserved for future systems.
$add ?260
 Operation cannot be performed while panel is not showing
$add ?261
Error 261 occurs when the user interface system is setting a
variable value. This is most likely if you have used too many
variables (try UNSETting some of them). If not, this indicates an
internal error which should be reported to Synoptics.
$add ?262
Error 262. An internal error, please report this to Synoptics.
$add ?263
Error 263. An internal error, please report this to Synoptics.
$add ?264
Error 264. An internal error, please report this to Synoptics.
$add ?265
Error 265. An internal error, please report this to Synoptics.
$add ?266
Error 266. An internal error, please report this to Synoptics.
$add ?267
Error 267. An internal error, please report this to Synoptics.
$add ?268
Error 268. An internal error, please report this to Synoptics.
$add ?269
Error 269. An internal error, please report this to Synoptics.
$add ?270
Error 270. An internal error, please report this to Synoptics.
$add ?271
Error 271. An internal error, please report this to Synoptics.
$add ?272
Error 272. An internal error, please report this to Synoptics.
$add ?273
Error 273 means that the panel is too big to display on the
device (framestore/host screen) or the panel is located outside
the display limits. Very often, this is because JUSTIFICATION is
not set correctly.
$add ?274
Error 274 means that an attempt was made to move the panel
outside the device limits.
$add ?275
Error 275. An internal error, please report this to Synoptics.
$add ?276
Error 276. An internal error, please report this to Synoptics.
$add ?277
Error 277. An internal error, please report this to Synoptics.
$add ?278
Error 278 means that a mandatory panel is showing but you tried
to perform some other user interface related action, for example
showing another panel or popping up a menu. Remember that when a
mandatory panel is showing interactions are only allowed with it
or elements on it.
$add ?279
Error 279 means that you have used an identifier for a panel
which the user interface system knows nothing about. Are
you specifying the ID key?
$add ?280
Error 280. Reserved for future use.
$add ?281
Error 281. Reserved for future use.
$add ?282
Error 282 means that an attempt has been made to position the
panel outside the limits of the device (framestore/host
display).
$add ?283
Error 283. An internal error, please report this to Synoptics.
$add ?284
Error 284 means that the user interface system was unable to
initialise. Have you already initialised the system?
$add ?285
Error 285 means that an attempt was made to use an unknown device
for a panel. Is the variable CDI set correctly - it should be 0,
1 or 2 only.
$add ?286
Error 286. An internal error, please report this to Synoptics.
$add ?287
Error 287. An internal error, please report this to Synoptics.
$add ?288
Error 288 means that the element specified (menu, cell,
textfield) was too big or was badly positioned on its panel.
$add ?289
Error 289 means that you have used an identifier for a cell which
the user interface system knows nothing about. Have you passed
the right value with the ID key? Is ENO set correctly? Have you
omitted the CREATE option?
$add ?290
Error 290. An internal error, please report this to Synoptics.
$add ?291
Error 291 means that you have used an identifier for a textfield
which the user interface system knows nothing about. Have you
passed the right value with the ID key? Is ENO set correctly?
Have you omitted the CREATE option?
$add ?292
Error 292 means that you have given an incorrect length for a
textfield. Textfield lengths should be greater than zero (0) and
less than the amount of (dynamic) memory available.
$add ?293
Error 293. Reserved for future use.
$add ?294
Error 294. Reserved for future use.
$add ?295
Error 295. Reserved for future use.
$add ?296
Error 296 means that Semper was unable to convert the string
given into a number.
$add ?297
Error 291 means that you have used an identifier for a menu which
the user interface system knows nothing about. Have you passed
the right value with the ID key? Is ENO set correctly? Have you
omitted the CREATE option?
$add ?298
Error 298. An internal error, please report this to Synoptics.
$add ?299
Error 299. An internal error, please report this to Synoptics.
$add ?300
Error 300. An internal error, please report this to Synoptics.
$add ?301
Error 301 means that the string that you specified for an action
is too long to fit into Semper's command line buffer. An action
might be the BEGINS action on a cell, or the click of a LEFT
mouse button or the execution of a textfield. Try breaking the
command down into smaller parts.
$add ?302
Error 302 means that while the user interface system was
$add ?303
Error 303. An internal error, please report this to Synoptics.
$add ?304
Error 304. An internal error, please report this to Synoptics.
$add ?305
Error 305. An internal error, please report this to Synoptics.
$add ?306
Error 306 means that 'DEVICE RESTORE' has been used before
'DEVICE SAVE' has been used (or RESTORE has been used more times
than were SAVEd!).
$add ?307
Error 307 means that too many 'DEVICE SAVE' commands have been
issued. The cursor position stack is of a fixed size, typically
about four (4). Have you omitted to restore a position somewhere?
$add ?308
Error 308. An internal error, please report this to Synoptics.
$add ?309
Error 309. An internal error, please report this to Synoptics.
$add ?310
Error 310. An internal error, please report this to Synoptics.
$add ?311
Error 311. An internal error, please report this to Synoptics.
$add ?312
Error 312. An internal error, please report this to Synoptics.
$add ?313
Error 313 means that all the memory reserved for storing names of
objects (panels, elements), actions, etc. has been used. 'UIF
STATUS' will show how much you have left. The amount of memory
available is fixed and installation dependent.
$add ?314
Error 314. An internal error, please report this to Synoptics.
$add ?315
Error 315. An internal error, please report this to Synoptics.
$add ?316
Error 316 means that you have tried to show a panel on a display
that has not been ASSIGNed yet.
$add ?317
Error 317. An internal error, please report this to Synoptics.
$add ?318
Error 318. An internal error, please report this to Synoptics.
$add ?319 ?320 ?321 ?322 ?323 ?324 ?325
This error is not used - please submit a Report Form if it occurs.
$add ?326 ?327 ?328 ?329 ?330 ?331 ?332
This error is not used - please submit a Report Form if it occurs.
$add ?333
UIF is not installed in this system and you have tried to use a UIF facility
or command. The Semper system is either a BlackBox version of Semper, or has
had the User InterFace code explicitly removed to reduce code size and memory
requirements. Note that it is not possible to run the TUTOR interface without
having UIF in Semper.
$add ?334 ?335 ?336 ?337 ?338 ?339 ?340
This error is not used - please submit a Report Form if it occurs.
$add ?500
Error 500. Source and covariance sizes differ
The number of layers of source picture must correspond with the number of
columns of the covariance matrix.
$add ?501
Error 501. Too many classification regions
The number of classification regions which may be processed by the
classification commands (BOX, MINDISTANCE and LIKELIHOOD) is dependent on the
length of a Semper row buffer. The more layers a picture has the fewer
classification regions it may have.
$add ?502
Error 502. Too many layers
The number of layers which can be processed by the classification commands
depends on both the length of a Semper row buffer and on how wide the picture
is. The wider a picture is, the fewer layers it may have.
$add ?503
Error 503. Threshold must be in the range 0.0 to 100.0
Thresholds to the LIKELIHOOD command, maximum likelihood, are given in terms
of percentages. The percentage gives the number of pixels in the class which
will be classified. For this reason the percentage must be less than 100.0.
$add ?504
Error 504. Not enough thresholds
When more than one threshold is given there must be as many thresholds as
classes.
$add ?505
Error 505. Probabilities must be positive, less than 1.0
Probabilities must be in the range 0.0 (never) to 1.0 (always).
$add ?506
Error 506. Sum of probabilities greater than 1.0
The sum of probabilities for all classes (in the LIKELIHOOD command must sum
to less than 1.0.
$add ?507
Error 507. Too many channels: maximum (square) is n
In order to achieve a respectable performance the 2-D histogram is built up
in memory. As with other commands this is proportional to the length of a
Semper row buffer.
$add ?508
Error 508. Thresholds must be positive
Since thresholds are in terms of standard deviations it is not sensible to
give negative thresholds.
$add ?509
Error 509. Unable to calculate eigenmatrix
The maximum iteration count was reached in calculating the eigenvectors.
This should not arise with covariance matrices calculated with the COVAR
command. If the covariance matrix has been determined by some other method
is it symmetric as the solution (Jacobi's method) relies upon this.
$add ?510
Error 510. Invalid polynomial order: largest is n
The maximum order polynomial is restricted by the (implementation dependent)
size of a Semper row buffer. Obviously the polynomial order must be greater
than zero.
$add ?511
Error 511. Control points must be position lists
The control points must be supplied in plist class pictures (perhaps use the
RECLASS command to do this).
$add ?512
Error 512. Image and map plists must be the same length
The map and image plists (control points) must be of the same length: WARP is
not in a position to decide which points match with which otherwise.
$add ?513
Error 513. Too many control points: maximum is n
Due to implementation restrictions, the Semper row buffer length, the WARP
command can only handle a certain number of control points. This should, in
normal circumstances, be sufficient to solve the maximum order of polynomial
allowed. Use the CUT command to reduce the size of the list.
$add ?514
Error 514. Not enough control points (or singular set)
When solving the equations for the coefficients not enough points were in the
control data set to solve the equations. Alternatively, the set of equations
is ill-conditioned that it has not proved possible to solve them. Try adding
more control points.
$add ?515
Error 515. Number of classes and probabilities disagree
The number of probabilities given must be the same as the number of classes.
$add ?516
Error 516. Class has zero determinant - no inverse possible
The covariance matrix is singular and it is not possible to evaluate its
inverse. This, in turn, means that the maximum likelihood method cannot be
used.
$add ?900
Error 900. Non-specific error generated by a user-supplied command
In general, any non-standard errors generated by routines not supplied by
Synoptics should be in the range 900 to 949.
$add ?997
Error 997. Quit option was selected in response to the page prompt
Strictly speaking this is not an error in that it generates no error message
or traceback and diagnostic information, but it is a condition which will
cause commands and programs to abort. For this reason, it can be trapped like
a normal error. Note that this condition can be disabled by using the PAGE
NOQUIT command to disable the quit facility.
$add ?998
Error 998. Non-specific internal Semper error
This is an error you should hopefully never come across. It is used to flag
obscure problems that may occur at a lower level within Semper. If you should
encounter one of these errors, make a note of the information it reports and
then get in touch with Synoptics.
$add ?999
Error 999. Fatal error - Semper cannot continue and will shut itself down
If for any reason Semper encounters an error which means that it cannot in any
way continue with the session, it will report this fact with error 999, e.g.
if Semper can no longer read commands from the terminal. As soon as the error
is reported Semper will try to finish in an orderly fashion, as if you had
type the command STOP. If you should encounter this error, make a note of the
information it reports and then get in touch with Synoptics.
$add event.command event keyboard pointer buttons
The EVENT command provides command level access to the internal Semper event
queues.  The command allows Semper programs to open, close, check, read and
flush the keyboard, pointer and button (switch) queues.

Exx. EVENT OPEN POINTER
       Opens the pointer queue
     EVENT COUNT KEYBOARD
       Returns the number of outstanding key presses in variable NK
     EVENT READ FLUSH KEYBOARD
       Reads the first key press into variable N and flushes the rest
$
The EVENT command provides access to most of the facilities available by means
of the Semper event queue mechanism.

The options KEYBOARD, BUTTONS and POINTER are used to select the queue(s)
required.  Apart from OPEN, READ and CLOSE, the action if no queues are
specified is to use all of them.

The option BREAK is used to select the break/abandon queue.  The only actions
allowed are to CLOSE (switch off) or OPEN (switch on) event handling on this
queue.  This can be used to protect critical code sections from abandon
requests.

The option COUNT returns the number of entries in the specified queues.  The
values for the keyboard, pointer and button queues are returned in the
variables NK, NP and NB respectively.

The option READ is used to extract an entry from the head of the specified
queues.  The values returned depend on the queue being read:

  The keyboard queue returns the key code in the variable N.  If the queue is
  empty the value returned is -1.

  The pointer queue returns the incremental X and Y changes in DX and DY.  If
  the queue is empty the values returned are 0,0.

  The button queue returns the number of the button closed (or zero if it is a
  button open event) in the variable NBC, the number of the button opened (or
  zero if it is a button close event) in the variable NBO and the bit packed
  button state in the variable NBB.  If the queue is empty NBC and NBO are
  both returned as zero.

The options OPEN and CLOSE are used to switch queues on and off.

The option FLUSH removes all the entries from the specified queue.

The option STATUS examines the state of the specified queues, returning the
value 0 if the queue is closed, 1 otherwise.  The values for the keyboard,
pointer and button queues are returned in the variables NKQ, NPQ and NBQ
respectively.  In addition, if the option VERIFY is set, the queue state,
current length and maximum length are written to the console output.


Example:   Invert the current look up table every half second until the user
           presses a mouse button or a key on the keyboard

  ! Read the current state of the queues
  EVENT STATUS KEYBOARD BUTTONS
  ! Open those that we need
  UNLESS NKQ EVENT OPEN KEYBOARD; UNLESS NBQ EVENT OPEN BUTTONS
  ! Loop with test
  L: LUT INVERT; WAIT .5; EVENT COUNT KEYBOARD BUTTONS; IF (NB+NK)=0 JUMP L
  ! Flush the relevant queue
  IF NK>0 EVENT FLUSH KEYBOARD; IF NB>0 EVENT FLUSH BUTTONS
  ! Reset the queue states
  UNLESS NKQ EVENT CLOSE KEYBOARD; UNLESS NBQ EVENT CLOSE BUTTONS

Opening and closing queues should be done with great care, as it is possible
to hang a session if all input queues are closed.  To be safe, the above
example should either use TRAP statements to catch abandon requests, or should
be bracketed with EVENT BREAK CLOSE ... EVENT BREAK OPEN

See also:  event.syntax, keycodes
$add event.syntax

Options:
  KEYBOARD       select the Keyboard event queue
  BUTTONS        select the Buttons/Switches event queue
  POINTER        select the Pointer event queue
  BREAK          select the Break event queue (only with OPEN and CLOSE)
  CLOSE | OPEN   close or open the selected queue(s)
  COUNT          return the number of entries in the selected queue(s)
  READ           return the first entry from the selected queue(s)
  FLUSH          empty the selected queue(s)
  STATUS         obtain status information about the selected queue(s)
  VERIFY         if STATUS set, print the queue status information

Variables set:
  N              keycode (see KEYCODES)
  NBO,NBC,NBB    button status
  DX,DY          pointer movement
  NKQ,NPQ,NBQ    open/close state of keyboard/pointer/button queue
  NK,NP,NB       current length of keyboard/pointer/button queue

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add examine.command examine directory inspect
You use EXAMINE to examine what pictures are stored on your various devices,
and what their size, class, form, title etc. is.

Exx: EXAMINE
       types the standard set of details for the current picture
     EXAMINE DISPLAY FULL
       types full details for the current display picture
     EXAMINE ALL BRIEF
       types one-line details for all pictures on the current device CD
     EXAMINE DEVICE 4
       types details of all pictures on device 4
     EXAMINE 50,60
       types details for any pictures in the range 50 to 60
     EXAMINE FOURIER
       types details of any Fourier pictures on the current device
     EXAMINE COMPLEX DEVICE 4
       types details of any Complex pictures on device 4
     EXAMINE TEXT 'eels'         (or @FIND 'eels')
       types details of any pictures on the current device whose title
       includes the string 'eels'
$
The standard set of details consists of the picture number, size, class, form
and title, and the letters 'wp' if the picture is write-protected.  The brief
form omits the title; the FULL form includes the data range, the creation
date, the coordinate origin (as column, row and layer numbers relative to the
left, top and back), and device-specific details such as the disc blocks
occupied, the display black-white levels etc.

ALL is assumed if you quote a class name, form name, or TEXT without an
explicit range of picture numbers, or if you specify the DEVICE key.

See also: examine.syntax
$add examine.syntax
Keys:
  [(2)]          single picture or range of pictures to be examined
                 [SELECT,SELECT]
  DEVICE         device on which picture are to be examined
  TEXT text      examine only pictures whose title contains the specified text

Options:
  FULL | BRIEF   print details in more or less detail than standard form
  ALL            examine all pictures on the current device
  IMAGE|MACRO|FOURIER|SPECTRUM|CORRELATION|UNDEFINED|WALSH|HISTOGRAM|PLIST|LUT
                 examine only pictures of the class given
  BYTE | INTEGER | FP | COMPLEX   examine only pictures of the form given
  LIST | CURVE   if PLIST set, examine only position lists or curves
  OPEN | CLOSED  if PLIST CURVE set, examine only open or closed curves

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add execute.command execute
The command EXECUTE defines  the  actions  to  be   carried   out
immediately before and after a Semper command is executed.

Examples:

     EXECUTE BEFORE 'TYPE ''About to execute command'''
     would type out the message 'About to execute command'  every
     time   Semper goes to the user interface system  for  input.
     This will NOT occur during the execution of library files.
$
If EXECUTE is used more than once, the actions  are  accumulated,
not  overwritten.   If  several commands are entered on one  line
using  ';',  the  action will be executed before  and  after  the
entire sequence, not before each element in the string.

See also: execute.syntax
$add execute.syntax
Keys:
  AFTER text     The given string is set to be executed after every Semper
                 command execution.
  BEFORE text    The given string is set to be executed before every Semper
                 command execution.

Options:
  OFF            'Before and after command' processing is disabled; the
                 actions currently set remain defined, and will become active
                 again when ENABLE is used.
  ON             'Before and after command' processing is enabled (default).

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add extract.command extract regions subregions section
You use EXTRACT to sample pictures in various ways.  You can extract
rectangular, rotated or skewed regions of a picture.  Here a regular grid of
sample positions is generated in terms of the parameters that define the
region of interest.  If the sample points go outside the source picture, they
wrap-around.  All this allows you to rotate or transpose images, to repeat
images in periodic arrays, etc.  The WITH key allows you to go even further by
letting you supply all the sample positions in a position list.  The output
values at each of the sample positions are normally arrived at using bi-linear
interpolation but you have the option to use nearest-neighbour extraction
(NNEIGHBOUR option) or bicubic interpolation (BICUBIC option).

Exx: EXTRACT SIZE 100 TOP LEFT TO 2
       extracts a 100 square region top left to picture 2 (like CUT)
     EXTRACT SIZE 512 DISPLAY
       repeats a small current picture periodically on the display
     EXTRACT 1 2 SIZE 128 SAMPLING 2 AVERAGE
       averages (the central 256 square of) picture 1 in 2 by 2 blocks to form
       a 128 square picture 2
     EXTRACT TO DISPLAY SIZE 100 SAMPLING .75 POSITION X,Y
       interpolates a region 75 points square centred at X,Y to form a
       100 square display
     EXTRACT TO 50 SIZE 300,1 ANGLE PI/4 POSITION X,Y; DISPLAY
       displays a diagonal line scan through X,Y
     XWIRES CURVE SAMPLING 1; EXTRACT 1 2 WITH 999 NNEIGHBOUR
       extracts evenly spaced samples from picture 1, along an arbitrary curve
       drawn with the cursor, using nearest-neighbour extraction
     U=U/64,U2/64 V=V/64,V2/64; EXTRACT SIZE 64 UV
       extracts a single unit cell of a periodic image with lattice base
       vectors U,V
$
In some circumstances, EXTRACT cannot operate with identical source and output
picture numbers.  In that case, you should specify a different number for the
output picture.

EXTRACT inevitably looks rather complicated.  Its basic action is to extract
(using bilinear interpolation if necessary) a region established first via the
standard 2-D subregion keys/options, and then expanded by SAMPLING and rotated
(anticlockwise) by ANGLE; neither POSITION nor SAMPLING need be integral.
Should the region specified overflow the source picture boundary, the source
picture is treated as continuing periodically in both directions.

The EXTRACT WITH  mode provides for arbitrary geometric transformation;
given a Plist as WITH, it generates an output picture with the same column and
row length as the Plist, but with each position replaced by a value
interpolated from the source picture at that position.  For example,
   CREATE 3 PLIST SIZE 360,50,2
   ORIGIN BOTTOM LEFT
   CALCULATE IFELSE(Z,Y*SIN(RAD(X)),Y*COS(RAD(X)))
   EXTRACT 50 TO 51 WITH 3
resamples picture 50 on a radial polar grid (radius 0-49, angle 0-359deg).

The UV option causes EXTRACT to distort the extracted region so that the
vector (U,U2) defined by the current value of the variables becomes one point
to the right in the output and (V,V2) one point upwards; SAMPLING and ANGLE
are ignored in these circumstances.  If the VERIFY option is used, the
components of the lattice vectors are listed on the console.

The AVERAGE mode can be applied only when undersampling without interpolation;
it may be useful for preserving the original signal-to-noise ratio.  The
blocks averaged, exceptionally, have the top left rather than centre at the
nominal sampling position, which allows you (for example) to reduce a 2N
square picture to a N square without an additional POSITION adjustment.

EXTRACT normally generates output pixel values by using bi-linear
interpolation between the four neighbouring source pixels.  If you specify the
option NNEIGHBOUR, the value of the nearest neighbouring source pixel is taken
as the output value.  If you use the BICUBIC option, the output pixel values
are generated by using bi-cubic interpolation between the 4 by 4 array of
source pixels that surround each sample position.  Roughly speaking, nearest
neighbour extraction is twice as fast as bi-linear interpolation and bi-cubic
interpolation is twice as slow.  Nearest neighbour extraction is useful when
it is necessary to avoid the artefacts caused by the interpolation process.
Bi-cubic interpolation avoids the sharp discontinuities of intensity gradient
which become more apparent when using bi-linear interpolation in conjunction
very small sampling intervals (high magnification).

While the generality of EXTRACT is useful, you will find it slow for large
pictures if the rows to be extracted lie at large angles to those of the
source; large angle rotations are usually better performed via ROTATE (even if
you have to extract a larger region initially than you ultimately want).

If the source picture origin is included in the extracted region, it is
recorded as the origin of the output (rounded to the nearest pixel); this does
not apply to the EXTRACT WITH mode, however.

If the MARK key is set, the limits of the region extracted is marked on the
indicated display picture, unless the WITH key is used, in which case all the
sample points are marked.

                            Display marking: region extracted or sample points
                       Multi-layer pictures: all layers processed
                      Forms used internally: integer,fp,complex

See also: extract.syntax
$add extract.syntax
Keys:
  [FROM]         source picture [SELECT]
  [TO]           output picture [FROM]
  SIZE(2)        size of subregion to be extracted [whole picture]
  POSITION(2)    position/offset of subregion [0,0]
  SAMPLING       sampling interval within subregion [1]
  ANGLE          angle through which subregion is rotated anticlockwise [0]
  WITH           Plist picture listing source positions at which output
                 samples are required; alternative to all keys/options
                 other than FROM,TO
  MARK           display to be marked with border indicating region extracted
                 or sample points used (WITH key set) [none]
  MKMODE         mark mode [1]
  MKSIZE         mark size [2]

Options:
  LEFT | RIGHT   extract subregion abutting indicated border
  BOTTOM | TOP
  NNEIGHBOUR | BICUBIC  use nearest nearest neighbour extraction | bicubic
                 interpolation [use bilinear interpolation]
  UV             extract samples on lattice defined by U,U2 and V,V2
  AVERAGE        (with integer SAMPLING values) average source samples over
                 undersampled regions
  VERIFY         list on the console the components of the lattice vectors

Variables used:
  U,U2,V,V2      if UV, base vectors defining the size and shape of a skewed
                 region

See SUBREGIONS for more details of subregion keys/options.

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add expand.command expand resampling resample non-square pixels
EXPAND horizontally resamples pictures, allowing you to compensate for the
distortion that is introduced by framestores with non-square pixels.
Typically these framestores are North American systems that are being used
with European camera signals.

Exx:
    EXPAND DISPLAY TO 2 RATIO 2,3
      expand the current display to picture 2, resampling assuming that
      the ratio of source to output sampling rate is 2:3.
    EXPAND 1 TO DISPLAY RATIO 6,5 NNEIGHBOUR
      expand picture 1 directly to the current display picture with a ratio of
      6:5, using the nearest neighbour pixel value instead of interpolating.
$
The EXPAND command performs horizontal resampling for any pair of positive
integer ratio values specified with the RATIO key.  The processing is most
efficient for small ratio values.  Any common factors are divided out first to
ensure that the smallest pair of ratio values for a given sampling factor are
used.  It is possible to resample using the command EXTRACT UV, but this will
tend to be slower for the ratios most commonly used.

For a standard (CCIR) camera input a sampling rate of 15MHz is required.  Most
North American (EIA or NTSC) frame-grabbers sample at 10MHz or 12.5MHz
requiring ratios of 2:3 (10MHz:15MHz) and 5:6 (12.5MHz:15MHz) for resampling
images.

The new pixel values are generated by interpolation, unless the NNEIGHBOUR
option is specified, in which case the values of the nearest pixels in the
source image are used.

EXPAND, in the first place, is intended to be used with pictures that have
just been acquired.  It will only process the real part of complex pictures.

                                    Multi-layer pictures: all layers processed
                                   Forms used internally: integer,fp

See also: expand.syntax extract
$add expand.syntax
Keys:
  [FROM]         source picture [SELECT]
  [TO]           output picture [FROM]
  RATIO(2)       required resampling ratio

Options:
  NNEIGHBOUR     use nearest neighbour instead of interpolating

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add find.command find highest lowest cm centreofmass
FIND locates the highest point, lowest point or centre of mass of a picture
or circular subregion, returning its coordinates as X,Y and the pixel value
or mass as T.

Exx: FIND 51
       finds the highest point in picture 51, and sets X,Y to its coordinates
     FIND LOWEST RADIUS 35 POSITION X,Y
       finds the lowest point of the current picture within 35 pixels of X,Y
     XWIRES CIRCLE; FIND CM @CIRCLE NONEGATIVE
       finds the centre of mass of a circular region indicated with the cursor
       (via three perimeter points), ignoring negative source pixels
$
Two additional options are relevant to the c.m. mode:  SQUARED causes source
pixels to be squared before the c.m. is found, and ITERATED causes the c.m.
determination to be iterated once with the second region being centred at the
c.m. of the first - this can be useful for locating the c.m. of a signal on
a large background which otherwise dominates the centre of mass completely.

If the MARK key is set, the resulting position is marked on the indicated
display picture, and if a circular subregion is used (RADIUS key is set), the
circle indicating the limits of the subregion are also marked.

                   Display marking: position found, circular subregion scanned
              Multi-layer pictures: faulted
             Forms used internally: fp

See also: find.syntax
$add find.syntax
Keys:
  [FROM]        picture to be searched [SELECT]
  POSITION(2)   centre of circular region to be searched [0,0]
  RADIUS        radius of circular region to be searched [infinite]
  MARK          display to be marked with resulting position and border
                indicating circular subregion (only if RADIUS key set) [none]
  MKMODE        mark mode [1]
  MKSIZE        mark size [2]

Options:
  HIGHEST|LOWEST|CM   find highest point, lowest point or centre of mass
                      [HIGHEST]
  NEGATIVE      if CM, include negative pixels in search [YES]
  SQUARED       if CM, find c.m. of squared pixels
  ITERATED      if CM, repeat the c.m. location once, with a region shifted
                so as to be centred at the c.m. found initially
  VERIFY        list on the console the results of the search

Variables set:
  X,Y           coordinates of point selected
  T             picture value at selected point, or mass if CM

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add fir.command fir smooth laplaceans gaussians kernels
You use FIR to apply FIR filters (small block convolution operators), which
replace each pixel by a weighted average of its neighbours.  You define the
kernel (weights) in a small subsidiary picture, or use standard forms
generated internally by FIR.

Exx: FIR 1 TO 2 WITH 51
       produces a picture 2 by applying the kernel in picture 51 to picture 1
     FIR LAPLACEAN SUBTRACT TO DISPLAY
       displays a sharpened version of the current picture
     FIR LAPLACEAN MODULUS
       obtains the magnitude of the laplacean of the current picture - one
       (rather noise sensitive) form of edge operator
     FIR DISPLAY GAUSSIAN RADIUS 2
       smooths the picture DISPLAY
     CREATE 90 SIZE 5,1; P -2=1,2,3,2,1; FIR 1 WITH 90 SEPARABLE
       defines a 1-D smoothing kernel and applies it to picture 1 in X and Y
       directions independently
$
Kernels need not be square, and may be up to 21 points wide; for large kernels
you may well find it faster to effect the convolution by multiplying the
Fourier transform of the source picture by that of the kernel (embedded in a
zero picture of the same size).

Three routes may be used for defining a kernel:
  - you may supply one in a picture indicated by WITH; if you define an
    asymmetric kernel, remember that each point of the source is replaced not
    by the kernel but by the kernel rotated 180 degrees.
  - you may use option GAUSSIAN, which generates a square kernel of the form
    exp{-d^2/(2.RADIUS^2)} for distance d from the centre, truncated beyond
    exp(-1) with a minimum size of 3, and normalised to a unit sum (which
    preserves the source mean); the kernel is in fact separated for speed.
  - you may use option LAPLACEAN, which invokes a fixed kernel
             (1/4) ( 1   2   1 )
                   ( 2 -12   2 )      or  (1 -2  1)  for 1-D source pictures
                   ( 1   2   1 )

If your kernel has the form k(x,y)=p(x)p(y), i.e. separates into identical X
and Y factors, you will find execution is faster if you supply the separated
form only and use option SEPARABLE: the last example above, involving a 1-D
kernel (1 2 3 2 1), applies an equivalent kernel
                   ( 1  2  3  2  1 )
                   ( 2  4  6  4  2 )
                   ( 3  6  9  3  1 )
                   ( 2  4  6  4  2 )
                   ( 1  2  3  2  1 )

With each kernel, you may specify ADD or SUBTRACT, which causes the filter
output to be added to, or subtracted from, the original picture, as in the
second example; this is effected in most cases simply by adjustment of the
supplied kernel without additional computation.

While any size kernel up to 21 square is acceptable, specially efficient code
is included for square, horizontal or vertical 3- and 5- point kernels (i.e.
5x5, 5x1, 1x5, 3x3, 3x1 and 1x3 kernels).  Edge pixels are treated as if the
edge pixels of the source continued indefinitely outwards.

                          Multi-layer pictures: layers processed independently
                          Form used internally: fp

See also: fir.syntax
$add fir.syntax
Keys:
  [FROM]         source picture [SELECT]
  [TO]           output picture [FROM]
  WITH           if GAUSSIAN or LAPLACIAN not set, picture containing filter
                 kernel
  RADIUS         if GAUSSIAN set, rms kernel radius [1]

Options:
  ADD | SUBTRACT filter output added to/subtracted from source
                 [output filtered result]
  MODULUS        output modulus (absolute value) of result
  SEPARABLE      apply (1-D) kernel separately in X and Y directions
  GAUSSIAN | LAPLACEAN   use gaussian profile smoothing kernel, or 3x3 point
                 laplacean kernel

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add fit.command fit background level ramp slope remove
You use FIT to fit a linear ('ramp') function to a picture, and to subtract it
or divide by it so as to level background variations from one side of a
picture to another.

Exx: FIT
       fits a ramp Ax+By+C to the current picture
     FIT DISPLAY NOCONSTANT SUBTRACT
       subtracts a fitted ramp Ax+By from the display (omitting the constant
       term keeps the data range within that accommodated by the display)
     FIT 50 DIVIDE TO 51 FP
       divides picture 50 by a fitted ramp ax+by+c, forcing the output class
       to be FP since the value will be spread either side of 1.

The fitted ramp coefficients are returned in variables A, B and C.
$
FIT begins by using a least squares fit criterion to fit the coefficients of a
linear function Ax+By+C to the source picture (Ax+C for a 1-D picture), with x
and y being picture coordinates.  If you use option SUBTRACT, it produces an
output picture by subtracting the fitted ramp from the source; if you use
DIVIDE, it divides by it; the subtraction is done before the division if you
ask for both.  Forcing option CONSTANT to NO causes the constant term C to be
omitted from the ramp subtracted and/or divided, and is useful as in the
second example for levelling up a background without shifting the entire data
range.

The 'right' way of correcting an image for background variations depends on
how the variations have arisen and what is sought.  You divide when your image
has the form I.t (e.g. uneven illumination I on a scene with reflectivity or
transmissivity t); you subtract and divide when it has the form I.(1+t) (e.g.
similar illumination with small variations t about 1 in reflectivity or
transmissivity; or an image whose local contrast t - fractional intensity
deviation - you need to extract); and you subtract when it has the form I+t
(e.g. additional stray light I entering a camera).  Subtracting is a useful
'ad hoc' expedient when an exact model for the imaging is not available or too
complicated.

If you need to compensate for more than the linear part of the variation, try
using LMEAN over a large block size to obtain the background function itself
and then CALCULATE to subtract/divide it as you wish.

                                                 Multi-layer pictures: faulted
                                                 Form used internally: fp

See also: fit.syntax
$add fit.syntax
Keys:
  [FROM]         source picture [SELECT]
  [TO]           output picture [FROM]

Options:
  SUBTRACT       subtract fitted ramp from source
  DIVIDE         divide source by fitted ramp (after SUBTRACT if set)
  CONSTANT       omit constant from ramp subtracted/divided [YES]

Variables set:
  A,B,C          coefficients of ramp Ax+By+C fitted; C not set if NOCONSTANT

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add flc.command flc averaging average
FLC allows you to perform lattice averaging by the transform peak profile
fitting method; it fits lattice (fourier) components to the isolated peaks
found in the transform of a periodic image discommensurate with the sampling
lattice.

Exx: FLC POSITION 52.6,20.9
       given a half-plane Fourier current picture, fits a transform peak at
       the indicated position, returning the component value as T,T2
     U=20.3,2.5 V=1.2,16.8; FLC LINE 3,-1
       fits the peak with indices 3,-1 on the lattice defined by U and V
     FOURIER 1; U=..,.. V=..,..; FLC TO 2 SIZE 65,128; IMAGE
       transforms picture 1, fits all sites on the lattice defined by U and V,
       and recovers a single unit cell of the image; U and V might be fitted
       more accurately via XWIRES LIST; LIBRARY LATTICE; BASE 999 after
       displaying the power spectrum (PS)
$
The Fourier transform of a 2-D periodic image consists of an array of isolated
peaks at positions forming a lattice reciprocal to the real space lattice;
unless the signal periodicity is exactly commensurate (an exact multiple of)
the sampling lattice in both directions however, the peaks fall between the
transform sample values and (ideally) have a crossed sinc profile.  FLC allows
you to recover the peak values by fitting the samples.

If you indicate no output picture, one peak only is fitted and its value is
returned in the variables T,T2.  You can indicated the position to be fitted
either directly as in the first example or via lattice indices as in the
second.  The source must be a half-plane Fourier picture, as is any output
produced as in the last example.

If you do indicate an output picture, then all sites on the lattice defined by
U and V are fitted, and the resulting values are stored in an output picture
(half-plane Fourier, 17x32 in size or whatever other SIZE you specify); you
can exclude peaks beyond a cut-off radius from the origin via a key RADIUS).
Pixel (h,k) receives the value for the site with indices (h,k) etc. so that on
inverse transformation the output yields one unit cell of the structure,
sampled on a lattice exactly subdividing the unit cell; normal cartesian
(square) sampling can be restored via EXTRACT UV.. (you use LIBRARY RECIPROCAL
and LIBRARY INVERT in turn to convert the Fourier plane base vectors U,V to
suitable values for EXTRACT).

Option VERIFY causes details of the fitting process to be reported; the
following steps are carried out for each peak fitted:
   (i) the mean noise intensity is estimated from the peripheral values of an
       8 point square region around the peak;
  (ii) the signal intensity is estimated via the integrated intensity in a 2
       point square region, with the estimated noise intensity subtracted;
 (iii) if the resulting signal to noise intensity ratio is less than 3 (or the
       value of the key SNR), the peak is discarded (with a warning message in
       the single peak modes);
  (iv) a simple estimate of the lattice Fourier component is made by combining
       a modulus given by the square root of the estimated singal intensity
       with a phase given by the phase of the average of the 4 points around
       the peak position (2 or 1 points as necessary if one or both of the
       peak coordinates is in fact integral).

If you use option WIENER, two further steps are carried out:
   (v) the ideal crossed sinc profile values are generated for a 4 point
       square region and a better value for the lattice component is obtained
       from the corresponding data samples d via an expression of the form
          t = sum(s.d) / [ sum(s.s) + nu / <|t|^2> ]
       in which nu denotes the mean noise intensity as estimated earlier, and
       <|t|^2> the expected signal intensity, estimated via an initial
       evaluation with nu set to zero; and
  (vi) the extent to which the local data conform to the expected crossed sinc
       profile is assessed via a Chi-squared difference between predicted and
       actual transform values, for report on the console.
The WIENER mode should not be used if the periodic signal does not fill the
original Image field entirely, if the periodicity is imperfect so that the
peak profiles are distorted, or if the reciprocal lattice is not accurately
known; if all these conditions are fulfilled however, it provides a more
reliable estimate of the lattice Fourier component.

If the MARK key is set, the fitted sites are marked on the indicated display
picture.
                                                 Display marking: sites fitted
                                            Multi-layer pictures: faulted
                                            Form used internally: complex

See also: flc.syntax
$add flc.syntax
Keys:
  [FROM]         source picture [SELECT]
  TO             output picture, fitting all peaks [none]
  SIZE(2)        output picture dimensions [17,32]
  RADIUS         maximum radius (in pixels) considered in all-peaks mode
  POSITION(2) | LINE(2)  position of single peak to be fitted, either in
                 picture coords or in terms of base vectors U(2) and V(2)
  SNR            threshold intensity signal-to-noise ratio below which
                 peaks are discounted [3]
  MARK           display to be marked with positions of fitted sites [none]
  MKMODE         mark mode [1]
  MKSIZE         mark size [2]

Options:
  WIENER         perform Wiener-optimisised least squares peak fit
  VERIFY         report on the console the results of the fitting process

Variables used:
  U(2),V(2)      Fourier space lattice base vectors when peak position is
                 indicated via LINE
Variables set:
  T(2)           Real,imaginary parts of fitted Fourier component (single
                 peak modes)

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add flood.command flood seed point fill foreground connectivity path
You use the FLOOD command to flood foreground and/or background regions
defined in the binary source image.  A flooded region is any region which
contains one or more seed points.  The output picture will contain a binary
image in which pixels corresponding to flooded regions are set to 1 and
everything else is set to 0.  You can specify a single seed point with the
POSITION key.  Multiple seed points can also be supplied in a Semper picture
by means of the WITH key, either in the form of a position list or as a binary
image in which the foreground pixels define the seed points.  The FG and BG
options specify whether to flood foreground or background regions (or both).
By default, only foreground regions are flooded.

Exx: FLOOD POSITION 20,30
       removes all foreground regions in the current picture except the one
       which includes the pixel at position (20,30)
     FLOOD 1 WITH 2 TO 3 BG
       floods the background regions of picture 1 which overlap foreground
       regions of picture 2 and outputs the result to picture 3
     DISPLAY 2:4; XWIRES LIST NOVERIFY; FLOOD 2:4 WITH 999 TO 2:5 FG BG;
     CALCULATE IFELSE(2:5,~2:4,2:4) TO 2:5; DISPLAY 2:5
       allows you to point with the cursor to any set of connected regions
       (foreground and/or background) in picture 2:4 and invert the selected
       regions
$
The FLOOD command has a number of uses:

(1)  It provides a general seed point filling facility

(2)  It allows you to add or remove connected regions in a binary image simply
     by pointing to them (see last example above)

(3)  It allows you to explore the connectivity relationships between regions

The source picture is treated as a binary image: zero values denote background
pixels and non-zero values denote foreground pixels.  Background pixels are
always treated as being 4-connected, that is, two background pixels are
4-connected only if they are either horizontally or vertically adjacent to
each other.  Foreground pixels are treated as being 8-connected, that is, two
foreground pixels are 8-connected if they are in any way adjacent.

Because of the difference in the way foreground and background pixels are
connected, the result of labelling the foreground regions of an image can be
quite different from the result of labelling the background regions of the
negated version of the same image.  For example,

      Source image               FLOOD FG

    0 0 0 1 1 1 1 1 1        0 0 0 1 1 1 1 1 1
    0 1 1 0 0 0 1 0 1        0 1 1 0 0 0 1 0 1
    0 1 1[0]1 1 0 0 1        0 1 1 0 1 1 0 0 1
    0 0 0 0[1]1 0 1 1        0 0 0 0 1 1 0 1 1
    0 0 0 1 1[0]0 1 1        0 0 0 1 1 0 0 1 1
    0 0 1 1 0 0 1 0 0        0 0 1 1 0 0 1 0 0
    0 0 1 1 1 1 0 0 0        0 0 1 1 1 1 0 0 0

         NEGATE                  FLOOD BG

    1 1 1 0 0 0 0 0 0        0 0 0 0 0 0 0 0 0
    1 0 0 1 1 1 0 1 0        0 0 0 0 0 0 0 0 0
    1 0 0[1]0 0 1 1 0        0 0 0 0 1 1 0 0 0
    1 1 1 1[0]0 1 0 0        0 0 0 0 1 1 0 0 0
    1 1 1 0 0[1]1 0 0        0 0 0 1 1 0 0 0 0
    1 1 0 0 1 1 0 1 1        0 0 1 1 0 0 0 0 0
    1 1 0 0 0 0 1 1 1        0 0 1 1 1 1 0 0 0

    where [ ] = seed points

The seed picture is specified by means of the WITH key.  If the seed picture
is a binary image, it must have the same size as the source picture.  If the
seed picture is a position list, any positions that fall outside the limits of
the source picture are ignored.  The positions are rounded to the nearest
source pixel position.  The seed positions are used to generate a temporary,
byte seed image with the same size as the source picture.

Likewise, if the single seed point position specified with the POSITION key
falls outside the source picture, it is ignored, otherwise it is rounded to
the nearest source pixel position.

If no valid seed points have been specified or if none of the seed points are
contained within any of the regions that are allowed to be flooded, a blank
image is output (all pixels are set to zero).

The FLOOD command produces the image containing the flooded regions in two or
more passes through the data (two passes except for very detailed images).
The results of the first pass are output to a temporary, integer form, disc
picture with the same dimensions as the source picture.  The final result is a
binary image which is always output to a picture of byte form.

The range of the final result is stored in the output picture label.

See also: flood.syntax
$add flood.syntax
Keys:
  [FROM]         source picure [SELECT]
  [TO]           destination picture [FROM]
  POSITION(2)    single seed point position [none]
  WITH           seed picture (binary image or position list) [none]

Options:
  FG             flood foreground regions [YES]
  BG             flood background regions [NO]

If the WITH key specifies a position list, a temporary seed picture is
created.

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add flush.command flush cache disc buffers
Most Semper installations buffer part of the disc files in main memory for
speed, and only update the actual files periodically (whenever their
directories are altered, for example).  There is a certain risk of loss of
data attached to this however, since (except in VAX/VMS installations) the
buffers are not guaranteed to be returned to the disc files in the event of a
session abort.  You can type FLUSH to force the updating, guaranteeing your
data to date, whenever you feel nervous.

See also:  close
$add flush.syntax
Flush takes no arguments
$add for.command for loops repeats cycles iterations do
You can make Semper repeat a group of commands by surrounding them with a
FOR..LOOP pair:

Exx: FOR N=11,14; PS N TO N+10
         SECTION; SURVEY TYPE; LOOP; ..
       produces in pictures 21-24 rotational averages of the power spectra of
       pictures 11-14, and types their ranges
     FOR X 1,0,.25; TYPE X; LOOP
       types 1,.75,.5, .25 and 0 in turn on successive lines

If the step is omitted loops count forwards or backwards according to the
value of the initial and final values; the default step is 1 or -1 according
to the loop direction. If the start and end values are equal the loop will
be obeyed once. It is possible to have loops that are not obeyed at all:

     FOR N 1,5,-1; TYPE N; LOOP; TYPE 'DONE'

The standard command continuation mechanism (a + at the end of the line) is
perfectly acceptable within FOR loops; however FOR loops may extend over
several lines in any case, as in the first example.  If you are working
interactively, the terminal prompt reminds you about active loop(s), and there
is an installation-dependent maximum loop length (typically 1000 characters).
(The same limit applies in RUN programs, but not in LIBRARY programs).
$
The 'loop variable' (N and X in the above examples) is 'local' to the loop,
i.e. the original state/value is restored when the loop ends; you can reset
the loop variable within the loop, as the change is effective only until the
end of the current cycle.

You can 'nest' FOR loops (each with its own closing LOOP statement), up to an
installation-dependent maximum depth (typically six), and you can re-use the
same loop variable each time too if you wish since each use is local.  You may
name the loop in a LOOP command (e.g. LOOP N) if it makes your program
structure clearer to you.

NB: A special restriction applies to FOR loops in connection with numbered
macros (which will not be supported in later releases of Semper): loops are
not executed correctly in numbered macros which are themselves called from
programs.

See also: for.syntax, next, break, loop
$add for.syntax
FOR uses a special syntax:
   FOR variable [=] start_value,end_value[,step_val]

and requires a terminating LOOP command.
$add fourier.command fourier
You use FOURIER to calculate 1-D or 2-D discrete Fourier transforms of
pictures.  The X and Y dimensions of a picture must be a multiple of 4 and
'factorisable' (no factors other than 2, 3, 4 or 5).

Exx: FOURIER 1 TO 4
       transforms picture 1 to picture 4

To invert a transform and recover the image, you use the IMAGE command.

See also: fourier.general
$
For Byte, Integer and Fp source pictures, the output is a half-plane transform
(Fourier, Complex); for a Complex source, it is full-plane; you cannot force a
different output form.

The output cannot be sent directly to the display (FOURIER TO DISPLAY) because
of incompatible forms and/or ranges used during intermediate stages of the
transform calculation.
                         Restrictions: image sizes must be factorisable
                                     : unsuitable for direct output to display
                 Multi-layer pictures: faulted
                Forms used internally: fp,complex

See also: fourier.syntax
$add fourier.syntax
Keys:
  [FROM]         source picture [SELECT]
  [TO]           output picture [FROM]

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add fullplane.command fullplane
You use FULLPLANE to convert a half-plane Fourier or Spectrum picture into its
full-plane equivalent, using the (conjugate) symmetry of the pixels. The
command HALFPLANE does the opposite conversion.

Exx: FULLPLANE 2 3
       places the full plane equivalent of half-plane transform 2 in 3
     PS; FULLPLANE; DISPLAY
       displays the spectrum of the current picture in full-plane form
$
                                              Multi-layer pictures: faulted
                                             Forms used internally: fp,complex

See also: fullplane.syntax, halfplane
$add fullplane.syntax
Keys:
  [FROM]         source picture [SELECT]
  [TO]           output picture [FROM]

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add gaussian.command gaussian
You use GAUSSIAN to generate a picture containing a single gaussian-profile
peak at the origin, for test or other purposes.  The LORENTZIAN command
generates a similar lorentzian-profile picture.

Exx: GAUSSIAN SIZE 128,1
       replaces the current picture with a 128 point 1-D picture (form Fp),
       with a gaussian peak (rms width 16 pixels) at its origin
     GAUSSIAN TO 2 SIZE 40,40,40 RADIUS 5
       generates a 3-D gaussian of sectional rms width 5 pixels in picture 2
$
The function generated is exp(-(x^2)/(2*(r^2))), where x is distance from the
picture origin and r is the value specified with the RADIUS key.  Values below
exp(-7) are set explicitly to zero.

                                         Multi-layer pictures: fully supported
                                         Form used internally: fp

See also: gaussian.syntax, lorentzian
$add gaussian.syntax
Keys:
  [TO]           output picture [SELECT]
  SIZE(3)        dimensions of output [32,SIZE,1]
  RADIUS         rms width in section of function generated [SIZE/8]

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add halfplane.command halfplane
You use HALFPLANE to convert a full-plane Fourier or Spectrum picture into its
half-plane equivalent, discarding the left hand half-plane.  The command
FULLPLANE does the opposite conversion.

Exx: HALFPLANE 50 51
       places the right half-plane of picture 50 in 51
     FOURIER 1; FULLPLANE; DISPLAY; HALFPLANE; WEIGHT WITH.. IMAGE
       displays the transform of picture 1 in full-plane form before filtering
       it.
$
                                             Multi-layer pictures: faulted
                                            Forms used internally: fp,complex

See also: halfplane.syntax, fullplane
$add halfplane.syntax
Keys:
  [FROM]         source picture [SELECT]
  [TO]           output picture [FROM]

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add help.command help
HELP topic topic..  types brief information about given topic(s)
HELP/FULL topic     types extended form of information
HELP/HEADER topic   types header lines only of all relevant topics (useful
                    for survey purposes)

HELP/TOPICS          lists topic names of all help library entries
HELP/TOPICS/FULL     lists topic names with alias (alternative) names
HELP/TOPICS topic    lists topic names beginning with indicated name only

You can ask about several topics at once.  Topic names can be abbreviated,
e.g. H matches HELP, but all the letters you give are treated as significant
(i.e. LOGICAL does not match LOGFILE).  A full-stop causes matching to resume
after the next full stop in the topic name, e.g. D.S matches DISPLAY.SCALING.
Alternative names (aliases) are recorded for most topics.

If the message 'No help library assigned' appears, read the printed manuals
to find out how to use ASSIGN to assign one; at worst, you may find the SYNTAX
command, which lists the keys and options recognised with each command,
useful, and typing SHOW will allow you to find out about the current state
of your session.
$add hfill.command hfill hole fill foreground background
You use the HFILL command to fill the holes in the foreground or background
regions defined in a binary source image.  The output picture will contain a
binary image in which any region which is classed as a hole in the source
image is inverted.  The FG or BG option specifies whether to fill in holes in
foreground or background regions.  By default, only the holes in foreground
regions are filled.

Exx: HFILL
       fills the holes in the foreground regions of the current picture
     HFILL BG 2:1 DISPLAY
       fills the holes in the background regions of picture 2:1 and outputs
       the final result to the current display picture or partition
     HFILL BG 1 2; CALCULATE :1 & ~:2 TO 2
       deletes any regions touching the edges of picture 1 and leaves the
       result in picture 2
$
The source picture is treated as a binary image: zero values denote background
pixels and non-zero values denote foreground pixels.  Background pixels are
always treated as being 4-connected, that is, two background pixels are
4-connected if they are either horizontally or vertically adjacent to each
other.  Foreground pixels are treated as being 8-connected, that is, two
foreground pixels are 8-connected if they are in any way adjacent.

Because of the difference in the way foreground and background pixels are
connected, the result of filling the holes in the foreground regions of an
image can be quite different from the result obtained by negating the image,
filling the holes in the background regions and negating the end result.  For
example,

      Source image               HFILL FG               Output image

    0 0 0 1 0 0 1 1 0        0 0 0 1 0 0 1 1 0        0 0 0 1 0 0 1 1 0
    0 0 0 1 0 1 0 0 1        0 0 0 1 0 1 H H 1        0 0 0 1 0 1 1 1 1
    0 0 0 1 0 1 0 0 1        0 0 0 1 0 1 H H 1        0 0 0 1 0 1 1 1 1
    1 1 1 0 0 0 1 1 0        1 1 1 0 0 0 1 1 0        1 1 1 0 0 0 1 1 0
    0 0 0 0 0 0 0 0 0        0 0 0 0 0 0 0 0 0        0 0 0 0 0 0 0 0 0
    1 1 1 1 0 1 1 1 1        1 1 1 1 0 1 1 1 1        1 1 1 1 0 1 1 1 1
    1 0 0 1 0 1 0 0 0        1 H H 1 0 1 0 0 0        1 1 1 1 0 1 0 0 0
    1 0 0 1 0 1 0 0 0        1 H H 1 0 1 0 0 0        1 1 1 1 0 1 0 0 0
    1 1 1 1 0 1 0 0 0        1 1 1 1 0 1 0 0 0        1 1 1 1 0 1 0 0 0

          NEGATE                 HFILL BG                  NEGATE

    1 1 1 0 1 1 0 0 1        1 1 1 0 1 1 0 0 1        0 0 0 1 0 0 1 1 0
    1 1 1 0 1 0 1 1 0        1 1 1 0 1 0 1 1 0        0 0 0 1 0 1 0 0 1
    1 1 1 0 1 0 1 1 0        1 1 1 0 1 0 1 1 0        0 0 0 1 0 1 0 0 1
    0 0 0 1 1 1 0 0 1        0 0 0 1 1 1 0 0 1        1 1 1 0 0 0 1 1 0
    1 1 1 1 1 1 1 1 1        1 1 1 1 1 1 1 1 1        0 0 0 0 0 0 0 0 0
    0 0 0 0 1 0 0 0 0        0 0 0 0 1 0 0 0 0        1 1 1 1 0 1 1 1 1
    0 1 1 0 1 0 1 1 1        0 H H 0 1 0 1 1 1        1 1 1 1 0 1 0 0 0
    0 1 1 0 1 0 1 1 1        0 H H 0 1 0 1 1 1        1 1 1 1 0 1 0 0 0
    0 0 0 0 1 0 1 1 1        0 0 0 0 1 0 1 1 1        1 1 1 1 0 1 0 0 0

    where  H = region classed as a hole

A hole is a background or foreground region in the source picture which is
entirely surrounded by a foreground or background region (dependending on the
FG or BG option respectively), or, equivalently, a background region which is
not 4-connected to, or a foreground region which is not 8-connected to, any of
the edges of the source picture.

The HFILL command produces the hole-filled image in two or more passes through
the data (two passes except for very detailed images).  The results of the
first pass are output to a temporary, integer form, disc picture with the same
dimensions as the source picture.  The final result is a binary image which is
always output to a picture of byte form.

The range of the final result is stored in the output picture label.

See also: hfill.syntax
$add hfill.syntax
Keys:
  [FROM]         source picure [SELECT]
  [TO]           destination picture [FROM]

Options:
  FG | BG        fill holes in foreground or background regions [FG]

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add hilbert.command hilbert
You use HILBERT to calculate the discrete Hilbert transform of a picture,
adding it as an imaginary part to the picture so that its Fourier transform
vanishes over one half-plane.  The operations is useful in analysing images
formed by one-sided imaging systems.  The X dimension of the source picture
must be a power of 2.

Exx: HILBERT 1 2
       copies the real part of picture 1 to Complex 2, and adds the row by row
       Hilbert transform as an imaginary part; the Fourier transform of
       picture 2 vanishes over the left half-plane.
     HILBERT RIGHT NOZERO
       produces a picture whose Fourier transform vanishes over the right
       half-plane, and whose imaginary row means match the real row means
$
The addition of the Hilbert transforms as imaginary parts is effected row by
row, by suppressing one half of the row Fourier transforms (LEFT or RIGHT as
you request; LEFT in default); the output is Complex in default.  The
imaginary part of the row means (i.e. of the central Fourier component) are
set to zero unless ZERO is NO, in which the real part mean is copied across.

Hilbert transformation is convolution with 1/(pi.x), and is like different-
iation in the x direction, with a high-frequency de-emphasis.  Curiously,
the convolution uses alternate points only of the source; asserting LP causes
the inclusion in the row transform manipulation of an additional linear ramp
filter, falling from 1 at the centre to zero at the outside, which approx-
imates the convolution differently, and weights all source points equally.

                                   Restriction: image width must be power of 2
                          Multi-layer pictures: faulted
                          Form used internally: complex

See also: hilbert.syntax
$add hilbert.syntax
Keys:
  [FROM]         source picture [SELECT]
  [TO]           output picture [FROM]

Options:
  LEFT | RIGHT   half-plane over which transform vanishes [LEFT]
  ZERO           set imaginary part of central transform column to zero rather
                 than duplicate real part [YES]
  LP             apply 'low pass' linear ramp filter to transform rows

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add histogram.command histogram statistics median mode
You use HISTOGRAM to generate and/or display picture intensity histograms
(histograms of the pixel values), optionally from picture subregions.

Exx: XWIRES REGION; HISTOGRAM 4:23 @REGION
       displays a histogram of a region of 4:23 indicated with the cursor
     HISTOGRAM CHANNELS 100 TO 51
       puts a 100 channel histogram of the current picture in picture 51
     MIN=10 MAX=20; HISTOGRAM PRESET TYPE
       displays a histogram of pixels between 10 and 20 in the current picture
       on the console
$
The histogram is displayed in graphical form if you direct it to a display
partition, but is otherwise stored as a class Histogram picture, which you can
DISPLAY when you want to or use to effect histogram equalisation with MAP.  In
either case, the display is erased and/or lettered exactly as for DISPLAY.

You can obtain the histogram of (multi-layer) subregion only, by specifying
the subregion in the standard way.

Normally, HISTOGRAM finds the actual range of the data processed, (setting
variables MIN,MAX accordingly); however, an estimated range is used if you
abandon during a range-finding scan, and if PRESET the existing values of
MIN,MAX are used.  The histogram channels are then spread evenly over this
range; data outside the range are not counted.  Imaginary parts of complex
pixels are not distinguished from real parts for counting purposes.

If the range MAX-MIN lies in the range 20-256, it is used as a default for the
number of channels (otherwise 256); you may ask for any number (up to the
maximum row length for Fp pictures) via the key CHANNELS.

                                              Display marking: region scanned
                                         Multi-layer pictures: fully supported
                                        Forms used internally: fp,complex

See also: histogram.syntax
$add histogram.syntax
Keys:
  [FROM]         source picture [SELECT]
  [TO]           output picture [DISPLAY, in graphical form]
  CHANNELS       number of histogram channels [MAX-MIN if in range 20-256;
                 else 256]
  SIZE(3)        dimensions of subregion to be processed [whole picture]
  POSITION(3)    position/offset of subregion [0,0,0]
  LAYER(2)       range of layers in subregion [all unless SI3/PO3 set]
  HEIGHT         histogram height in framestore pixels [lesser of half
                 histogram width and half partition height]
  TIMES          integral display magnification factor [1]
  ASPECT         for character form displays, aspect ratio (no. columns/inch
                 divided by no. lines/inch) of character grid [default given
                 by PAGE command]
  WIDTH          for character form displays, the number of characters
                 per line [default given by PAGE command]

Options:
  PRESET         set histogram channel limits from MIN,MAX [lowest,highest
                 pixel values present used]
  LEFT | RIGHT
  BOTTOM | TOP   process subregion abutting indicated border
  NEAR | FAR
  REPEATING      repeat histogram counts when magnifying, instead of
                 interploating
  LETTER         letter partition top with picture number etc. [YES]
  BORDER         mark display border [YES]
  TYPE | LOG     histogram is output in character form on console or to log
                 output stream [picture is displayed on display device]

Keys HEIGHT,TIMES and options LETTER,BORDER,TYPE,LOG are relevant only if
the output is in graphical form (i.e. if it is displayed instead of stored).

Variables used:
  MIN,MAX        if PRESET, pixel range covered by histogram channels

Variables set:
  MIN,MAX        unless PRESET, pixel range within picture/region processed

See SUBREGIONS for more details of subregion keys/options.

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add hp.command hp levelling
HP provides a High-Pass filter that levels the local background throughout a
picture, retaining the high frequency (rapidly varying) detail only.  It
subtracts from each pixel the average value over a block of neighbouring
pixels (see the command LMEAN for more about local averaging).

Exx: HP TO 999; DISPLAY
       displays the fine detail in the current picture (detail with a period
       no larger than 5 pixels)
     HP OVER 100
       subtracts a local mean calculated over 100 square neighbourhoods
     HP 50 51 OVER 30 HORIZONTAL
       applies a horizontal 1-D form of the filter
$
You use the key OVER to specify the size of block over which the local average
is to be determined.  Local averages over horizontal or vertical 1-D strips
can be obtained if you use the option HORIZONTAL or VERTICAL.

The general form of the filter kernel will be clear from its value in the
particular case of OVER 3:

            (1/9) (-1  -1  -1)
                  (-1   8  -1)
                  (-1  -1  -1)

Edge pixels of the source - where the block averaged overflows the source -
are processed as if the boundary values were repeated indefinitely outwards.
When OVER is even, the source pixel replaced is rounded to the bottom right
from the block centre.
                                             Multi-layer pictures: faulted
                                            Forms used internally: fp,complex

See also: hp.syntax, lmean
$add hp.syntax
Keys:
  [FROM]         source picture [SELECT]
  [TO]           output picture [FROM]
  OVER           filter kernel size [5]

Options:
  HORIZONTAL | VERTICAL   apply 1-D horizontal filter (kernel size = OVER,1)
                 or 1-D vertical filter (kernal size = 1,OVER) [apply 2-D
                 square filter (kernel size = OVER,OVER)]

Note:
  Globally setting the VERIFY option will trigger the VERTICAL option for this
  command.

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add hplj.command hplj hewlett packard laser jet screendump hardcopy
With the HPLJ command, you can print pictures in Hewlett-Packard LaserJet+
format. Output is sent to a file, which should then be sent to the printer
using the appropriate local utility. As well as pictures (from any device),
you may print display partitions complete with their overlays.

Exx: HPLJ 4:3 DPI 75 NAME '75dpi.pic'
       prints picture 3 on device 4 at a resolution of 75 dots per inch to
       the file 75dpi.pic
     HPLJ PARTITION 4 NAME 'part4'
       prints display partition 4 (including overlays) to the file part4.hpl

Pictures/partitions being output may not exceed 512 points square; 512 points
wide is the maximum size that fits A4 paper.
$
HPLJ (Hewlett-Packard Laser-Jet) operates in two distinct modes: picture (the
default) and partition (when you specify the PARTITION option).

In picture mode, it dumps the picture indicated (irrespective of whether it is
a disc, tape or display picture), scaled to maximum contrast on the paper
unless you force a different scaling as in the last example.  Option NEGATED
reverses the contrast (as if MIN,MAX were interchanged).

In partition mode, the complete display partition is printed, and not simply
the region occupied by any picture stored in the partition, and any overlay
lines/lettering are merged with the data; you have no control of the grey
scaling except for option NEGATED.  If you want to dump a complete display
frame, simply declare a suitable partition, e.g. PARTITION 9 FRAME 1 and
apply HPLJ to this.

Fifteen distinct grey levels are achieved at each of 512x512 printed pixels.

Note that some printers may not have enough memory to print a full page at the
highest resolution. The resolution defaults to create the largest possible
image on the output paper. If images are required at a fixed resolution, the
DPI keyword allows the default to be overridden. Allowable values for DPI are
75, 100, 150 and 300. To print images with dimensions greater than 512 use the
EXTRACT command to sub-sample the image first.

The output file is specified using the NAME keyword.  If the file name is
specified without an extension, the default extension .hpl is used.  The file
must not already exist, unless one of the options OLD or NEW is quoted.
Option OLD specifies that an existing file should be re-used, option NEW will
delete any existing file of the same name.

See also:  hplj.syntax, extract
$add hplj.syntax
Keys:
  [ ]             if PARTITION option is set:
                     display partition number [DISPLAY]
                  otherwise:
                     source picture number [SELECT]
  DPI             dots per inch resolution to use
  NAME            file name for output

Options:
  PARTITION       source is a display partition
  NEGATED         reverse intensity scaling
  PRESET          use pre-defined intensity scaling (see MIN, MAX below)

  OLD             re-use an existing output file (used if output to device)
  NEW             overwrite an existing output file by deleting it

Variables used:
  MIN, MAX        if PRESET option is set:
                     source intensity levels to be printed as black and white

Variables set:
  MIN, MAX        if PRESET option is not set:
                     minimum and maximum source intensity levels

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add illumination reflectivity
For most purposes, you can safely allow SHEET and SOLID to use their default
illumination and surface reflectivity conditions; however, in case you do want
to change any of the details, the following information should help.

The illumination (keys LTHETA, LPHI, MAIN, FORWARD, AMBIENT): two directional
light sources, and one non-directional, are modelled.   The main source lies
in a direction inclined at an angle LTHETA to the +Z axis, with an X-Y azimuth
LPHI anticlockwise from the +X axis, (i.e. has spherical polar coordinates
R,LTHETA,LPHI); the defaults (LTHETA=pi/4, LPHI=0) place the light at your
right hand side.  As examples:
   SHEET .. LPHI PI
     generates an image lit from your left side rather than your right
   SHEET .. LPHI PI/2 LTHETA PI/2
     generates one lit from directly above.

The second source is fixed, and shines forward as you look; its function is to
provide some contrast on regions of the surface not illuminated by the main
source.  Keys MAIN and FORWARD allow you to control the 'brightness' of these
two sources; the defaults are 154 and 42.  Finally, additional non-
directional illumination with a brightness AMBIENT is included (default 40) -
so that points on the object always stand out from the background at least.

The surface brightness model (key DCONT): writing n for the direction of the
local surface normal, l for that of the main light source, e for your eye, and
m for the normal to a mirror reflecting the main light source into your eye
(m=l+e, in terms of vectors), the model used for the brightness of a given
point on the 3-D object surface is:
        AMBIENT               [isotropic ambient light]
      + MAIN.r(n,l,m)         [reflection of main source]
      + FORWARD.r(n,e,e)      [reflection of subsidiary forward source]
      + DCONT.Z/d             [depth contrast (perspective)]

The depth contrast term simply makes parts of the object further away from you
less bright; d denotes the range of Z values spanned by the 3-D box enclosing
the object, in the orientation in which you view it; DCONT has a default value
of 30, so that the output values will vary by up to 30 from back to front as a
result of this term alone.

The surface reflectivity (key SDR): the function r(n,l,m) above takes the form

    a.cos(n,l)                   [diffuse reflection; rough surface]
  + b.t*cos(n,m)/(1+t-cos(n,m))  [mirror reflection; polished surface]

with a=SDR/(1+SDR), b=1/(1+SDR) and t=0.03.  You can use SDR (the Specular to
Diffuse Ratio; default 0.4) to control how shiny the surface appears (what
proportion of it is microscopically smooth): SDR 0 models a perfectly rough
surface, and SDR 3 a highly polished one, for example.  The polished regions
have an angular distribution with a half width of about 10 degrees (root(t)
in radians).
$add image.command image inverse inversion
You use IMAGE to perform inverse Fourier or Walsh transforms - to regenerate
Images from their transforms.  Normalisation is included so that the sequences
FOURIER-IMAGE and WALSH-IMAGE recover the original values exactly.  For
inverse Fourier transforms the X and Y dimensions of a picture must be a
multiple of 4 and 'factorisable' (no factors other than 2, 3, 4 or 5).  Use
the command SHOW SIZES to list all the factorisable sizes.  If the source
picture is a half-plane Fourier image, the size restriction is applied with
respect to the output picture dimensions.  For inverse Walsh transforms the
picture dimensions must be a power of 2.

Exx: IMAGE 50 51
       recovers an Image picture 51 from a Fourier or Walsh picture 50
     IMAGE BYTE
       inverse transforms the current picture, leaving the result in Byte form
$
On inverse Fourier transformation, the default form for the output is Fp when
the transform is half-plane, and Complex otherwise.

          Restrictions: image sizes must be factorisable (inverse Fourier
                        transform) or a power of two (inverse Walsh transform)
                      : unsuitable for direct output to display
  Multi-layer pictures: faulted
 Forms used internally: fp,complex

See also: image.syntax, fourier, walsh, show
$add image.syntax
Keys:
  [FROM]         source picture [SELECT]
  [TO]           output picture [FROM]

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add inkey.command inkey
You can use the INKEY command to read individual keystrokes from the terminal
without waiting for the user to press a RETURN, and without any 'echo' on the
terminal screen.

Exx: INKEY N
       waits until the user presses a key, and sets N to the (decimal value
       of) the Ascii code for the key (e.g. pressing A sets N to 65)
     INKEY C1,C2,C3
       reads three keys in turn, returning their Ascii codes in variables
       C1-3
     INKEY
       waits until a key is pressed before continuing; the keystroke is
       discarded

See also: keycodes
$add input.command input read get files BMP TIFF
You use INPUT to read pictures created by Semper 6 on workstations or PCs
(using the OUTPUT command) or by other selected programs.

Exx: INPUT 5 NAME 'newdata'
       reads picture 5 from the Semper 6 file newdata.pic
     INPUT 125 RAW NAME 'binary' SIZE 512,512
       reads picture 125, of size 512 by 512 pixels from the raw binary
       file binary.bin
     INPUT 33 RAW INTEGER NAME 'mydata' SIZE 640,480 SWAP
       reads picture 33, of size 640 by 480 pixels as 16 bit integers with
       Motorola byte ordering from the file mydata.bin
     INPUT 1 RAW NAME 'special.pic' SIZE 128,128 SKIP 64
       reads picture 1, of size 128 by 128 pixels from the raw binary file
       special.pic, skipping the first 64 bytes of the file
     INPUT 1 RASTER NAME 'dump.rff' MAP 2
       reads SunRaster file dump.rff into picture 1, storing any colourmap
       information in picture 2
     INPUT 1 BMP NAME 'windows.bmp' MAP 2
       reads Windows BitMap file windows.bmp into picture 1, storing any
       colourmap information in picture 2
     INPUT 1 TIFF NAME 'macphoto.tif' MAP 2
       reads TIFF file macphoto.tif into picture 1, storing any colourmap
       information in picture 2
$
INPUT expects a Semper 6 data file unless one of the options BMP, RASTER, RAW
or TIFF are given.

If the option BMP is given, the input file is treated as a Windows BitMap
image file. Currently only files with 8 or 24 bits per pixel are accepted.
Only uncompressed images are supported (not RLE compression).

If the option RASTER is given, the input file is treated as a Sun Raster
image file. Currently only files with 8 bits per pixel are accepted. The
file packing types supported are the old and new unpacked types 0 (RT_OLD)
and 1 (RT_STANDARD), and also the byte encoded type 2 (RT_BYTE_ENCODED).

If the option RAW is given, a raw binary file is expected, of size given by
SIZE(3), with bytes starting with the top left pixel of layer 1, reading along
the row.

If the option TIFF is given, the input file is treated as a TIFF image file.
Both the Intel and Motorola packing orders are supported - most Apple
Macintosh packages produce the Motorola form, Windows packages the Intel form.
Currently only greyscale and RGB files with 8 bits per sample are accepted.
Only uncompressed images are supported (not LZW, PackBits or any other
compression scheme). Both planar and packed RGB images can be read.
Semper ignores Grey and Colour response correction curves, as these require
unsigned 16 bit pixels, which Semper does not directly support.
Any text fields found (e.g Author, Software, Manufacturer etc.) are reported
to the console output, as are any significant TIFF Tags that are not
supported. These messages can be suppressed using the NOVERIFY option.

If the keyword MAP is given with the options BMP, RASTER or TIFF it is
treated as a picture number in which to store any colourmap data present
in the file. This information can be used to remap the image data read in
using the Semper MAP or COLOUR commands. For instance, for a SunRaster image,
if the map data has 3 rows (RGB colormap) you can remap the original image
as follows:

      INPUT 1 RASTER NAME 'myfile.rff' MAP 2   ; ! read the data
      COLOUR 1 TO 3 WITH 2                     ; ! create the RGB image

The map information can also be used as a look-up table (LUT) if the LUT
length of the display system is 256 (use SHOW SYSTEM), but the image will
only be displayed with the correct false colours if the pixel range is not
rescaled (option NOSCALE to the DISPLAY command). For example:

      INPUT 1 BMP NAME 'windows.bmp' MAP 2      ; ! read the data
      LUT 1 FROM 2; PARTITION 1 LUT 1           ; ! prepare the LUT
      DISPLAY 1 TO DISPLAY:1 NOSCALE            ; ! display the palette image

The default extension for Semper 6 files is .pic, for Raster files is .rff,
for BitMap files .bmp, for TIFF files .tif and for raw binary is .bin.

The byte ordering for the Semper 6 data file is little-endian (Intel format).
Files written using the OUTPUT command on a PC can be read into a workstation
linked over a PC-NFS type network.

The depth of raw binary can be specified using the form options BYTE, INTEGER,
FP and COMPLEX. The SWAP option specifies that the binary data uses the
Motorola packing format. The SKIP keyword specifies the offset (in bytes) of
the start of the data - this is useful for skipping known size headers.

The AGAIN option can be used to read the last file again without having to
give a filename. (Provided no files have been written since). This option is
most useful in library procedures used to unpick foreign files formats, and is
generally used together with the RAW and SKIP options. For instance to read
a file MYSTYLE.BIN consisting of two 16 bit values giving the size and then
the raw data in bytes:

           INPUT 999 RAW NAME 'MYSTYLE' SIZE 2,1 INTEGER
           ORIGIN LEFT; DX = P(0); DY = P(1)
           INPUT 999 RAW AGAIN SIZE DX,DY BYTE SKIP 4

Files are searched for in the current directory and then throughout the
PATH (see FILEPATH and SHOW PATH). You can give a full path name to avoid
the path scan.

See also: input.syntax output read write colour
$add input.syntax
Keys:
  [TO]            picture to be read [SELECT]
  NAME text       name of file containing picture data  [none; prompts if
                  interactive unless AGAIN is given]

  SIZE(3)         specifies the size of a raw binary data image [none]

  SKIP            the byte offset of the start of the data within the file [0]

  MAP             picture to hold Sun Raster colormap data

Options:
  BMP             read an uncompressed Windows BitMap file
  RASTER          read a Sun Raster file
  RAW             read a raw binary data file
  TIFF            read an uncompressed TIFF file

  NOVERIFY        suppress informational messages (TIFF only)

  SWAP            read data in Motorola byte order (RAW only)

  AGAIN           use NAME given in last file read

  BYTE | INTEGER | read data as byte (8 bit), integer (16 bit), floating
  FP | COMPLEX     or complex

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add abandon
Press CTRL and C at the same time.

Note that if you type sufficient unacknowledged abandons to Semper the
Semper Break monitor will abandon the entire session.
$add cursor.movement cursor
Use the mouse - the mouse buttons can be used to enter xwires positions.
$add Semper startup setup
The simple command SEMPER will initiate an interactive session, with the
default allocations being used for all units.  The various units can be
re-assigned as desired via command parameters or qualifiers:

       SEMPER [-Qualifiers]
    or SEMPER [/Qualifiers]


Log files are opened dynamically by means of the Semper command ASSIGN FILE.

Qualifiers available are:

-run=file_name
  This qualifier is used to specify the name of the Semper run program
  file that is used as your startup commands.  The default extension
  is ".run" and the default file name is "semper.run". In any case the Shell
  PATH is searched for the file (this applies to all options).
  The qualifier can be entered as -norun  to override the use of the startup
  file.

-error=file_name
  This qualifier is used to specify the name of the Semper error message
  file.  The default extension is ".err" and the default file name is
  "semper.err".  Alternative error message files can be used for local
  variations or extensions, e.g. messages tailored for a particular
  application.

-par=n
  This qualifier is used to override the maximum number of display partitions
  available to the session. Each partition slot requires about 300 bytes of
  storage on the work disc. Users who require smaller work discs can reduce
  the number of available partitions. Users who need more than the default
  value can increase the number (up to the implied maximum of 999), but must
  be aware of the impact on work disc usage.

-luts=n
  This qualifier is used to override the maximum number of display lookup
  tables available to the session. Each LUT (typically) requires about 1500
  bytes of storage on the work disc. Users who require smaller work discs can
  reduce the number of available LUTs. Users who need more than the default
  value can increase the number (up to their local compile time maximum -
  usually about 100), but must be aware of the impact on work disc usage.

-monitor
  This qualifier enables all monitor output channels and turns on monitor
  output from the beginning of the Semper session so that any details
  concerning the starting-up of Semper can be monitored.

$add jump.command jump branch
The command JUMP NAME causes Semper to resume execution at the command
labelled NAME; labels are placed by prefixing a command with the label name
and a colon.

Ex: REPEAT: ...
    IF SD<.2 JUMP OK; TYPE 'Trying again'; JUMP REPEAT; OK: ..

When you are running interactively, the label must be within the current
command line; for a JUMP command in a program however, it may be anywhere
within the program.  You may not JUMP into the middle of a FOR loop, though
JUMPing out or within a loop is quite OK.

Note that only the first three characters of a label are significant.
$
Within a run file, Semper searches for the label within the current line
first, and then from the start of the file if necessary.

You should normally ensure that all labels within a program are unique.

Note that, unlike Semper 5, you are not allowed to JUMP to labels in
other programs.
$add justification.command justification
The command JUSTIFICATION defines which of nine  points   on  the
object is  used  to locate elements, panels etc.

Examples:
     JUSTIFICATION TOP RIGHT
     specifies that location is to be by the top right point.
$
By default all objects (cells, panels, etc.) are justified  about
their   centre   point.  The  JUSTIFICATION  command allows  this
positioning  method  to  be  altered.  Omitting  either  of   the
directions  (X or Y) implies CENTRE justification in the  omitted
direction.

             +-----------+-----------+------------+
             | Top       | Top       | Top        |
             | Left      |           | Right      |
             +-----------+-----------+------------+
             |           |           |            |
             | Left      |           | Right      |
             +-----------+-----------+------------+
             | Bottom    | Bottom    | Bottom     |
             | Left      |           | Right      |
             +-----------+-----------+------------+

See also: justification.syntax
$add justification.syntax
Options:
  LEFT | RIGHT   Specifies that location is by the left/right point.
  TOP  | BOTTOM  Specifies that location is by the top/bottom point.

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add keycodes internal character codes
When reading keystrokes directly from the keyboard (see commands INKEY and
EVENT) each one will be passed back as an integer character code.  Semper uses
the standard Ascii character sequence for its keycodes with a few additions to
cover special keystrokes like functions keys and cursor keys.

Printing Ascii codes:

  space 32      0   48      @   64      P   80      `   96      p  112
    !   33      1   49      A   65      Q   81      a   97      q  113
    "   34      2   50      B   66      R   82      b   98      r  114
    #   35      3   51      C   67      S   83      c   99      s  115
    $   36      4   52      D   68      T   84      d  100      t  116
    %   37      5   53      E   69      U   85      e  101      u  117
    &   38      6   54      F   70      V   86      f  102      v  118
    '   39      7   55      G   71      W   87      g  103      w  119
    (   40      8   56      H   72      X   88      h  104      x  120
    )   41      9   57      I   73      Y   89      i  105      y  121
    *   42      :   58      J   74      Z   90      j  106      z  122
    +   43      ;   59      K   75      [   91      k  107      {  123
    ,   44      <   60      L   76      \   92      l  108      |  124
    -   45      =   61      M   77      ]   93      m  109      }  125
    .   46      >   62      N   78      ^   94      n  110      ~  126
    /   47      ?   63      O   79      _   95      o  111

Special key codes:

    9   Tab
   13   Return
   27   Escape

  257   Backspace and delete character
  258   Delete line
  259   Insert/replace mode
  260   Start of line (home)
  261   End of line
  262   Refresh line

  513   Cursor up
  514   Cursor down
  515   Cursor left
  516   Cursor down

  768 - 1023   Function key = 768 + key number

See also: inkey, event, Semper 6 Fortran Programmers' Guide
$add label.command label foreground background connectivity path
You use the LABEL command to label separate foreground and/or background
regions defined in a binary source image.  Each region is assigned a unique,
integer number counting upwards from 1.  The output picture will contain an
image in which each pixel is set to the number assigned to the underlying
region, or zero, if the underlying region has not been labelled.  The FG and
BG options control whether foreground or background regions (or both) are
labelled in this way.  By default, only foreground regions are labelled.

Exx: LABEL
       labels all the foreground regions of the current picture
     LABEL 2:1 BG; SURVEY NOVERIFY; TYPE 'Number of objects = ',MAX
       labels all the background regions of picture 2:1 and types on the
       console the number of labelled regions
     LABEL 44 TO DISPLAY FG BG
       labels all the connected regions of picture 44 and outputs the final
       result to the current display picture or partition
$
The LABEL command has two particular uses:

(1)  It can be used as a quick way to count individual foreground regions

(2)  It enables you to determine whether there exists a connected path between
     any two pixels in an image (if they are, they will have the same label)

The source picture is treated as a binary image: zero values denote background
pixels and non-zero values denote foreground pixels.  Background pixels are
always treated as being 4-connected, that is, two background pixels are
4-connected only if they are either horizontally or vertically adjacent to
each other.  Foreground pixels are treated as being 8-connected, that is, two
foreground pixels are 8-connected if they are in any way adjacent.

Because of the difference in the way foreground and background pixels are
connected, the result of labelling the foreground regions of an image can be
quite different from the result of labelling the background regions of the
negated version of the same image.  For example,

      Source image               LABEL FG

    0 0 0 0 0 0 0 0 0        0 0 0 0 0 0 0 0 0
    0 1 1 0 1 1 0 0 0        0 1 1 0 2 2 0 0 0
    0 1 1 0 1 1 0 0 0        0 1 1 0 2 2 0 0 0
    0 0 0 0 0 0 1 0 0        0 0 0 0 0 0 2 0 0
    0 0 0 0 0 0 0 1 0        0 0 0 0 0 0 0 2 0
    0 0 0 0 0 0 0 0 0        0 0 0 0 0 0 0 0 0

         NEGATE                  LABEL BG

    1 1 1 1 1 1 1 1 1        0 0 0 0 0 0 0 0 0
    1 0 0 1 0 0 1 1 1        0 1 1 0 2 2 0 0 0
    1 0 0 1 0 0 1 1 1        0 1 1 0 2 2 0 0 0
    1 1 1 1 1 1 0 1 1        0 0 0 0 0 0 3 0 0
    1 1 1 1 1 1 1 0 1        0 0 0 0 0 0 0 4 0
    1 1 1 1 1 1 1 1 1        0 0 0 0 0 0 0 0 0

The LABEL command produces the labelled image in two or more passes through
the data (two passes except for very detailed images).  The results of the
first pass are output to an integer form picture with the same dimensions as
the source picture.  This will be the output picture itself unless the output
picture is a display picture, in which case a temporary disc picture is
created to hold the results of the first pass.

The range of the final result is stored in the output picture label.  This
means that the total number of labelled regions can be obtained by means of
the SURVEY command with no additional processing.  The range is limited by
the range of 16-bit integers which means that a maximum of 32767 separate
regions can be labelled (and therefore counted) in one image.

See also: label.syntax analyse
$add label.syntax
Keys:
  [FROM]         source picure [SELECT]
  [TO]           destination picture [FROM]

Options:
  FG             label foreground regions [YES]
  BG             label background regions [NO]

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add ladjust.command ladjust luts brightness contrast colour
The LADJUST command allows you to adjust interactively your current display
output look-up table, and to control brightness, contrast, and colouring of
the display.

Exx:
  LADJUST BRIGHTNESS CONTRAST
     Adjust the display brightness with the 'y' axis; contrast with 'x'.
  LADJUST RANGE 64,192 HUE SATURATION
     If viewing with a false colour lut, adjust the hue with the 'y' axis,
     saturation with 'x', over the central range of the lut.
  DISPLAY 2:55; LADJUST RANGE (MIN+MAX)/2,MAX SCALED DISPLAY HUE
     Adjust  the  hue  of the upper half of the look-up table  (RANGE  keys
     scaled to match the display scaling).
  LADJUST RANGE 120,130 POSITION WIDTH INITIALLY HSV 120,1,1
     Adjust the position ('x') and width ('y') of a 'highlight' band,  whose
     intensities are set initially to bright green.
  LADJUST BRIGHTNESS DBRIGHTNESS BLUE
     If viewing with a full colour lut, adjust the brightness and  contrast
     of its blue component only.

See also: ladjust.syntax, lset, lut
$
When adjusting the look-up table, you 'connect' one or more movement axes of
the  mouse  (or  cursor keys) to a parameter describing a  section  of  the
output look-up table.  For example, you might connect the 'x' axis  of  the
mouse  to  the brightness, and the 'y' axis of the mouse  to  the  contrast
(rate  of  change of brightness).  Then by moving the mouse,  you  set  the
output look-up table to achieve the effect you want.

If  you  are  working with a false colour output  look-up table,  you  can
control  the colour as well as the brightness associated with each  display
level.

You  can specify the range of display levels whose appearance you  wish  to
adjust directly.  Levels outside this range may remain fixed, or may adjust
themselves  so as to blend with those you are adjusting, according  to  the
keys you specify with the command.  You may also adjust  the  range itself,
to achieve thresholding or highlighting of an image.
$add ladjust.syntax
Keys:
  RANGE(2)       Specify the range of display levels you wish to adjust. The
                 range defaults to the total range of display levels supported
                 in the look-up table (often 0,255 or 0,127).  If SCALED is
                 quoted, these keys are scaled to match the black and white
                 levels of the display partition indicated.
  SCALED         Interpret the RANGE and RA2 keys in terms of the black and
                 white levels of the partition indicated by SCALED.
  END(2)         (Iff TIE option quoted) : If a parameter (brightness, hue,
                 saturation) is changed over the range RANGE,RA2 then this
                 parameter is set to ramp linearly between its current value
                 at END and the value at RANGE, and between RA2 and END2.
                 (The values RANGE,RA2 must lie entirely within END,EN2).
                 This facility is provided to let you adjust within RANGE,RA2
                 whilst the lut remains continuous over END,EN2. These keys
                 have the same defaults as RANGE,RA2 and can be scaled in the
                 same way.
  HSV(6)         (Iff INITIALLY option quoted) : Before adjustment begins,
                 sets the lut over (RANGE, RA2) to a linear ramp in hue,
                 saturation, and intensity between the limits given (hue and
                 saturation are ignored except for false colour luts). Hue is
                 specified in the range 0 to 360, saturation and intensity in
                 the range 0 to 1. [120,1,1,HSV,HS2,HS3 - initial colur bright
                 green/white, final colour same as initial colour]

Options:
  TIE            Use the END(2) keys to constrain the lut modifications.
  ALL | RED,GREEN,BLUE   For full colour luts, specifies the colour channels
                 to be modified [ALL]
  BRIGHTNESS     Vary the brightness of the pixels within the range.
  DBRIGHTNESS    Vary the rate of change of brightness within the range.
  CONTRAST       Synonym for DBRIGHTNESS.
  HUE            Vary the hue of the pixels within the range
  DHUE           Vary the rate of change of hue of the pixels within the
                 range.
  SATURATION     Vary the colour saturation of the pixels within the range.
  DSATURATION    Vary the rate of change of colour saturation.
  POSITION       Vary the position of the centre of the range
                 (i.e. (RANGE+RA2)/2)).
  DPOSITION      Vary the width of the range (i.e. (RA2-RANGE)).
  WIDTH          Synonym for DPOSITION.
  UPPER          Vary the bottom limit of the range (i.e. RANGE).
  LOWER          Vary the top limit of the range (i.e. RA2).
  INITIALLY      Set the lut over (RANGE, RA2) to the hue, saturation and
                 brightness specified by keys HSV(6). The effect is similar
                 to that achieved by using LSET before LADJUST except that it
                 is non-destructive, that is, if the position or width of the
                 range is changed within LADJUST the ORIGINAL lut is revealed.

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.

The above options cause parameters to be allocated to the movement axes as
follows:

     If only one option is specified, the parameter is allocated to the 'y'
     axis; the 'x' axis has no effect.

     If two or more options are specified, they are allocated first to  the
     'y'  axis, then to the 'x'.  The first to be selected is the first  in
     the following list, the second is the next to be found in the list:

               BRIGHTNESS, HUE, SATURATION;
               WIDTH (DPOSITION), POSITION, LOWER, UPPER;
               DBRIGHTNESS, DHUE, DSATURATION.

When the LADJUST command is active, pressing one of the following keys will
alter the variables attached to the mouse or cursor keys:

  R    Reset the variables currently under adjustment to their initial values
  ?    Print a report showing the variables currently under adjustment

  X    The following key defines the 'x' axis parameter
  Y    The following key defines the 'y' axis parameter

After either 'X' or 'Y' is pressed, one of the following should be used:

  D    The following character defines a 'rate-of-change' parameter

  B    Brightness
  H    Hue
  S    Saturation

  C    Contrast (also available as 'DB')

  L    Lower limit (initially RANGE)
  U    Upper limit (initially RA2)
  P    Position (centre of range, initially (RANGE+RA2)/2)
  W    Width of range (initially RA2-RANGE) (also available as 'DP')

  O    Turn off the adjustment

For example, the keystrokes 'XBYDB' would set 'x' to vary brightness, 'y' to
vary contrast.
$add lattice.command lattice grid
You can use LATTICE to mark grids/lattices on a display, or to create lists of
lattice sites in class Plist pictures.

Exx: LATTICE SPACING 20 MARK DIS
       marks a lattice with a spacing of 20 pixels throughout the current
       display
     U=19.3,24.5 V=-2.3,29.5 W=2.4,-5.1; LATTICE TO 1
       lists in picture 1 the sites of a lattice covering the area of DISPLAY,
       with the base vectors and origin given
     LATTICE FROM 6 TO 3 SIZE 256 BOTTOM LEFT RADIUS 150
       lists in 3 those sites of the lattice defined by U,V,W that lie within
       150 points of W,W2 and also in the indicated subregion of picture 6
$
In general, you define the lattice by setting U and V to its base vectors, and
W to the position of its origin (if this is not the picture origin), as in the
second example; alternatively, the key SPACING provides a quick way of
defining a square lattice (U=SPACING,0 V=0,SPACING W=0,0), mainly for marking
a coordinate grid on a display.

The field of view of the lattice generated is determined by that of a 'source'
picture, in one of two possible modes:
   (i) you can select a display picture, partition or frame exactly as for
       ERASE etc., with the field determined by that of the relevant
       coordinate system, e.g. LATTICE DIS
  (ii) you can give a more general source picture via an explicit FROM key,
       e.g. LATTICE FROM 6
In either case, you can use the standard 2-D subregion options/keys, and in
addition restrict the lattice to a given RADIUS of the origin W,W2 as in the
last example.

What is done with the lattice is determined by two independent keys, MARK and
TO.  If you use MARK, the lattice is marked on the indicated display; and if
you use TO, it is output to the indicated picture in the form of a Plist.
If you use neither, however, nothing useful is done at all.

In default, lattice marking takes the form of intersecting lines with short
gaps at the lattice sites; option SITES however makes it mark the individual
sites instead, in whatever form is determined by MKMODE and MKSIZE.

See also: lattice.syntax
$add lattice.syntax
Keys:
  []             picture, partition or frame number whose field of view is
                 covered by lattice
  [TO]           output Plist listing lattice sites [none]
  MARK           display picture to be marked [none]
  MKMODE         mark mode [1]
  MKSIZE         mark size [2]
  SIZE(2)        dimensions of subregion covered by lattice [whole picture]
  POSITION(2)    position/offset of subregion covered [0,0]
  RADIUS         maximum radius for lattice sites [infinite]
  SPACING        use lattice base vectors (SPACING,0), (0,SPACING) and offset
                 (0,0), instead of (U,U2), (V,V2) and (W,W2)

Options:
  PICTURE | PARTITION | FRAME | FROM  interpret [] as display picture,
                 partition or frame, or as entirely general picture number
                 [PICTURE]
  SITES          mark lattice as individual sites (in style determined by
                 MKMODE,MKSIZE) rather than as lines from site to site
  LEFT | RIGHT   subregion covered by lattice abuts indicated border
  BOTTOM | TOP

Variables used:
  U(2)           first base vector of lattice
  V(2)           second base vector of lattice
  W(2)           position (offset) of lattice origin

The combination of options with an omitted key [] allows PICTURE,PARTITION
etc. to appear as keys.  Note that you must quote either MARK or TO for
anything to be done at all.

See SUBREGIONS for more details of subregion keys/options.

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add learn.command learn training classification statistics
The LEARN command calculates the statistics of polygonal regions. These
statistics can the be used with the commands BOX, MINDISTANCE and LIKELIHOOD
to carry out supervised classification.

Exx: LEARN 1 20 DATA 10,11,12
       calculates the statistics of the polygonal regions enclosed by the
       curves described by the plists 10, 11 and 12, with the raw data being
       taken from picture 1 and the statistics being stored in picture 20
     LEARN 1 20 DATA 10,11,12 VERIFY
       as above but also output the number of pixels in each class to the
       console
     LEARN 2 20 DATA 10,11,12,13,14 CLASS 1,1,1,2,2
       calculates the statistics for two classes; the first defined in terms
       of 3 regions and the second in terms of two 2 regions
$
This command calculates the statistics of arbitrary
polygonal regions, the output of which is suitable for use by the
supervised classification commands.  The following statistics are calculated
for each region:

    Covariance matrix
    Mean and standard deviation
    Minimum and Maximum

The polygon, or `training region', describing the area for which these
statistics are calculated is described by a position list (plist) picture.
The region's statistics are stored in a separate layer of the output picture.
This picture's format is the same as that produced by the COVARIANCE command.
Up to nine polygons can be specified with the DATA key.  If more than nine
classes are required, the STACK command can be used to combine the results of
several LEARN commands.

By default, each region belongs to a separate class.  The CLASS key can be
given, which allows one class to be made up of more than one training region.
You must specify the same number of values for the CLASS key as for the DATA
key.  No further interpretation is placed on the CLASS key; it is only used by
this command to distinguish which region belongs to which class.  Classes can
be numbered from one up to the number of regions given to the LEARN command.

The number of pixels found in each class is given in the variables AREA, AR2,
AR3 .. AR9.  If the VERIFY option is specified, LEARN will output the number
of pixels that it finds in each class.  An asterisk "*" is output beside
classes which are unlikely to have enough data for the maximum likelihood
classification (the  number of pixels in the training region is less than ten
times the number of layers in the source picture). If statistics are
calculated from too small a training region, the covariance matrix is likely
to be singular (no inverse) and the maximum likelihood classification method
cannot be used.

The LEARN command has to estimate the maximum number of pixels in each region
in order to create a temporary picture.  This temporary picture contains the
pixels of an area whilst its statistics are calculated.  It is possible for
LEARN to fail if there is not enough space for the temporary picture.  LEARN
may also fail in the unlikely event that the maximum number of pixels is
estimated incorrectly.  A situation which is only likely to occur if very
long, thin horizontal training regions are used.

See also: learn.syntax, covariance, stack, box, mindistance, likelihood
$add learn.syntax
Keys:
  [FROM]         source picture [SELECT]
  [TO]           output picture containing the training statistics [none]
  DATA(9)        one or more plists describing training areas [none]
  CLASS(9)       class with which a training area is associated [each
                 training area is associated with a separate class]

Options:
  VERIFY         output to the console number of pixels found in each class

Variables set:
  AREA(9)        number of pixels found in each output class

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add letter.command letter
You use LETTER to add visible lettering at the bottom of a picture, or to
create a new picture containing nothing but the text (for PASTing into other
pictures). [If you simply want to write in a display overlay instead, try MARK
TEXT.]

Exx: LETTER 1 TEXT 'Fish-eye view of woodland growth'
       adds the lettering below the bottom of picture 1
     LETTER 1 TO 2 TITLE
       takes the lettering from the picture title, and puts the lettered
       result in picture 2
     LETTER FG 0 BG 255; PASTE TO 5 BOTTOM RIGHT
     Text (as textstring): 'Plate ',n
       places a small block of black on white lettering ('Plate' and the value
       of variable n) in picture 999, and pastes it into 5 at the bottom right
$
Keys BG and FG control background' and 'foreground' values for the pixels
making up the lettering; they default to MIN and MAX respectively.   If you
indicate no source, as in the last example, the default output is 999.

When you have no source picture, you can specify the output row length via a
key SIZE; if the lettering is too wide, it is split into more than one line
as necessary (at spaces wherever possible).   In default, SIZE is made just
large enough to accommodate the lettering (with a border at least pixel wide),
up to the maximum row length for your installation.

                                      Multi-layer pictures: faulted
                                     Forms used internally: integer,fp,complex

See also: letter.syntax
$add letter.syntax
Keys:
  [FROM]         source picture [none]
  [TO]           output picture [FROM if set; otherwise 999]
  TEXT text      text of lettering to be generated [none; prompts if
                 interactive]
  SIZE           row length of output, if no source [min. nec.]
  FG             'foreground' value used in lettering [MAX]
  BG             'background' value used in lettering [MIN]

Options:
  TITLE          take text from source picture title

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add library.command library
A LIBRARY command makes Semper execute a given program from the beginning
until a RETURN command or the end.  (See PROGRAMS for general information
about indirect command execution.)
Ex: LIBRARY PARTITIONS
      executes the (standard) program PARTITIONS, which defines partitions
      subdividing a display frame with arbitrary numbers of rows and columns.

Unusually for Semper, all the letters of the program name are considered
significant, and not simply the first three.  You can use several LIBRARY
commands in a single line, include them in FOR loops, nest calls freely, and
so on.
See also: library.syntax
$add library.syntax
LIBRARY uses a special syntax:
   The entry on the command line is taken as a single text string. Note that
   all characters in the string are significant.
$add likelihood.command likelihood classification maximum.likelihood
The LIKELIHOOD command classifies a picture using the maximum likelihood
method.

Exx: LIKELIHOOD 1 2 WITH 3
       classify picture 1 to picture 2 using the training data in picture 3
     LIKELIHOOD 1 2 WITH 3 PROBABILITY .1,.05,.50
       as above but assign a priori probabilities to the three classes
     LIKELIHOOD 1 2 WITH 3 THRESHOLD 90
       same as thr first example but assign a threshold of 90% to each class
       (90% of pixels within each class will be classified)
$
This command performs a maximum likelihood classification of the source image
based upon the statistics given in the picture specified with the WITH key.
This picture can be generated by the LEARN or COVARIANCE commands.  Each layer
of the picture contains the statistics for one class.  The number of columns
in this picture must be the same as the number of layers in the source
picture.  The number of classes that the LIKELIHOOD command can process
depends upon on the size of a Semper row buffer and on the number of layers in
the source picture.  Output pixel values run from zero, indicating
unclassified pixels, to N, where N is the number of layers in the picture
containing the statistics for each class.

By default, all classes are assumed to have an equal probability.  You may use
the PROBABILITY key to specify a priori probabilities for each class.  The sum
of the probabilities must be less than or equal to 1.0 (allowing a probability
of pixels being unclassified).

The THRESHOLD key allows you to specify a threshold value (the percentage of
pixels in a class which will be classified, in the range 1 to 100) for each
class.  When thresholding is applied, it is assumed that the classes are
normally distributed.  If the THRESHOLD key is omitted all pixels in the
source picture will be classified.  Normally a threshold should be specified
for each class, but if only one threshold value is given, it is applied to all
classes.  In this way, classifications involving more than nine regions may be
performed with thresholding.

By default, the output picture has the same dimensions as the source picture.
The SIZE and POSITION keys may be used to classify a subregion instead.  The
size may also be altered by using the STRIDE key which specifies a sampling
interval across and down the picture, allowing a fast classification of the
source picture.

It is possible for this command to fail before classification if any of the
class covariance matrices are singular (have no inverse).  This is most likely
to arise too small a training region was specified to the LEARN or COVARIANCE
command.

See also: likelihood.syntax, learn, box, mindistance
$add likelihood.syntax
Keys:
  [FROM]         source picture [SELECT]
  [TO]           output picture [FROM]
  WITH           training statistics [none]
  STRIDE         sampling interval across and down the picture [1]
  SIZE(2)        dimensions of subregion to be classified [whole picture]
  POSITION(2)    position/offset of subregion [0,0]
  PROBABILITY(9) a priori probability of a class [all classes have equal
                 probabilty and all pixels are classified]
  THRESHOLD(9)   threshold percentage to apply to each class [none]

Options:
  LEFT | RIGHT   classify subregion abutting indicated picture border
  TOP | BOTTOM

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add list.command list
You use LIST to inspect the text of a program, or to write it to a file
outside of Semper; also to list the text of a numbered macro on the console.

Exx: LIST PROGRAM 'COMBINE'
       lists program COMBINE on the console
     LIST ALL
       lists all programs in any assigned program libraries
     LIST .. NAME 'PROGTEXT'
       in conjunction with any of the above, creates a file PROGTEXT.SPL
       containing the program text
     LIST 30
       lists the macro CD:30 on the console; you cannot send the text to a
       file as in the last example, but the WRITE command achieves some of
       the required functionality

$
LIST NAME '...' will complain if the output file already exists. Use the
option NEW to overwrite an existing file.

See also: list.syntax files
$add list.syntax
Keys:
  [FROM] | PROGRAM text   number of macro, or name of program to be listed
                 [macro SELECT]
  DEVICE         device number of library containing program to be listed,
                 if two or more programs have the same name [first library
                 in current search order]
  NAME text      list program(s) in named file, created if necessary, rather
                 than on terminal (NB: not available when listing macros)

Options:
  ALL            list all programs in all assigned program libraries
  OLD | NEW      if OLD set, reuse existing file, starting from the beginning
                 if NEW set, overwrite existing file [if file exists, fault
                 its reuse, otherwise, create new file]

Use option OLD to access write-only output devices such as the printer port.

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add lmean.command lmean blur smooth
You use LMEAN to calculate the local mean over a square block of neighbouring
pixels around each source pixel.  In effect, LMEAN tells you the general
brightness around each pixel, and the others measure the brightness variation.

Exx: LMEAN DISPLAY OVER 50
        smooths picture DISPLAY (over 50 point square blocks)
     LMEAN 1 TO 2 OVER 8 VERTICAL
        smooths vertically only, over 8 point columns
$
Execution time is more or less independent of the block size, so you can use
very large ones if you need to.  You use a key OVER for the size of block over
which the local average is to be taken (default 5); 1-D HORIZONTAL or VERTICAL
forms are acceptable as well as square forms.

Edge pixels of the source - where the block averaged overflows the source -
are processed as if the boundary values were repeated indefinitely outwards.
When OVER is even, the source pixel replaced is rounded to the bottom right
from the block centre.

                                              Multi-layer pictures: faulted
                                             Forms used internally: fp,complex

See also: lmean.syntax
$add lmean.syntax
Keys:
  [FROM]         source picture [SELECT]
  [TO]           output picture [FROM]
  OVER           size of block/length of strip averaged around each pixel [5]

Options:
  HORIZONTAL | VERTICAL   average over horizontal/vertical strip centred on
                 each pixel [average over square block centred on each pixel]

Note:
  Globally setting the VERIFY option will trigger the VERTICAL option for this
  command.

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add local.command local
If you name one or more variables in a LOCAL command at the start of a
program, Semper notes their current state/value and restores this at the end
of the program.  If you use LOCAL interactively, the values are restored at
the end of the command line, provided any FOR loops established after the
LOCAL command have been closed.  The mechanism allows you to use variable
names in programs without any risk of their clashing with names used at higher
or lower calling levels.

(Variables named in FOR commands are treated as local automatically, and you
need take no special action to preserve them.)

Ex: N=.2; ...
    LOCAL N,M; ... ; N=5; ...; LIBRARY ANYPROG; ...
    leaves N set to .2 in spite of the assignment and program call

    N=.2 M=100; ...
    FOR N=1,5; .. ; FOR M=N,5; .. ; LIBRARY ANYPROG; LOOP; LOOP
    leaves M and N set to .2 and 100 in spite of the loops and program calls
$add log.command messages log output stream
You use the LOG command if you want to write messages to the log output
stream.  It has exactly the same syntax as the TYPE command.

Ex: LOG 'After ',n,' iterations, mean = ',mean

See also: type, diagnostic, textstring
$add loop.command loop
You can make Semper repeat a group of commands by surrounding them with a
FOR..LOOP pair:

Exx: FOR I 1,10; TYPE I,I*I; LOOP I

LOOP is the command that terminates a FOR loop.  It can optionally include
the name of the FOR variable.  There must be exactly one LOOP command for
each FOR command.

To break out of a FOR loop, use one of the commands BREAK, NEXT or JUMP.

See also: loop.syntax, FOR, BREAK, NEXT, JUMP
$add loop.syntax
LOOP uses a special syntax:

     LOOP [variable]

where variable is the name of the loop variable in the matching FOR command.
$add lorentzian.command lorentzian
You use LORENTZIAN to generate a picture containing a single lorentzian-
profile peak at the origin, for test or other purposes.  The GAUSSIAN command
generates a similar gaussian-profile picture.

Exx: LORENTZIAN SIZE 128
       replaces the current picture with a 128 square Fp picture with a
       lorentzian peak (half width at half height 16) at its origin
     LORENTZIAN 2 SIZE 40,40,40 RADIUS 5
       generates a 3-D lorentzian of rms width 5 pixels in picture 2
$
Pixels distant x from the picture origin are set to is r^2/(r^2+x^2), where R
is the value of the RADIUS key.

If RADIUS is negative, the function r^2/x^2 (with central value zero) is
stored instead - effectively a zero width lorentzian.

                                         Multi-layer pictures: fully supported
                                         Form used internally: fp

See also: lorentzian.syntax, gaussian
$add lorentzian.syntax
Keys:
  [TO]           output picture [SELECT]
  SIZE(3)        dimensions of picture produced [32,SIZE,1]
  RADIUS         width parameter for lorentzian function [SIZE/8]

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add lpd.command lpd linear peak detect local maximum
You use the LPD command to search for positive peaks in a 1-D picture and
output a list of peak parameters. Optionally, you can also output a line
spectrum with the peak maxima and bounds indicated. In all cases the Semper
variable N is set to the number of peaks found.

Exx: LPD 1 PLIST 2
       searches for peaks in picture 1 and outputs details as plist in
       picture 2. N is set to number of peaks found
     LPD 1 LINE TO 2 HEIGHT 50 BASELINE 10
       searches for peaks with a minimum height of 50 and outputs a
       line spectrum indicating their position and size. Values below
       the value 10 are assumed to be outside of any peak detected.

$
The basic peak detection performed by LPD can be refined using several
different criteria.

The key BASELINE is used to specify a minimum background level, below which
value points are not considered to be part of a peak. This value should be set
high enough to eliminate false peaks caused by baseline wobble, without
eliminating too much of a detected peak. The default value used for BASELINE
is 0 (which may be below the minimum value in the input spectrum!)

The key HEIGHT is used to specify a minimum height which must be achieved by
at least one point within the peak. The default value used is one third of
BASELINE - MIN. If this value is negative it is faulted.

The key AREA is used to specify a minimum area for peaks of interest. The
default value is 0. This key can be used together with the HEIGHT key to
restrict detection to sharper peaks in the input spectrum.

The key SATURATE is used to determine a threshold for minima used to seperate
peaks. To be accepted as a minimum position, a value must lie below this
threshold. The default value is the maximum value in the input spectrum (i.e.
the feature is normally turned off). This is useful for saturated peaks that
have small dips below the maximum value.

If the LINE option is given, the command will output a line spectrum
consisting of a single point at the position of each peak maxima with a height
equal to the integrated peak area. The start and end points of the peak are
marked with a negative value (of the same height as the maximum value in the
input spectrum).

The output plist contains parameters for each peak. For consistency with the
output of the ANALYSE command the output is dimensioned for 25 parameters, but
only 8 are supplied. The names and layer positions of the parameters set are
shown below. The commands used for particle analysis after the ANALYSE
commands, for example PTYPE, can also be used on the output of the LPD
command.

   Layer    Name       Contents
   =====    ====       ========
     1      XREF       X position of maximum
     3      ID         Peak number
     7      CONTACT    Saturated peak flag (1 = Saturated, 0 = Not)
     8      XMIN       X position of left hand edge of peak
     9      XMAX       X position of right hand edge of peak
    10      YMIN       Minimum value in peak
    11      YMAX       Maximum value in peak
    19      AREA       Integrated peak area

See also: lpd.syntax, peaks, ptype, particle.parameters
$add lpd.syntax
Keys:
  [FROM]         1-D source picture [SELECT]
  [TO]           if LINE, output picture [FROM]
  [PLIST]        if N > 0, picture containing list of peak parameters with
                 same format as particle parameter list [999]
  BASELINE       threshold below which any source values are ignored [0]
  HEIGHT         threshold above which peak is accepted [(BASELINE-MIN)/3]
  SATURATE       threshold above which minima are ignored [MAX]
  AREA           area threshold [0]

Options:
  LINE           output 1-D picture with peak maxima set to integrated peak
                 area with negative excursions outside bounds of integration
                 and zeros elsewhere [YES]

Variables set:
  N              number of peaks detected

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add lsd.command lsd blur smooth
You use LSD to calculate the local standard deviation (root mean square
deviation) over a square block of pixels around each source pixel.  In effect,
LSD tells you the brightness variation around each pixel.

Exx: LSD 1; DISPLAY
        presents bright pixels wherever the source varies strongly within the
        a 5 square neighbourhood - the operations is quite a good smooth edge
        detector.
     HP 1 TO 2 OVER 20; LSD TO 3 OVER 20; MIN=-2 MAX=2; CALC :2/:3 TO DIS
       displays 1 with mean and s.d. both standardised over 20 pixel blocks
$
Execution time is more or less independent of the block size, so you can use
very large ones if you need to.  You use a key OVER for the size of block over
which the local average is to be taken (default 5).

Edge pixels of the source - where the block averaged overflows the source -
are processed as if the boundary values were repeated indefinitely outwards.
When OVER is even, the source pixel replaced is rounded to the bottom right
from the block centre.

                                              Multi-layer pictures: faulted
                                             Forms used internally: fp,complex

See also: lsd.syntax
$add lsd.syntax
Keys:
  [FROM]         source picture [SELECT]
  [TO]           output picture [FROM]
  OVER           size of square block evaluated around each pixel [5]

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add lset.command lset luts brightness contrast colour
The LSET command allows you to set the contents of a display output look-up
table.

Exx:
  LSET 2 BRIGHTNESS 0,1
     sets look-up table 2 to a linear grey-scale ramp ranging from black
     to white.
  LSET BRIGHTNESS 1 SATURATION 1 HUE 0,360
     sets the current (false colour) look-up table to a 'spectrum' of fully
     saturated  colours  from red (hue=0) through green (hue=120  and  blue
     (hue =240) and back to red (hue=360)
  LSET BRIGHTNESS 1 SATURATION 1,0 HUE 120
     sets the current (flase colour) look-up table to shades of green, from
     fully saturated at the minimum display level, through pastel shades in
     the centre, to zero saturation (white) at the maximum display level.
  MIN=-1 MAX=1 CREATE DISPLAY SIZE 256
  LSET BRIGHTNES 1,0 RANGE 0,.1 SCALED DISPLAY
     sets the current look-up table to an inverted grey-scale ramp over the
     range  0  to  0.1 translated via the black and  white  levels  in  the
     display.
  LSET BRIGHTNESS -1,2 GREEN RED
     sets the green and red components of the current (full colour) lut  to
     a high-contrast ramp.  Leaves the blue component unchanged.
$
If you are working with a false colour output look-up table, you can control
the colour as well as the brightness associated with each display level.

You can specify the range of display levels whose appearance you want to set.
The appearance of levels outside this range will remain unchanged.

See also: lset.syntax, ladjust, lut
$add lset.syntax
Keys:
  [NUMBER]       look-up table number [current look-up table number = CLUT]
  RANGE(2)       Specify the range of display levels whose appearance is to
                 be set. The range defaults to the total range of display
                 levels supported in the look-up table (often 0,255 or
                 0,127). If option SCALED is quoted, these keys are scaled to
                 match the black and white levels of the display partition
                 indicated.
  SCALED         Interpret the RANGE and RA2 keys in terms of the black and
                 white levels of the partition indicated by SCALED.
  BRIGHTNESS(2)  The initial and final values of the brightness ('V' of an
                 HSV space) over the specified range. The brightness of each
                 pixel is clipped to the range 0 to 1 before output.
                 [0,BRIGHTNESS]
  HUE(2)         The initial and final values of the hue ('H' of an HSV
                 space) over the specified range. The hue range forms a
                 'spectrum' over the range 0 (red) through 120 (green) and
                 240 (blue), and back to 360 (red again). The hue parameter
                 is NOT clipped to this range, however, but is treated as
                 periodic with period 360. Ignored for all but false colour
                 luts. [0,HUE]
  SATURATION(2)  The initial and final values of the saturation ('S' of an
                 HSV space) over the specified range. A pixel with zero
                 saturation is always white, black, or a grey level between,
                 regardless of hue. The saturation of each pixel is clipped
                 in the range 0 to 1 before output. Ignored for all but
                 false colour luts. [0,SATURATION]

Options:
    RED          For full colour luts, specifies the colour channels to be
    GREEN        modified. If none of these is quoted, all three channels
    BLUE         will be set. Ignored for all but full colour luts.

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add lut.command lut lookuptable look-up-table
You use LUT to generate, store or alter the look-up-tables Semper maintaines
for use in your framestore hardware (if you have hardware luts). If the lut
lut affected is active (being used for viewing), the changes are instantly
apparent; and LUT KEYS allows you to make some forms of adjustment
interactively.

Exx: LUT 5 CREATE FALSE
       creates a false colour current lut 5
     LUT 2 CREATE RANGE 50,200
       creates a monochrome lut 2, black up to entry 50 and white above 200
     LUT ZERO RED
       zeros the red component of the current (full colour) lut
     LUT FROM 51 KEYS
       loads the current lut from a Semper Lut picture 51, and allows it to
       be adjusted interactively (type ? for help)
     DISPLAY 23; LUT CREATE FALSE HIGHLIGHT 2.3,2.5
       displays picture 23 with all values in the range 2.3-2.5 white

In default, LUT acts on the lut currently active (TYPE CLUT reports this).
$
LUT runs in three basic phases, each with several options:, and is inevitably
somewhat complicated:

Input phase (where the lut comes from); the alternatives are:
    LUT N simply operates on the existing lut N (CLUT in default)
    LUT N CREATE creates a new lut N, with options MONO (the default), FALSE
       and COLOUR (see also below)
    LUT N COPY C copies existing lut C
    LUT N FROM P loads from Lut picture P
    LUT N INPUT reads lut from display hardware (useful at the start of a
       session to read lut left by another program); options MONO, FALSE,
       COLOUR may be useful if hardware does not 'know' the mode itself.

Modification phase (how the lut is altered); the alternatives are:
    LUT.. RESET resets lut to standard ramp (as if CREATEd)
    LUT.. INVERT inverts the lut (reversing the grey scale)
    LUT.. ZERO zeros the lut (making picture invisible)
    LUT.. HIGHLIGHT H1,H2 forces lut entries H1-H2 to maximum brightness, and
       reduces the rest of the table slightly, to make band H1-H2 'stand out'
    LUT.. KEYS invokes an interactive keystroke-driven mode in which you can
       alter the lut range, brightness, contrast or highlight range; typing ?
       produces a list of key functions (see also below)

    With false or full colour luts, you use options RED, GREEN, BLUE and ALL
    (the default) to indicate which components are to be modified.

Output phase (what is done with the lut):
    In all cases, LUT stores the lut as software lut N, and loads it to the
       display hardware if relevant
    LUT.. TO P also stores a copy as an Lut picture P
    LUT.. DELETE deletes the lut altogether.

Lut ramp generation parameters
------------------------------
In default, luts generated are simple ramps covering the input and output
range appropriate to your display hardware.  You can vary them however, when
CREATing, RESETting, or in the KEYS mode, via the keys RANGE, BRIGHTNESS and
CONTRAST.

RANGE gives the minimum and maximum input values (horizontal range) over which
      the ramp extends, and must lie within the range appropriate to the
      hardware; the end value of the ramp are repeated outwards as necessary.
      RANGE defaults to the full input range (commonly 0,255), and you can
      increase (but not reduce) the display contrast by reducing RANGE.

BRIGHTNESS gives the output value (height) at the centre of the ramp, as a
      fraction of the maximum value (full height), i.e. as a number in the
      range 0 to 1. BRIGHTNESS defaults to .5, and you can increase or reduce
      the display brightness by increasing or reducing BRIGHTNESS.

CONTRAST gives the slope of the ramp, as a fraction of the maximum slope
      possible for the RANGE and BRIGHTNESS values, i.e. as a number in the
      range -1 to 1.  CONTRAST defaults to 1, and you can reduce (but not
      increase) the display contrast by reducing CONTRAST, or reverse it by
      reversing it.

Ex: graph of lut for hardware with 256 8-bit entries, with RANGE 64,140
    BRIGHTNESS .65 and CONTRAST .8:

      255 |-------------------------------------------------|
          |                          .......................|
          |                        . :   end val ctd        |
          |           CONTRAST   .   :                      |
          |           = slope  .     :                      |
          |                  .^      :                      |
          |                .  |      :                      |
          | end val ctd  .    |      :                      |
          |.............    BRIGHT   :                      |
          |            :   = height  :                      |
          |            :      |      :                      |
          |            :      |      :                      |
        0 |-------------------------------------------------|
          0          RANGE          RA2                    255

Exx: graphs of luts with default (full) RANGE and BRIGHTNESS/CONTRAST values
     indicated:
|--------------.    |----------- . .    |--------------|    |--------------.
|           .  |    |     . . .'   |    |              |    .              |
|        .     |    . . '          |    |            . .    |'' . .        |
|     .        |    |              |    |     . . .'   |    |      ''. .   |
|  .           |    |              |    . . '          |    |           ''..
.--------------|    |--------------|    |--------------|    |--------------|
  BRI=.5 CON=1        BRI=.8 CON=1       BRI=.2  CON=.7      BRI=.5 CON=-.7

BRIGHTNESS and CONTRAST are defined in such a way as to be independent of any
particular display hardware; but the RANGE as described above is not.  You
will sometimes prefer to specify the RANGE in terms of the pixel range scaled
to black and white when a display picture was created (EXAMINE FULL reports
this), so as to be independent of the grey scaling too: to do this, you
indicate via a key SCALED the display picture whose scaling you want applied;
for example,
   MIN=0 MAX=1; LOR TO DIS:4 SIZE 200
   LUT RANGE .2,.8 SCALED DISPLAY

False colour luts
-----------------
False colour luts are generated with an intensity/hue determined by what would
be the output intensity for a monochrome lut: the hue varies smoothly from
black through  blue, red, magenta (red + blue), grey, green, cyan (green +
yellow), and yellow (red + green) to white.  You can stretch false colours
scales via RANGE in the same way as you can stretch a monochrome scale;
however BRIGHTNESS and CONTRAST do not affect them.

Full colour luts
----------------
Full colour luts are generated by treating each component as an independent
monochrome lut; you can stretch or compress full colour scales via RANGE,
BRIGHTNESS and CONTRAST in the same way as monochrome scales.  In default,
these change all three components identically, altering intensity and/or
saturation levels rather than hue, but you can alter the hue as well by
quoting RED, GREEN and/or BLUE so as to change one or two components only.

Highlighting
------------
You can also ask for a particular band of lut entries to be 'highlighted',
i.e. presented at maximum brightness or in a different colour - for example to
allow you to explore quickly the effect of different threshold levels applied
to a picture.  To do this, you indicate the band you want with the key
HIGHLIGHT, e.g. HIGHLIGHT 50,100; lut values outside the band are reduced
somewhat to ensure that the band is visible.

Ex: with HIGHLIGHT 50,100 added, the first lut above becomes:

      255 |---------.........-------------------------------|
          |         .       .                               |
          |         .       .                               |
          |         .       .        .......................|
          |         .       .      .                        |
          |         .       .    .                          |
          |         .       .  .                            |
          |         .       ..                              |
          |         .                                       |
          |         .                                       |
          |..........                                       |
          |                                                 |
          |                                                 |
        0 |---------:--:----:--------:----------------------|
          0        50      100                             255

You can refer the HIGHLIGHT values to a picture's black,white levels by using
the SCALED key exactly as for RANGE.

Keystroke mode
--------------
Once entered, the interactive keystroke mode allows you access to most lut
features instantly, though at present for monochrome luts only.  Press ? for
a list of keys recognised and a summary of their functions, or RETURN to leave
the keystroke mode.

Broadly, you select a parameter to modify via the keys B(rightness),
C(contrast), R(ange) or H(ighlight), then move it up or down via the keys >
and < (or other locally assigned keys, such as left and right arrows); keys
F(ine) and C(oarse) allow you to control the step size.  The H keys 'toggles',
i.e. you can use it repeatedly to turn highlighting on and off alternately.

For the Range and Highlight parameters, which involve two limits, you also
select how you want to move them, via the keys M(ean - both together),
S(eparation), U(pper only) and L(ower only).

For false and full colour luts, you can select one channel or all for
modification via the keys 1(red), 2(green), 3(blue) or A(ll); you cannot
select pairs of channels however.

You can zero a channel in two ways: permanently via the key Z(ero), or
temporarily via the key O (the letter, not the digit), which 'toggles' and
allows you to clear and restore the lut alternately.

If you make mistakes and/or get lost, you can use the key D(iscard) to discard
any keystroke-controlled changes and recover the lut as originally generated.

The final Brightness, Contrast, Range and Highlight parameters are returned as
Semper variables B, C, R,R2 and H,H2 for use in subsequent commands; if you
are operating in the scaled mode, the values are inverse-scaled appropriately.
Ex:
   LUT SCALED DIS KEYS  [Keys R,M,S,>,< used to adjust the range]
   MIN=R MAX=R2; SCALE PRESET

See also: lut.syntax
$add lut.syntax
Keys:
  [NUMBER]       lut number [CLUT]
  FROM | COPY    picture or lut number from which new lut is to be taken
                 [none]
  TO             picture number to which final lut is to be copied [none]
  RANGE(2)       min,max lut entries covered by lut ramp [first,last]
  BRIGHTNESS     lut brightness parameter [.5]
  CONTRAST       lut contrast parameter [1]
  HIGHLIGHT(2)   min,max lut entries highlighted [none]
  SCALED         display picture whose black,white scaling is assumed for
                 RANGE,HIGHLIGHT values supplied and returned

Options:
  CREATE         create a new lut
  INPUT          read lut from display hardware (at start of session)
  DELETE         delete lut
  MONO|FALSE|COLOUR   create monochrome, false or full colour lut [MONO]
  RESET          reset lut (as if just CREATEd)
  INVERT         invert lut (complementing or negating)
  ZERO           zero (clear) lut
  ALL | RED,GREEN,BLUE  modify indicated lut colour(s) only [ALL]
  KEYS           enter keystroke driven lut adjustment mode
  ENQUIRE        return lut size and maximum output value by setting variables

Variables set:
  LSIZE          following LUT ENQUIRE, lut size (number of entries)
  LMAX           following LUT ENQUIRE, maximum output value for lut
  B,C            following LUT KEYS, final brightness,contrast parameters
  T(2)           following LUT KEYS, final range limits
  H(2)           following LUT KEYS with highlighting, final highlight limits

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add lvariance.command lvariance blur smooth
You use LVARIANCE to calculate the local variance (mean square deviation) over
a square block of neighbouring pixels around each source pixel.  In effect,
LVARIANCE tells you the brightness variation around each pixel.

Exx: LVARIANCE 1; DISPLAY
        presents bright pixels wherever the source varies strongly within the
        a 5 square neighbourhood - the operations is quite a good smooth edge
        detector.
$
Execution time is more or less independent of the block size, so you can use
very large ones if you need to.  You use a key OVER for the size of block over
which the local average is to be taken (default 5).

Edge pixels of the source - where the block averaged overflows the source -
are processed as if the boundary values were repeated indefinitely outwards.
When OVER is even, the source pixel replaced is rounded to the bottom right
from the block centre.

                                              Multi-layer pictures: faulted
                                             Forms used internally: fp,complex

See also: lvariance.syntax
$add lvariance.syntax
Keys:
  [FROM]         source picture [SELECT]
  [TO]           output picture [FROM]
  OVER           size of square block evaluated around each pixel [5]

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add macro.command macro
The MACRO command defines sequences of commands, command fragments, or other
text, which may subsequently be recalled by typing an @ sign followed by an
identifying number or name.

Exx: Xwires region; display @region  [= display size dx,dy position x,y]
     Macro 20; Ask 'Picture: ' n; display n; ps full ln;  display
     @20
     Macro 91; 'Subregion from 25 micron scan of stained specimen'
     Title 53 @91; Title 57 @91

Macros identified by numbers, like 20 and 91 above, are stored in class MACRO
'pictures'; EXAMINE MACROS lists all the macros on the current device, and
LIST lists the text of any given one.  You can alter the text of one of these
via EDIT.
$
NB: Two special restriction affect the use of numbered macros within programs,
though not macros used directly from terminal input:
   (i) macros called within programs may not contain labels or FOR loops;
  (ii) programs may not use the MACRO command to (re-)define macros.

See also: macro.syntax
$add macro.syntax
MACRO uses a special syntax:

     MACRO n; ............. macro text ..............

where n is the picture number to contain the macro text.  Any text entered on
the same command line (may be continued on subsequent lines), following the
MACRO command, is stored in the class MACRO picture indicated.
$add magnify.command magnify
You can use MAGNIFY to enlarge pictures or subregions by integer factors,
either interpolating or repeating source pixels.

Exx: MAGNIFY 4:23
       replaces picture 4023 with a double size version of itself
     XWIRES REGION; MAGNIFY @REGION TIMES 5 TO DISPLAY
       displays, enlarged 5 times, a region marked with the cursor
     MAGNIFY SIZE 50 TIMES 6 REPEATING
       displays the central 50 square of the current picture, repeating each
       source pixel in a 6 by 6 block
$
You can use all the standard keys/options to specify a (multi-layer) region
for enlargement; pixels are interpolated unless you use option REPEATING.

The outermost output pixels fall exactly on the outermost pixels of the source
region; the picture size does not therefore increase quite as you may expect -
e.g., if you magnify a 10 square picture by the default factor of two times,
the result is 19 points square.  Also, the point which falls on the origin of
the source is not exactly central; Semper records an adjusted position
accordingly (unless the region you magnify does not include the origin anyway.

If the MARK key is set, the limits of the source region are marked on the
indicated display picture.
                               Display marking: source region
                          Multi-layer pictures: layers processed independently
                         Forms used internally: fp,complex

See also: magnify.syntax
$add magnify.syntax
Keys:
  [FROM]         source picture [SELECT]
  [TO]           output picture [FROM]
  TIMES          integral magnification factor [2]
  SIZE(2)        dimensions of subregion to be magnified [whole picture]
  POSITION(2)    position/offset of subregion [0,0]
  MARK           display to be marked with border indicating source region
                 [none]

Options:
  REPEATING      repeat pixels instead of interpolating
  LEFT | RIGHT   magnify subregion abutting indicated border
  BOTTOM | TOP

See SUBREGIONS for more details of subregion keys/options.

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add map.command map rescale histogram equalise nonlinear
You use MAP for arbitrary pixel value mapping, linear or nonlinear, and for
histogram equalisation or shape forcing.

Exx: MAP 1 TO 2 WITH 3 RANGE 1.2,3.5
       treats 1-D picture 3 as defining replacement values for picture 1
       pixels over the range 1.2-3.5 (default MIN-MAX), and stores mapped
       result as picture 2
     HISTOGRAM 50 TO 3; MAP 50 WITH 3
       equalises the histogram of picture 50
     HISTOGRAM 50 TO 3; MAP 50 TO DISPLAY WITH 3 GAUSSIAN
       displays picture 50 stretched so as to have a gaussian histogram

You can of course use XWIRES to draw the map directly with the display cursor
if you wish, or use a display lut recovered via LUT.
$
MAP operates in two modes.  Normally, you map with a tabulated mapping
function provided directly as a 1-D picture.  MAP treats the map pixels as
defining replacement pixels over the source range MIN to MAX (unless you
specify a different  RANGE), using bilinear interpolation where necessary to
extend these to form a continuous function.

Alternatively, you map with a Histogram picture (produced from the picture you
wish to map), in which case MAP generates the actual mapping function itself
in such a way as to equalise the output picture histogram, (a standard method
of contrast-stretching in pictures with poor initial contrast).

Since equalisation in fact often overdoes it, you may like to use the
additional option GAUSSIAN, which results in an output histogram gaussian in
shape, falling by a factor exp(-2) at both ends.

NB: Finite numbers of distinct pixel value and/or histogram channels usually
mean that the final histogram has the target shape only when averaged over a
few neighbouring channels; the visual impact of the imperfection is however
negligible.

Byte source pictures are mapped efficiently via a look-up-table approach.

                      Multi-layer pictures: all layers processed
                     Forms used internally: integer (for byte data),fp,complex

See also: map.syntax
$add map.syntax
Keys:
  [FROM]         source picture [SELECT]
  [TO]           output picture [FROM]
  WITH           picture containing map function or Histogram [999]
  RANGE(2)       source picture range spanned by map function [MIN,MAX]

Options:
  GAUSSIAN       if WITH is a Histogram, map source so that output has
                 histogram with gaussian profile

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add mark.command mark annotate overlay text border region circle
You use MARK to mark positions, outline regions and write text in a display
overlay, in a variety of different ways.  (Setting the general key MARK has a
similar effect with several commands, e.g. EXTRACT.)

Exx: MARK @XY
       marks a small cross on picture DISPLAY at position X,Y
     MARK DIS:2 SIZE 300,200 TOP LEFT
       outlines the indicated region of picture DIS:2
     MARK PARTITION DIS:2 BORDER VIEW
       outlines the partition DIS:2, and presents it on the monitor
     MARK RADIUS 60 POSITION 10,10 ANGLE 0,PI/2
        marks a quadrant of a circle upwards from 70,10 curving leftwards
        to 10,70
     MARK TEXT 'Area B' BOTTOM LEFT
        marks the text at the bottom left

With no options set, MARK simply marks the display centre; details of the
alternative modes are given in separate help files (HELP MARK. types them
all).  Use the general option VIEW if you want MARK to ensure that what you
mark is visible, even if off the initial viewing screen.
$
In default, MARK marks DISPLAY, in picture coordinate mode; however, you can
also use it in PARTITION or FRAME mode -

     e.g., MARK PARTITION DIS:7 (see GRAPHICS).

You specify positions via POSITION, LEFT, RIGHT, TOP and BOTTOM in the
standard way.

You can control the form of mark used for isolated points, if you want to, via
MKMODE and MKSIZE.

For complex display pictures, where the real and imaginary parts of the image
are displayed side by side, MARK would normally annotate both parts.  You can
restrict the annotation to just the real or imaginary part by specifying the
option RE or IM.

Note that when annotating pictures or partitions, the annotation is output to
all of the frames allocated to the partition involved.  This means that
annotation will be correctly displayed on full colour framestores provided
that the partitions used have three successive frames allocated to them.

See also: mark.syntax, mark.position, mark.line, mark.arrow, mark.circle

See also: mark.arc, mark.region, mark.list, mark.curve, mark.border, mark.text
$add mark.syntax
Keys:
  []             picture/partition/frame to be marked [DISPLAY if picture
                 or partition; CFRAME if frame]
  TEXT text      text marked at position POSITION(2)
  SIZE(2)        mark subregion with given dimensions (and position as given
                 by all standard 2-D subregion keys/options)
  TO(2)          mark line or arrow from POSITION(2) to given end-point
  RADIUS         mark circle/arc with given radius and centre POSITION(2)
  WITH           mark positions/curve in indicated Plist picture
  POSITION(2)    if none of TEXT,SIZE,TO,RADIUS or WITH is set, mark given
                 position only in style determined by MKMODE,MKSIZE
  ANGLE(2)       if RADIUS set, mark arc rather than circle, with given
                 starting and finishing angles
                 if SIZE set, mark subregion at specified angle
  SAMPLING       sampling (inverse magnification) factor for subregion [1]
  MKMODE         mark mode [1]
  MKSIZE         mark size [2]

Options:
  PICTURE | PARTITION | FRAME   use indicated coordinate system [PICTURE]
  BORDER         mark picture/partition/frame border
  LINE           mark line from POSITION(2) to TO(2)
  ARROW          mark arrow rather than LINE
  CIRCLE         mark circle with centre at POSITION, radius RADIUS
  ARC            mark arc rather than circle, over angular range THETA-TH2
  REGION         mark subregion defined by standard 2-D keys/options
  LEFT | RIGHT   mark subregion abutting indicated border (if SIZE key used)
  BOTTOM | TOP
  UV             mark subregion with unit sampling vectors defined by Semper
                 variables U,U2 and V,V2
  LIST | CURVE   if WITH set, check type of Plist [actual type]
  OPEN | CLOSED
  LJ | RJ        if TEXT set, mark string left-justified or right-justified
                 with respect to specified position
  BJ | TJ        if TEXT set, mark string bottom-justified or top-justified
                 with respect to specified position
  BELOW | ABOVE  if TEXT set, mark text centrally at top/bottom of picture
  OUTSIDE | INSIDE  if BELOW or ABOVE set, mark text outside or inside picture
                 border [OUTSIDE]
  RE | IM        mark real or imaginary part of complex display picture
                 [mark both parts]
  VIEW           switch view to make display region visible [NO]

LINE,CIRCLE,REGION,ARC are fact ignored, and allowed only in the interests of
readability.

See SUBREGIONS for more details of subregion keys/options.

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add mark.position
MARK POSITION X,Y  [or MARK @XY]
  marks the indicated position
$add mark.line
MARK LINE POSITION X,Y TO XN,YN
MARK POSITION X,Y TO XN,YN  [ = MARK @XY TO XN,YN ]
  all mark a line from X,Y to XN,YN (the option LINE is ignored, but allowed
  for readability); you may use all the standard 2-D subregion options/keys to
  specify the position
$add mark.arrow
MARK ARROW POSITION X,Y TO XN,YN  [ = MARK ARROW @XY TO XN,YN ]
  marks an arrow from X,Y to XN,YN; you may use all the standard 2-D subregion
  options/keys to specify the position
$add mark.circle
MARK CIRCLE POSITION X,Y RADIUS R
MARK POSITION X,Y RADIUS R  [ = MARK @CIRCLE ]
  all mark a circle with the given centre and radius (the option CIRCLE is
  ignored, but allowed for readability); you can use any of the standard 2-D
  subregion options/keys to position the circle centre
$add mark.arc
MARK ARC POSITION X,Y RADIUS R ANGLE THETA,TH2
MARK POSITION X,Y RADIUS R ANGLE THETA,TH2  [ = MARK @ARC]
  all mark a circular arc with the given centre and radius, anticlockwise from
  angle THETA to angle TH2 (both in radians anticlockwise from +X axis)
$add mark.region
MARK REGION POSITION X,Y SIZE R,R2
MARK POSITION X,Y SIZE R,R2  [ = MARK @REGION ]
  all outline a (horizontal/vertical) rectangular region centred at X,Y with
  dimensions R,R2 (the word REGION is ignored, but allowed for readability);
  R2 may be 1, in which case a 1-D region (a line) is marked; you may use any
  of the standard 2-D subregion options/keys to indicate the region
MARK @REGION SAMPLING 2
  marks region with the given number of samples but doubled sampling interval
MARK @REGION ANGLE THETA
  marks a region rotated anticlockwise by THETA
MARK @REGION UV
  marks a skewed region with new sampling lattice base vectors U and V
$add mark.list
MARK LIST WITH N
MARK WITH N
  both mark the positions recorded in the Plist picture N (the only effect of
  quoting the option LIST itself is to cause the type of the Plist to be
  verified)
$add mark.curve
MARK CURVE WITH N
MARK WITH N
  both mark the curve recorded in the Plist picture N (the only effect of
  quoting the option CURVE itself is to cause the type of the Plist to be
  verified)
$add mark.border
MARK BORDER
  outlines the picture, partition or frame border, according to the graphics
  mode selected
$add mark.text
MARK TEXT typeitemlist BOTTOM LEFT
  writes the indicated text at the bottom left of the picture; you can use any
  of the standard 2-D options/keys to position the text
MARK TEXT ... POSITION X,Y  [ = MARK TEXT ... @XY ]
  writes the text left centred at the indicated position
MARK TEXT ... LJ @XY
  writes the text left justified to the position indicated; you can also use
  RJ, TJ and BJ to force right, top and bottom justification; LJ is assumed if
  you use LEFT, TJ if you quote TOP etc.

If you use options BELOW or ABOVE in picture mode, the text is positioned
quite differently, to allow convenient picture titling:
MARK TEXT ... BELOW  [ or ABOVE ]
  writes the text centrally below (or above) the picture, as a title;
MARK TEXT ... BELOW INSIDE
  writes the text centrally inside the bottom of the picture; you may write
  BELOW OUTSIDE etc. if you wish, but OUTSIDE is the default anyway
$add mask.command mask outline boundary border curve
You use MASK to reset to a constant all pixels inside or outside a given
subregion - for example, to eliminate unwanted features in an image, or to
perform low or high pass filtering of a Fourier transform.

Exx: MASK
       resets all points more than two thirds of the way from the origin to
       the nearest picture edge to the mean picture value at that radius
     XWIRES CIRCLE; MASK INSIDE @CIRCLE VALUE 0
       resets to zero all points inside a circle indicated via 3 cursor points
     MASK OUTSIDE RADIUS 100 POSITION 20,30 WIDTH 10
       resets points more than 100 pixels from the point (20,30), fading
       smoothly over 10 or so pixels rather than abruptly
     XWIRES CURVE TO 51; MASK WITH 51
       resets all points outside an arbitrary region indicated via the cursor
$
MASK operates in two modes, circular (the default) and polygonal (MASK..WITH a
Plist).  It can reset pixels OUTSIDE (the default) or INSIDE the region in
question; the default reset value is the source picture mean taken over the
mask boundary, unless you force a particular value via the key VALUE (which
takes a complex value for complex pictures).

For the circular mode only, a 'soft edge' can be included in the mask, with a
gaussian profile extending outwards (or inwards if INSIDE) from RADIUS:
specifically, a pixel R from the centre of the circle with initial value P is
reset to w.P + (1-w).VALUE, with w=exp(-(R-RADIUS)^2/WIDTH^2).

If the MATK key is set, the mask boundary is marked in the indicated display
picture.  Display marking includes a second circle 2*WIDTH from the first when
WIDTH is quoted.
                                           Display marking: mask boundary
                                      Multi-layer pictures: faulted
                                     Forms used internally: integer,fp,complex

See also: mask.syntax
$add mask.syntax
Keys:
  [FROM]         source picture [SELECT]
  [TO]           output picture [FROM]
  RADIUS         circular mask radius [two thirds min source dimension]
  POSITION(2)    circular mask centre position
  WIDTH          width parameter for soft edge applied to circular mask [0]
  WITH           Plist containing mask boundary curve [circular mask]
  VALUE(2)       (in general complex) value to which pixels are to be reset
                 [source picture average around mask boundary]
  MARK           display to be marked with mask boundary [none]

Options:
  OUTSIDE|INSIDE  reset pixels outside or inside mask [OUTSIDE]

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add median.command median noise
You use MEDIAN to 'smooth' binary pictures, removing isolated point and line
objects, and similar point and line holes within objects, at the same time.
Specifically, each pixel is reset to the median value of its 3x3
neighbourhood, the original value being retained when the 8 neighbours are
evenly divided.

Exx: MEDIAN DISPLAY
       smooths objects in the current display
     MEDIAN 50 TO 51
       smooths picture 50 as picture 51

                                    Multi-layer pictures: all layers processed
                                    Form used internally: integer
Subtopics: median.syntax
$add median.syntax
Keys:
  [FROM]         source picture [SELECT]
  [TO]           output picture [FROM]

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add menu.command menu
The command MENU controls the creation  and  operations  of   the
Semper  6  Plus Menu  element.   The  default  type  of  menu  is
PULLDOWN, with default style CHOICE.

Examples:
     MENU CREATE NAME 'Display mgt.' FIXED
     creates a new fixed menu called 'Display mgt.'
$
There  are  three styles of menu: FIXED, POPUP and  PULLDOWN.  By
default, menus are created as being of type PULLDOWN. Popup menus
are  rather strange, in that they belong to a panel (as   do  all
elements), but may appear outside it. Both the POPUP and PULLDOWN
menus 'use up' a panel (they may considered to be a special  type
of  panel).  This point is worth remembering when  defining  user
interfaces if the system reports that all panels are in use.  The
UIF  STATUS  command  can  be used to  check  the  state  of  the
interface system.

By default, pulldown menus will  be  activated  when  their  name
banner  is hit:  there is no default condition for activation  of
popup  menus.  There are no default conditions  for  deactivation
for  pulldown and popup menus.  This can be provided by using the
DROP  key,  or  by programming  the  deactivation  directly.  For
example:

     MENU CREATE PULLDOWN
     MID = ENO
     CELL CREATE ADD MID TEXT 'Function 1' DROP ROW 1 COLUMN 1
     CL1 = ENO
     CELL CREATE ADD MID TEXT 'Function 2' DROP ROW 2 COLUMN 1
     CL2 = ENO

would  create a menu with two elements on it. When either of  the
two  cells  were selected, the menu would  automatically  be  de-
activated.

If   the DESTROY option is used (see uif.element) then the   menu
and  all the cells on that menu are destroyed. The cells  on  the
menu do not have to be destroyed individually. For example:

     MENU ID MID DESTROY

would  destroy the menu created in the previous example, as  well
as the two cells with the ids CL1 and CL2.

Using  POSITION  on a popup menu whilst it  is  DEACTIVATED  will
move  it to the position required before it appears, i.e.

     MOUSE QUERY; MENU ID MID POSITION UIX,UIY ACTIVATE

will  cause the menu with  id  MID  to  appear  at  the   current
mouse position.  This is the sort of action which may be assigned
to  a mouse button to cause popup menus to appear when  a  button
is   pressed.    A  similar  action  could  be   defined   on   a
button to cause the menu to disappear:

     MOUSE QUERY; MENU DEACTIVATE

which  would  cause the menu under the mouse when the  button  is
pressed to be deactivated.

There are two types of menu: CHOICE and TOGGLE. By default, menus
are of the CHOICE type. On CHOICE type menus the cells will cycle
through their highlight states as the mouse moves over them.  For
example, if a (choice) menu has a check cell on it the cell  will
go  from the space to the plus mark state. If the mouse is  moved
over the cell again the cell will go to the minus mark state.  In
contrast, TOGGLE type menus will not cycle the cell states  until
the  cell  is selected (by clicking on it). From this it  can  be
seen  that INVERT cells rather than any other type are  the  most
useful on CHOICE type menus.

Note that the size of the menu will be assumed to include  a  one
character  wide  border  to  allow  for drawing a box around  the
menu,  which must be allowed for when defining the size.

See also: menu.syntax, element.syntax, uif.element
$add menu.syntax
Keys:
  BACKGROUND     Specifies the background colour to be used for the menu.
  BEGINS text    The given string is set as the 'interaction begins' action
                 for the menu.
  ENDS text      The given string is set as the 'interaction ends' action
                 for the menu.
  FOREGROUND     Specifies the foreground colour to be used for the menu.
  ID             Defines the menu to use [ENO].
  IN             Defines the panel in which the menu is to appear.  Does
                 not reset the value of variable PNO [PNO].
  NAME text      Defines a name for the menu.
  POSITION(2)    Defines the position of the currently set location point
                 of the menu in the requested panel.  Using POSITION once
                 a menu has been created moves the menu.
  SIZE(2)        Defines a minimum X and Y size for the menu.  If the
                 menu requires to be larger than the size specified, the
                 size given here will be overridden.

Options:
  ACTIVATE       The menu is activated.  For popup menus and pulldown menus,
                 the menu appears on the screen.  The activated menu is
                 selected.
  CHOICE         The menu is of style choice.
  CREATE         Creates a menu.  This is the first option that is
                 checked for when the command looks at its arguments.
  DEACTIVATE     The menu is deactivated.  For popup menus and pulldown menus,
                 the menu disappears from the screen: for fixed menus, there
                 is no effect.
  DESTROY        Destroys a menu.
  FIXED          The menu is of type fixed.
  POPUP          The menu is of type popup.
  PULLDOWN       The menu is of type pulldown.
  TOGGLE         The menu is of style toggle.

Variables set:
  ENO            Set by the CREATE option to the identifier of the menu.

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add semper6plus semper6.plus semper.plus plus user interface menus
The Semper 6 Plus user interface system is controlled by the  use
of a set  of commands which extend  the  Semper  language.  Their
names have been chosen so that they do not clash with  the  names
of Semper commands.  These commands fall into two main   classes;
those   which define the user interface, and those which  control
it.

See also cell, device, execute, justification,
         menu, uif, uif.element, uif.example,
         uif.variable, mouse, panel, textfield.
$


To define a user  interface,  the  user  will  use  the  commands
detailed above to set up the panels, elements and  actions  which
they  require.  Once this interface  has been  loaded,  execution
begins with the use of UIF GO: the user is then running within the
user  interface  environment until  they  use  UIF   EXIT,   when
they return to Semper, or UIF STOP which returns them to the host
operating system.  It should be noted that once the interface has
been  loaded,  it can be modified interactively  (unless  it  has
been designed so that the user cannot do this).
$add uif.variable
The user interface system makes use of the following variables:

     CDI       is  the identifier of the display on which  panels
               are  to   appear.    It   should  be  set  to  the
               required  device,  see  the  DEVICE  command   for
               further details.

     ENO       when  a  new  element, etc.    is   created,   its
               identifier   is placed in variable ENO.  If it  is
               necessary  to  save identifiers  of  elements  for
               later use, (e.g.  cell ids for later inclusion  in
               a  menu),  the  value of ENO must  be  saved  into
               another variable.

     UIX
     UIY       the  mouse position, when queried, is   set   into
               these  variables. These variables are also set  to
               the size of the display when using the DEVICE QUERY
               command.

     NBU       the  number  of  buttons on  the  mouse  (pointing
               device) is set by the MOUSE QUERY command.

     NCO       the  number of colours on the display is set  into
               this variable.

     PNO       when  elements are created, they are assigned   to
               a   panel,  whose identifier is assumed to  be  in
               PNO.
$add uif.element
All user interface commands which deal with element  creation and
manipulation  work  on  the element whose identifier  is  in  the
variable ENO, unless:

     *    The CREATE option is used, in which case a new  element
          is created and its identifier assigned to the  variable
          ENO.
     *    The ID key is used to define the element to work on.

All  elements  are assigned to the panel whose identifier  is  in
variable PNO  unless  the  IN key is used to define the panel  in
which  it  is to appear.  It is not possible to add  elements  to
panels  which are showing. Therefore, all elements required on  a
fixed  panel  must be added before it is shown: to  add  elements
later  the  panel must be destroyed and re-created.
$

While the number  of  colours available depends  on  the  display
device,  the numbering  of  colours used  by  the  user interface
system is defined as follows:

    0    Black
    1    White
    2    Red
    3    Green
    4    Blue
    5    Cyan
    6    Magenta
    7    Yellow

By  default,  elements  inherit  the  foreground  and  background
colours   of  the panel on which they are placed.  If a  cell  is
added  to a menu, then it inherits the foreground and  background
colours  of  the menu. The default values may be  over-ridden  by
using   the  FOREGROUND  and  BACKGROUND  keys.  The  effect   of
specifying a colour number which is higher than that returned  in
NCO  by DEVICE QUERY is undefined. It is possible to  change  the
colour  of elements once created but the panel on which they  are
located must be hidden and redisplayed for this to be visible.

Elements can be named.  This facility is  not supplied  so   that
elements   can  be  referred  to by name, rather to identify  the
purpose  of  the  element  on the panel.   For  instance,  if   a
pulldown  menu is named, the name is the string displayed on  the
panel  which, when hit, causes the menu to appear. If a  cell  is
named,  then the cell is drawn surrounded by a box with the  name
in the top line of the box.

The  BEGINS, CHANGES and ENDS keys define the actions  which  are
carried  out  when  an  element  undergoes  any  of the following
transitions:   interaction begins,  state  changes,   interaction
ends.   For   each  element type, the definition of  these  three
transitions are as follows

+============+===============+================+================+
| Element    | Begins        | State Change   | Ends           |
+============+===============+================+================+
| Cell       | Mouse enters  | Cell selected  | Mouse leaves   |
|            | cell          |                | cell           |
+------------+---------------+----------------+----------------+
| Menu       | Mouse enters  | Not applicable | Mouse leaves   |
| (fixed)    | menu          |                | menu           |
+------------+---------------+----------------+----------------+
| Menu       | Menu          | Not applicable | Menu           |
| (popup)    | activated     |                | deactivated    |
+------------+---------------+----------------+----------------+
| Menu       | Menu          | Not applicable | Menu           |
| (pulldown) | activated     |                | deactivated    |
+------------+---------------+----------------+----------------+
| Textfield  | Textfield     | Contents       | Enter +        |
|            | selected      | changed        | selected       |
+============+===============+================+================+

The action for each of these states is defined by a text  string,
which contains the commands,  keys and options to be executed  by
Semper.  The null string '' may be entered if no action is to  be
carried  out:   note  that  this is NOT the same  as  the  string
'null', which would cause the Semper command NULL (i.e.  DISPLAY)
to be executed!  By default, all actions are  defined  to be  the
null string, i.e. no action defined.  These strings are submitted
for   interpretation   when   the   action   is   triggered,   so
variables  appearing  in the action strings are  interpreted  and
set  at that time.  Variable ENO is set to the element which  has
generated the action when it occurs.
$add uif.element.syntax element.syntax
Keys:

     BACKGROUND     Specifies  the background colour to  be  used
                    for the element.

     BEGINS         The    given   string   is   set    as    the
                    'interaction begins' action for the element.

     CHANGES        The  given  string is  set  as   the   'state
                    change' action for the element.

     ENDS           The  given string is set as the  'interaction
                    ends' action for the element.

     FOREGROUND     Specifies  the foreground colour to  be  used
                    for the element.

     ID             Defines  the  element to use [ENO].

     IN             Defines  the panel  in  which   the   element
                    is   to appear.  Does not reset the value  of
                    variable PNO [PNO].

     NAME           Defines a name for the element.

     POSITION(2)    Defines  the  position of the  currently  set
                    location  point   of   the  element  in   the
                    requested  panel.   Using  POSITION  once  an
                    element has been created moves the element.

     SIZE(2)        Defines  a  minimum X and Y  size   for   the
                    element.   If   the  element requires  to  be
                    larger  than  the size  specified,  the  size
                    given here will be overridden.

Options:

     CREATE         Creates an element. This is the first  option
                    that is checked for when the command looks at
                    its arguments.

     DESTROY        Destroys an element.


Variables set:

     ENO            Set by the CREATE option to the identifier of
                    the element.
$add uif.example
The  following is a short example program which uses some of  the
user interface commands.

 !
 !  Set  things  up. Note justification  setting  because  we  are
 ! positioning at top left of screen.
 !
 uif enable
 justification top left
 !
 ! Create a panel.
 !
 panel create size 1,1 position 0,0 name 'Semper 6 Plus Demo.' auto
 mai=pno
 !
 ! Create a textfield, for typing normal Semper commands.
 !
 textfield create position 1,5 name 'S$' length 58
 $te=eno
 !
 ! Create a menu, with two options on it. The first displays
 ! whatever SEL is set to. The other exits to the host operating
 ! system.
 !
 menu create pulldown name 'pulldown' position 1,1
 $pu=eno
 cell create invert text 'Display' row 1 col 1 add $pu changes 'display'
 c1=eno
 cell create invert text 'EXIT' row 2 col 1 add $pu changes 'uif stop'
 c2=eno
 !
 ! Additionally define an action for when the mouse/cursor enters
 ! the 'EXIT' cell.
 !
 cell id c2 begins 'cls;type ''*** Warning this will exit SEMPER'''
 !
 ! Show the panel, so that Semper 6 Plus knows what limits are
 ! defined for the 'scrolling' (where normal Semper output will be
 ! directed) area.
 !
 panel id mai show
 !
 ! Set the interface going.
 !
 uif go
$add mindistance.command mindistance classification minimum.distance
The MINDISTANCE command classifies a picture using the minimum distance to
means method.

Exx: MINDISTANCE 1 2 WITH 3
       classify picture 1 using the training data contained in picture 3
     MINDISTANCE 1 2 WITH 3 THRESHOLD 1,2,1
       as above but apply thresholds of 1, 2 and 1 standard deviations to each
       of the classes
$
This command performs a minimum distance to means classification of the source
image based upon the statistics given in the picture specified with the WITH
key. This picture can be generated by the LEARN or COVARIANCE commands. Each
layer of the picture contains the statistics for one class. The number of
columns in this picture must be the same as the number of layers in the source
picture.  The number of classes that the MINDISTANCE command can process
depends upon on the size of a Semper row buffer and on the number of layers in
the source picture.  Output pixel values run from zero, indicating
unclassified pixels, to N, where N is the number of layers in the picture
containing the statistics for each class.

By default, no threshold values are applied and all pixels will be classified.
If the THRESHOLD key is used, you can specify a single value to be applied to
all classes, otherwise, you must specify a separate value for each class.  The
threshold values denote the number of standard deviations from  the means of
each class.  All threshold values must be positive.

By default, the output picture has the same dimensions as the source picture.
The SIZE and POSITION keys may be used to classify a subregion instead.  The
size may also be altered by using the STRIDE key which specifies a sampling
interval across and down the picture, allowing a fast classification of the
source picture.

See also: mindistance.syntax, learn, covariance, box, likelihood
$add mindistance.syntax
Keys:
  [FROM]         source picture [SELECT]
  [TO]           output picture [FROM]
  WITH           training statistics [none]
  STRIDE         sampling interval across and down the picture [1]
  SIZE(2)        dimensions of subregion to be classified [whole picture]
  POSITION(2)    position/offset of subregion [0,0]
  THRESHOLD(9)   threshold values to be applied [all pixels are classified]

Options:
  LEFT | RIGHT   classify subregion abutting indicated picture border
  TOP | BOTTOM

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add monitor.command monitor debugging routines calls
In installations where Semper has been compiled with monitor support, you can
turn on or off various forms of printout that monitor system operation with
the MONITOR command, which may be useful for debugging programs.

Exx: MONITOR SHOW
       prints the current monitor status
     MONITOR ROWIO ON
       causes picture row i/o operations to be monitored
     MONITOR NONE RANGE
     MONITOR ON; ....... ; MONITOR OFF
       disables all monitoring except for RANGE calls for a given series
       of commands
     MONITOR OFF
       turns off all monitoring, but without changing idividual channel status

The following named monitor 'channels' are available:

 Chn  Name       Function
  1   PROCESSING Available for user-written processing routines
  2   ROWIO      Verifies calls to SEMROW (row i/o)
  3   OPENS      Verifies calls to SEMOPN/DEL (opening/deleting pictures)
  4   RANGE      Verifies calls to RANGE, which determines/records picture
                 ranges

The monitor facility is intended primarily for Synoptics internal use; it is
provided to customers only on an 'as is' basis, in case it is found helpful,
without any kind of warranty whatsoever.
$
The option ON or OFF switch all monitoring on or off.  Printout normally goes
to the terminal (to the monitor output stream in fact - see the ECHO command).
All monitoring is turned off when Semper starts up.

You use options PROCESSING, ROWIO etc. to MONITOR to enable or disable
monitoring of specific sets of information, e.g. MONITOR OPENS NORANGE.
Option ALL or NONE turns them all on or off together.

Additional monitor 'channels', numbered from 5 up to 16, may be used by system
or user routines.  These are controlled by means of the CHANNEL key, for
example, MONITOR CHANNEL 5 to enable channel 5, MONITOR CHANNEL -8 to disable
channel 8.  At present the following channels are used:

  5   Verifies calls to routine DISC
  6   is reserved for systems with magnetic tapes
  7   Verifies calls to routine MCDC61

All monitor channels are disabled when Semper starts up.

Within a Fortran routine, a test of the form

      IF (MONIT) THEN
         IF(SEMMON(TEXT,NAME,ICHAN)) RETURN
      ENDIF

is used to test whether or not monitor output is to be generated.  The call to
SEMMON passes the monitor message in TEXT, the name of the subroutine as a
character string in NAME and the monitor channel number in ICHAN.  SEMMON will
output the monitor text if the specified monitor channel is enabled.

See also: monitor.syntax
$add monitor.syntax
Keys:
  CHANNEL        monitor channel to be enabled (disabled if < 0) [none]

Options:
  SHOW           list monitor status on the console
  ON | OFF       turn monitoring on or off
  ALL | NONE     enable or disable all monitor channels
  ROWIO          enable monitoring of row input/output operations
  OPENS          enable monitoring of picture opens
  RANGE          enable monitoring of calls to module RANGE
  PROCESSING     enable monitoring of output from new processing modules

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add morphology shape size direction binary erode dilate median
The main Semper commands concerned with manipulating and measuring 2-D shapes
are ANALYSE, ERODE, DILATE and MEDIAN.  They are concerned with pictures that
are essentially binary, i.e. having two values only: 0 for background pixels
and 1 for pixels belonging to the shapes ('objects') of interest.  Since
Semper does not actually store pixels in single bit form, most of the relevant
commands in fact distinguish zero and non-zero pixel ('clear' and 'set')
instead, and ANALYSE distinguishes those failing or meeting user-defined
conditions.  You can render a picture binary via CALCULATE, e.g.
   CALC :51>20 or CALC :51<THR.

ERODE, DILATE and MEDIAN are concerned with manipulating shapes (growing,
shrinking, skeletonisation, edge smoothing, noise removal, skeleton pruning
etc.); corresponding operations applicable to grey level pictures (those with
more than two pixel values) are provided by RANK.

ANALYSE is concerned with measuring the shapes, directions etc. of objects
(perhaps after manipulation by the preceding commands); it generates a list of
all objects found in a field, together with a large number of 'parameters' for
each (position, directionality, diameter, area, etc.) which is then sorted,
interrogated, printed or displayed by a number of subsidiary commands (PTYPE,
PSHOW etc.).
$
There is no NEED for you to take any special action over displaying binary
pictures, but where speed matters, you may like to display them unscaled and
rely on a look-up-table to render them visible, as unscaled bytes are commonly
transferred to/from the display device faster than any other data type.  You
might achieve this, depending on the details of your installation, by commands
such as:
   $ lut reset highlight 1,255; min=0 max=255
followed by either
   $ display preset
or
   $ copy to display
$add connectivity morphology
Two kinds of pixel connectivity are commonly distinguished, namely 4- and 8-
connectivity.  In 4-connectivity, pixels are treated as connected to their
neighbours horizontally and vertically, but not diagonally, while in 8-
connectivity diagonal neighbours are also treated as being connected.  Thus
          the configuration left forms a single 8-connected
 1 111    region, but four separate 4-connected regions; the    11111
  1  1    figure right gives the corresponding 4-connected       1  1
  1   11  single region.                                         1  111

8-connectivity gives smoother curves and better rendering of edges, and is
therefore preferable in general; however, 8-connectivity of both objects and
          background is topologically inconsistent, e.g. both
  0011    object and background are 8-connected across the centre    0011
  0011    of the configuration left.  Semper assumes in general      0011
  1100    therefore 8-connectivity for objects, and requires         1000
  1100    4-connectivity of the background to separate them, for     1100
          example as right.

For example, ANALYSE treats the configuration above left as a single object,
but that above right as two;  ERODE SKELETON produces a skeleton that is 8-
but not 4-connected;  DILATE SEPARATELY (iterated indefinitely) shrinks the
background to a 4-connected skeleton, so as to maintain separation of objects.
$add motif.command motif average
You use MOTIF to recover a clear 'motif' from a picture containing many noisy
instances of it (randomly positioned but uniformly oriented), by averaging
regions centred at positions defined in a previously prepared Plist.

Exx: MOTIF TO 10 SIZE 60,40 WITH 3
       produces a new picture 10, 60 points by 40, by averaging regions of the
       current picture around the positions listed in Plist 3
     MOTIF WITH 3 NUMBERS 1,80
       averages the first 80 positions listed only
     XCF 1 WITH 2 TO 3; SURVEY FULL; PEAKS THRESHOLD 3*SD
     MOTIF 2 TO 3 EVEN; MOTIF 2 TO 4 ODD
       locates positions in picture 2 matching a 'reference' picture 1, (given
       suitable image sizes and noise levels) and produces two independent
       averages over them in 3 and 4
$
MOTIF averages source picture regions 32 points square (or the SIZE indicated)
at each listed position far enough from the edge to prevent the picture bounds
being exceeded, and combines them in an average.  The positions are rounded to
integral values if necessary, and the number averaged is returned in the
variable N.  Producing two independent averages, as in the last example, may
help you distinguish signal from residual noise in the result.

If the positions are listed in a useful order (e.g., PEAKS normally lists peak
positions in height order), you may find it useful to restrict the average to
the 'best' positions only, as in the second example.

If you set the MARK key, the centres of the regions averaged are marked in a
mode determined by MKMODE and/or MKSIZE; option REGION causes the regions to
be outlined instead.

               Display marking: centre postition or border of regions averaged
          Multi-layer pictures: faulted
          Form used internally: fp

See also: motif.syntax, peaks
$add motif.syntax
Keys:
  [FROM]         source picture [SELECT]
  [TO]           output picture [FROM]
  SIZE(2)        dimensions of output [32,SIZE]
  WITH           Plist containing list of positions to be averaged [999]
  NUMBERS(2)     first,last positions to be averaged [all]
  MARK           display to be marked with centre positions or borders (REGION
                 option set) of regions averaged [none]
  MKMODE         mark mode [1]
  MKSIZE         mark size [2]

Options:
  EVEN|ODD       average even or odd numbered positions only [all]
  REGION         mark regions rather than centre positions if MARK
  VERIFY         list on the console the number of regions averaged

Variable set:
  N              number of regions averaged

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add mouse.command mouse
The command MOUSE defines the actions and/or position of the
mouse. In fact, this command defines the actions of the pointing
device which may be a graphics tablet, trackerball, etc. It is
called MOUSE for convenience.

Examples:
     MOUSE RIGHT 'mouse query;type uix, uiy'
     would print the current position of the mouse every time
     the right hand mouse (pointer) button was clicked.
$
Semper 6 Plus assumes that the pointing device has a maximum of
three buttons referred to as LEFT, CENTRE and RIGHT. For single
button mice, the LEFT button should be programmed, for two
button mice, the LEFT and RIGHT buttons.

The LEFT, CENTRE and RIGHT text keys define the action to be
taken when the appropriate button is pressed. If an action has
been defined for a button, the default action may be restored by
redefining the action with a null string (''). The default
actions for the mouse buttons when pressed are as follows:

     Left      Select elements on either the host display or
               the framestore. If there are elements on both
               displays at the position hit, then select the
               element on the host screen.

     Centre
     Right     Select elements on either the host display or
               the framestore. If there are elements on both
               displays at the position hit, then select the
               element on the framestore screen.

The POSITION keys (a pair of values) specify the cursor position
to which the mouse is to be moved. A similar function may be
achieved using the ID key which positions the cursor on an object
(a panel, cell, etc.). When using the ID key, the cursor is
positioned according to what justification was in force when the
cell was created. For example, if a cell was created with
(CENTRE, CENTRE) justification and the command 'MOUSE ID <cell>'
was given, the cursor would be positioned on the centre of the
cell.

The QUERY option returns the current pointer position in the
variables UIX and UIY. The option also sets the variable NBU to
the number of buttons available on the mouse. The device queried
depends upon the setting of the variable CDI (1 - host screen, 2
- framestore). It also sets ENO and PNO to the element (cell,
etc.) and panel numbers over which the cursor is positioned. If
the cursor is not on a panel or element the relevant variable is
set to minus one (-1).

If DEVICE ACTIVE has been used to limit interactions to a
single display, then both left and right buttons will only select
elements on panels on that display. The default settings are
reset if DEVICE ACTIVE 0 is used.

See also: mouse.syntax, device
$add mouse.syntax
Keys:
  CENTRE text  Defines the actions to be taken for the centre button.
  ID           Position the mouse pointer on an element, for example, a
               cell or a menu.
  LEFT text    Defines the actions to be taken for the left button.
  RIGHT text   Defines the actions to be taken for the right button.
  POSITION(2)  Positions the mouse pointer to the given position relative
               to the top left of the current device.

Options:
  QUERY        Queries the current mouse position.

Variables set:
  ENO,UIX      are set by MOUSE QUERY to the current mouse position, and PNO
  UIY,NBU,PNO  and ENO to the id of the panel and element over which the
               mouse is located.  UIX and UIY are set relative to the top
               left of the current device in device dependent coordinates.
               NBU is set to the number of buttons on the mouse.
  ENO,PNO      are set by MOUSE POSITION to the id of the panel and element
               over which the mouse is located when moved to the new position.

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add negate.command negate reverse
If you merely want to view a picture with reversed contrast, without changing
the pixels themselves, try DISPLAY NEGATED or simply LUT INVERT.

You use NEGATE to reverse the contrast of a picture, interchanging positive
and negative forms; it is equivalent to SURVEY; SCALE..RANGE MAX,MIN.

Exx: NEGATE DISPLAY TO 20
       places a reversed contrast version of DISPLAY in picture 20
     NEGATE 10
       reverses the contrast of picture 10, retaining the same range
     NEGATE 10 PRESET
       rescales picture 10 so as to interchange the current values of MIN,MAX
$
Multiplying by minus one of course also reverse the contrast of a picture, but
alters the data range as well; NEGATE effects the reversal without altering
the minimum and maximum values present in the picture, replacing source pixels
p by an output value p' = max + min - p.  Like SCALE, NEGATE truncates byte
values outside the range 0-255 to the nearer limit.

                  Multi-layer pictures: fully supported
                 Forms used internally: integer (for byte pictures),fp,complex

See also: negate.syntax
$add negate.syntax
Keys:
  [FROM]         source picture [SELECT]
  [TO]           output picture [FROM]

Options:
  PRESET         rescale between existing values of MIN,MAX rather than actual
                 min,max values present

Variables used:
  MIN,MAX        if PRESET, values to be interchanged by scaling

Variables set:
  MIN,MAX        unless PRESET, min and max pixel values

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add next.command next
The command NEXT NAME causes Semper to resume execution at the start of the
next cycle of the named FOR loop.

Exx: FOR N=1,5; SURVEY N; IF SD<15 NEXT N
     TYPE 'SD for picture ',N,' = ',SD; DISPLAY N; LOOP
       reports and displays pictures with SD values of at least 15

If you omit the loop variable name, the innermost loop active is assumed; thus
in the example

   FOR N=1,10; FOR M=N,10; FOR X =-5,5; .. ; LOOP; NEXT; LOOP; LOOP

the NEXT command jumps to the next cycle of the M loop.
$add noise.command noise poisson random
You use NOISE to generate pseudo-random noise limited versions of pictures,
perhaps to explore the noise-sensitivity of algorithms you are implementing.
Gaussian, uniform and negative exponential distributions are provided.

Exx: NOISE 1 TO 3 WIDTH .5
        adds gaussian distributed noise, with s.d. 0.5, to picture 1, storing
        the result as picture 3
     NOISE 51 DOSE 8
        replaces picture 51 by a poisson noise ('shot' noise) limited version,
        with an average of 8 quanta per pixel

In default, NOISE adds gaussian-distributed noise, with s.d. WIDTH (default
0.1); if you use the key DOSE to indicate the mean number of quanta per pixel
you require, it generates a poisson noise-limited version of the source
instead, re-scaled so that the output has the same mean as the source (and
hence a similar range); if you use option UNIFORM, it adds uniformly
distributed noise in the range 0 to WIDTH; and if you use option EXPONENTIAL
it adds negative exponentially distributed noise (typical of diffraction
patterns, i.e. power spectra) with s.d. WIDTH.
$
Where the source picture is complex, real and imaginary parts are processed
independently (with the same value of WIDTH).  In the poisson noise mode, the
source picture must be non-negative, and if the source picture mean is already
recorded in MEAN(,ME2) you can speed processing by using option PRESET which
causes NOISE to use the existing values in preference to scanning the picture
directly.  When used with the DOSE option, NOISE will fault any negative pixel
values in the source picture.

The random number generator 'seed' is held in Semper variable RNM, and you
can initiate reproducible 'random' sequences by setting this yourself.

                                  Multi-layer pictures: all layers processed
                                 Forms used internally: fp, complex

See also: noise.syntax
$add noise.syntax
Keys:
  [FROM]        source picture [SELECT]
  [TO]          output picture [FROM]
  WIDTH         width of noise distribution (s.d. if gaussian or negative
                exponential; maximum if uniform) [.1]
  DOSE          selects poisson noise mode; number of quanta per pixel
                desired [option dependent]

Options:
  UNIFORM | EXPONENTIAL  generate noise with uniform or negative exponential
                noise distribution [generate noise with gaussian distribution]
  PRESET        if DOSE, uses existing value of MEAN instead of determining
                actual pixel mean (speeding processing if the mean is known)

Variable used and set:
  RNM           random number generator seed; range 0 to 1

UNIFORM, EXPONENTIAL, and DOSE, are mutually exclusive alternatives.

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add syntax.notation
If you ask HELP about a topic NNNN.SYNTAX, it lists the keys, options and
other variables used by the processing command NNNN, with brief explanations
of their function.  These lists provide a more formal supplement to the
description given in response to HELP NNNN itself.

Essentially, each key, option or variable is described by a single line
giving its name, its function and its default value/state, e.g.

  FROM           source picture  [SELECT]

The default value, given in square brackets, is in most cases a Semper
expression evaluated at the time the command is interpreted; the example
above thus means that the current picture (whose number is always found in
the variable SELECT) is the default source picture for the operation.  In a
few cases, a simple verbal explanation - in lower case lettering - is given
instead.

Keys or options that are mutually exclusive alternatives, selecting different
modes of operation for the command, are given on a single line with | signs
intervening, e.g.

    PICTURE | PARTITION | FRAME   picture, partition or frame mode [PICTURE]
or
    - | PARTITION | FRAME   details..

if one mode is assumed unless you request another explicitly.

Square brackets around a key name mean that you may omit the name itself if
you wish; for example, the line

  [FROM]         source picture

in DISPLAY.SYNTAX covers both DISPLAY 51 and DISPLAY FROM 51.  If you are
using more than one such 'assumed' key, you must keep to the order in which
they are listed by HELP.

Empty square brackets mean that you always omit the name - usually because no
semantically satisfactory name exists (names such as $1 and $2 are in fact
used in these cases; for example, the line

  []             source picture

in RECLASS.SYNTAX means that you type RECLASS 51 to reclass picture 51.

Notations such as SIZE(2) (or 3 etc.) indicate keys which accept 2 (or 3 etc.)
values; for example, the line

  SIZE(3)        dimensions of subregion

in CUT.SYNTAX covers CUT SIZE 400 and CUT SIZE 400,300 and CUT SIZE 50,30,2.
Note that combinations such as [(2)] thus mean a key whose name you omit but
which takes up to two values - e.g. DELETE 10,12.

The word text following a key name means that you give a textstring as the key
value; for example, the line

  NAME text      file name

in ADD.SYNTAX means that you type commands such as ADD NAME 'MYFILE'; the line

  TEXT text      title text to be used

in TITLE.SYNTAX allows TITLE TEXT 'Plate number ',NP; and the line

  [] text        expression to be calculated

in CALCULATE.SYNTAX means that you type commands such as CALCULATE SIN(X+Y)

- remember that the term textstrings embraces expressions as well as literal
text.

Default values for options are either YES or NO; the default is omitted when
(as in most cases) the default is NO.  For example, the line

  BORDER         mark the picture border [YES]

in DISPLAY.SYNTAX means that the border is marked unless you use the option in
the form NOBORDER.

In most cases, the general keys and options are not listed in -.syntax
entries; they are general precisely because their use is both widespread and
systematic.  Details are given wherever thay are used in ways that are in
any sense unusual.
$add null.command null
If you begin a command with a number rather than a name, e.g.
   1
or
   6:34 TIMES 2
Semper assumes the command NULL, defined in most installations to be
equivalent to DISPLAY; the effect is thus to display the picture whose
number you type.
See DISPLAY.COMMAND for further details accordingly.

Note that this short cut should be avoided as it is not guaranteed to behave
the same way in all Semper installations, and may also be omitted from later
releases.
$add ocf.command ocf orient
You use OCF to determine the rotation necessary to bring two similar but
misoriented pictures into register, or to detect rotational periodicity in a
picture.

Exx: OCF 6 WITH 10 FULL
       sets THETA to the angle in radians by which 10 must be rotated
       clockwise for it to match 6
     PS 1 3; PS 2 4; OCF 3 WITH 4
       determines the misorientation of pictures 1 and 2, even if they are
       displaced laterally as well
     OCF RINGS 3 RADIUS 40,60 TO 91
       stores in picture 91 the auto-correlation function of the current
       picture with respect to orientation, calculated using samples taken on
       3 rings with radii 40, 50 and 60
$
OCF effectively rotates the two source pictures (FROM and WITH) about their
origins, tabulating the cross-correlation coefficients between sets of samples
taken on 5 rings with radii from one quarter to three quarters of the distance
to the nearest picture edge.  The angle giving the highest correlation level
is returned (in radians) as variable THETA; if you indicate an output picture
as in the last example, the correlation function is stored as a 1-D
Correlation picture.

To register pictures differing initially in position as well as orientation,
you can eliminate the unknown displacements by considering power spectra (as
in the second example) or auto-correlation functions, which are position-
independent.  They are also centro-symmetric (implying an orientational
ambiguity of 180 degrees), and OCF accordingly uses semi-circular rather than
full circular ring samples in default.  For registering other kinds of data
(e.g., pairs of images with an identifiable common point) you use option FULL.

A picture with fine detail has a spectrum that extends further out than one
with largely coarse detail, and an auto-correlation function that shows the
opposite behaviour; you select one or the other according to your application,
and can also control the radii at which samples are taken via the key RADII.
If your pictures are noisy, you may need to increase the number of rings
compared, via the key RINGS.

If the MARK key is set, the sample rings are marked on the indicated display
picture.
                                            Display marking: sample rings used
                                       Multi-layer pictures: faulted
                                      Forms used internally: fp,complex

See also: ocf.syntax
$add ocf.syntax
Keys:
  [FROM]         first source picture [SELECT]
  WITH           second source picture [none]
  TO             output picture receiving correlation function [none]
  RINGS          number of ring sections compared [5]
  RADIUS(2)      min,max radius of ring sections compared [one and three
                 quarters of the distance to the nearest picture edge]
  MARK           display to be marked with sample rings [none]

Options:
  FULL           correlate full circular rings [semi-circular]
  VERIFY         list on the console the correlation results

Variable set:
  THETA          angle by which second picture must be rotated clockwise
                 to match first; in radians

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add order.command order
Semper maintains a default search order amongst the various program libraries
assigned at a given time, which is verified by the command ORDER without
arguments.  Libraries are placed at the front of the list when they are
assigned; apart from this, the search order is only altered in response to
explicit ORDER commands you type:

Ex: ORDER 2
      moves device 2 to the front of the list, leaving the others unaffected
    ORDER 2,5,3
      moves each device in turn to the front of the list, leaving any others
      unaffected; if all devices are listed, this is equivalent to stipulating
      the final search order.

See also: order.syntax
$add order.syntax
Keys:
  [(9)]          device numbers in desired future search order

Options:
  VERIFY         confirm new program search order on the console [YES]

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add origin.command origin
You use ORIGIN to move the coordinate origin for a picture when you want to.

Exx: ORIGIN TOP LEFT
       records the origin for the current picture as being at the top left
     XWIRES; ORIGIN 51 @XY
       records an origin for picture 51 indicated with the cursor
     ORIGIN 4:23 RESET
       resets the origin of picture 4023 to its (class-dependent) default
       position
$
You use the standard 3-D subregion keys/options to indicate the origin
position, assuming SIZE 1,1,1).

The origin for Fourier transforms must be set according to whether the
transform is half-plane or full-plane.  A full-plane transform must have its
origin at the centre of the image, so you should use the command ORIGIN RESET
to set up the origin correctly.  A half-plane transform must have its origin
halfway down the left-hand side of the image, so in this case you should use
the command ORIGIN LEFT.

See also: origin.syntax
$add origin.syntax
Keys:
  []             picture whose origin is moved [SELECT]
  POSITION(3)    position of new origin relative to current origin or to
                 position indicated by options below [0,0,0]

Options:
  LEFT | RIGHT
  BOTTOM | TOP   move origin to indicated edge
  NEAR | FAR
  RESET          move origin to default position (except for half-plane
                 Fourier transforms)

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add output.command output write put files TIFF BMP
You use OUTPUT to output pictures in one of several fast binary forms.

Exx: OUTPUT 23 NAME 'binary' UNLABELLED
       writes picture 23 to the file binary.pic, excluding the picture label
     OUTPUT 12 RAW BYTE NAME 'rawdata'
       writes pictures 12 to the file rawdata.bin as a byte stream
     OUTPUT 14 RAW NAME 'local.dmp' SWAP
       writes picture 14 to the file local.dmp using Motorola byte ordering
     OUTPUT 303 RASTER NAME 'screen'
       writes picture 303 as a Sun Raster file named screen.rff
     OUTPUT 42 TIFF NAME 'image'
       writes picture 42 as a TIFF file named image.tif
     OUTPUT 1 BMP NAME 'bitmap' MAP 2
       writes picture 1 as a Windows BitMap file named bitmap.bmp using
       the contents of picture 2 as a colormap

Pictures produced by OUTPUT can be recovered by INPUT
$
OUTPUT writes a Semper 6 data file unless one of the options BMP, RAW,
RASTER or TIFF are given.


If the option BMP is given a Windows BitMap file is produced. If the source
image has 3 layers the file is output as a 24-bit BitMap (BitpsPerPixel=24).
Otherwise the file is written with a BitsPerPixel value of 8 (256 colours) and
a linear greyscale colormap, unless the key MAP is used. If MAP is specified
it must be a 256 by 3 picture, with the red data in row 1, green in row 2 and
blue in row 3. (On systems where the LUT length is 256, a suitable picture can
be generated using the LUT command with the TO key).

If the option RAW is given a raw binary file is produced. A raw data file is
a byte stream starting with the top left pixel of layer 1, outputting along
each row. Pixels are written to a raw data file using the form of the output
picture, unless one of the form options (BYTE, INTEGER, FP or COMPLEX) is
specified.

If the option RASTER is given a Sun Raster image is produced. Currently these
are always written with a depth of 8 bits per pixel, using standard packing
(type 1 - RT_STANDARD) and with no colormap information (RMT_NONE).

If the option TIFF is given a Tagged Image File Format (TIFF) image is
produced. For a three layer source image an uncompressed RGB file is written,
each pixel as an RGB triple or as a planar RGB file if the option PLANAR
is given. Otherwise a greyscale file is written with a depth of 8 bits
per pixel, black-to-white photometric interpretation and using no compression.
The data is always written contiguously for simple TIFF readers.

The byte ordering for the Semper 6 data file is little-endian (Intel format).
Files written using the OUTPUT command on a PC can be read into a workstation
linked over a PC-NFS type network.

Raw data files can be written using Motorola byte ordering by quoting the
SWAP option.

Semper 6 data files have the picture label included unless the option
UNLABELLED is given. The actual data written is as for WRITE, but with
as binary data with no formatting.

The default extension for Semper 6 files is .pic, for RAW files is .bin, for
SunRaster files is .RAS, for TIFF files .tif and for BMP files it is .bmp.

Output will not automatically overwrite existing files unless the NEW option
is given. If NEW is omitted and the session is interactive the user will be
asked to confirm that the existing file can be overwritten.

See also: output.syntax input read write
$add output.syntax
Keys:
  [FROM]           picture to be written [SELECT]
  NAME text        name of file to write the data into [none; prompts if
                   interactive]

Options:
  NEW              replace output file if it already exists

  BMP |            write an uncompressed Windows BitMap format file
  RASTER |         write a Sun Raster format file
  RAW |            write a raw binary data file
  TIFF             write an uncompressed TIFF file

  PLANAR           write RGB TIFF as three seperate planes

  SWAP             write data in Motorola byte order (RAW only)

  BYTE | INTEGER | write data as byte (8 bit), integer (16 bit), floating
  FP | COMPLEX     or complex (not BMP, RASTER or TIFF)

  UNLABELLED       write without including picture label information

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add overlay.command overlay 4sight sg gl xwindows display framestore extras
You use the OVERLAY command to control the colour and visibility of the
display window's eight overlays.  Display annotation or graphics is directed
to the current graphics overlay, rubberband lines are displayed in the
rubberband overlay and the cursor is displayed in the cursor overlay.
Overlays can be turned on and off without affecting the data stored in the
overlay bitplanes.  Where overlay information is overlapped, the highest
numbered overlay is displayed.

Exx:  OVERLAY SHOW
        lists the current overlay settings
      OVERLAY CYAN
        sets the colour of overlay 1 to cyan
      OVERLAY 3 HSV 60,50,100 CURSOR
        sets the colour of overlay 3 to a desaturated yellow and makes this
        the cursor overlay
      OVERLAY 2 OFF
        turns off overlay 2
      OVERLAY 5 ERASE
        erases overlay 5
$
The display window has eight overlay bit-planes numbered from 1 to 8.  You use
the NUMBER key to specify the overlay number.  Note that the NUMBER key always
defaults to 1.

The SHOW option causes all the current overlay settings to be listed on the
console.

When the display window is created, overlays 1, 7 and 8 are selected as the
graphics, rubberband and cursor overlays, all overlays are turned on and
cleared and the colours for overlays 1 to 8 are set to white, red, green,
blue, cyan, magenta, yellow and red respectively.

The OVERLAY command changes only the overlay settings that are specified with
the command.  The remaining overlay settings are left unchanged.

The overlay colour can be specified in one of three ways.  If you need to
specify the colour exactly, you can specify the RGB components of the colour
as percentages with the RGB key, or the hue, saturation and brightness of the
colour with the HSV key.  The saturation and brightness values must also be
specified as percentages.  If the colour you want is one of the eight primary
or secondary colours, you can use the corresponding colour option as a
convenient alternative.  You may not specify more than one of the options
BLACK, WHITE, RED, GREEN, BLUE, CYAN, MAGENTA and YELLOW and the RGB and HSV
keys at one time.

An overlay can be turned on or off (made visible or invisible) by specifying
the option ON or OFF.

You may use one of the GRAPHICS, RUBBERBAND or CURSOR options to make the
specified overlay the current graphics, rubberband or cursor overlay.  You are
not allowed to specify more than one function for a given overlay.  For
example, the following would not be allowed:

    OVERLAY 2 GRAPHICS; OVERLAY 2 RUBBERBAND

All display annotation is directed into the current graphics overlay.  Note
that the ERASE OVERLAY command erases only the current graphics overlay and
leaves the other seven overlays unchanged.  You can use the ERASE option with
the OVERLAY command to clear a specified overlay.  To clear all the overlays,
type the following command line:

    FOR N=1,8; OVERLAY N ERASE; LOOP N

The cursor and any rubberband lines or boxes (see the XWIRES and PDRAW
commands) are displayed by overwriting and erasing the data in the
corresponding overlays.  You are recommended to retain the highest numbered
overlay for displaying the cursor so that it is not obscured by any of the
other overlays.

See also: xwires, framestore
$add overlay.syntax
Keys:
  [NUMBER]       overlay number [1]
  RGB(3)         red, green and blue percentages of overlay colour [none]
  HSV(3)         hue (0 to 360), saturation (percentage) and brightness
                 (percentage) defining overlay colour [none]

Options:
  BLACK | WHITE | RED | GREEN | BLUE | CYAN | MAGENTA | YELLOW  overlay colour
  ON | OFF       overlay visibility
  GRAPHICS | RUBBERBAND | CURSOR  overlay function
  ERASE          clear the specified overlay
  SHOW           list current overlay settings

The keys RGB and HSV and any of the colour options are mutually exclusive.

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add ovread.command ovread overlay readback
OVREAD reads the data in the overlay plane of the specified display frame,
partition or picture and outputs this in image form to a Semper picture.

Exx: OVREAD DISPLAY TO 2
       read the contents of the overlay for the current display picture into
       picture 2
     OVREAD FRAME 1 SIZ 200 TOP LEFT TO 3:1
       read the contents of the 200 square region at the top left of display
       frame 1 to picture 3:1
$
OVREAD creates a byte class picture with a size that is determined by the
dimensions of the source sub-region in display units (display pixels).  This
ignores the effect of any under-sampling when addressing a display picture as
the source region, i.e. a 400 square picture displayed with under-sampling of
2 occupies a region 200 square region on the display and OVREAD will create
a 200 square picture when reading back from this display picture.

The 2-D sub-region keys and options may be used to specify a sub-region of the
frame/partition/picture in question.  Note that when addressing a display
picture, the sub-region is still defined in the original picture coordinate
frame, even though the output size is independent of this, e.g. in the example
above, specifying a sub-region size of 60 by 40 gives an output picture size
of 30 by 20.

For complex display pictures, where the real and imaginary parts of the image
are displayed side by side, OVREAD would normally read back from the real
part.  If, however, you specify the option IM, OVREAD will read back from the
imaginary part.

See also: ovread.syntax
$add ovread.syntax
Keys:
  []             picture/partition/frame to be read back [DISPLAY if picture
                 or partition; CFRAME if frame]
  [TO]           output picture [SELECT]
  SIZE(2)        dimensions of subregion to be read back [whole region]
  POSITION(2)    position/offset of subregion [0,0]

Options:
  PICTURE | PARTITION | FRAME  use indicated coordinate system [PICTURE]
  LEFT | RIGHT   read back subregion abutting indicated border
  BOTTOM | TOP
  RE | IM        read back from the real or imaginary part of complex display
                 picture [read back from real part]

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add ovwrite.command ovwrite overlay write
OVWRITE writes the data in the source picture into the overlay plane of the
specified display frame, partition or picture.  The data is positioned so that
the source picture origin coincides with the graphics origin.  The source
data is converted into binary form by thresholding it.

Exx: OVWRITE DISPLAY WITH 1
       overlay the image in picture 1 onto the current display picture,
       setting overlay pixels where the source pixels are greater than or
       equal than the mid-range value.
     OVWRITE FRAME 1 WITH 2 THRESHOLD 20
       overlay the image in picture 2 onto the central region of display
       frame 1, using a threshold value of 20.
     OVWRITE DIS:2 NEGATED CLIP
       overlay the image in the current picture onto display picture 2,
       setting overlay pixels where the source pixels are below the mid-range
       value and clipping the output at the limits of the display picture.
$
OVWRITE overlays a source image onto the target region of the display which
can be a frame, partition or picture.  In each case the image is aligned so
that the source origin coincides with the graphics origin on the display.

Since the overlay plane is only 1 bit deep, the source image is converted into
binary form by thresholding it.  You may specify the threshold value directly
by means of the THRESHOLD key, otherwise, the threshold value defaults to the
middle of the range of source picture values.  Overlay pixels are set to 1
where source pixels are greater than or equal than the threshold value and set
to 0 elsewhere.  If the option NEGATED is specified, the thresholding
condition is reversed (overlay pixels are set where source pixels are less
than the threshold value).

The image is clipped at the graphics clipping limits (frame limits for a
frame, and partition limits for a partition or picture), unless the CLIP
option is specified, in which case the image is clipped at the graphics border
limits (for a picture these are the limits of the display picture itself).

If the source picture has more than one layer, the LAYER key can be set to
select a given layer.  In default, OVWRITE processes the first layer.

For complex display pictures, where the real and imaginary parts of the image
are displayed side by side, OVWRITE would normally write to both parts.  If,
however, you specify the option RE or IM, only the real or imaginary part will
be written to.

See also: ovwrite.syntax
$add ovwrite.syntax
Keys:
  []             picture/partition/frame to be written to [DISPLAY if picture
                 or partition; CFRAME if frame]
  [WITH]         source picture [SELECT]
  THRESHOLD      threshold value [middle of source picture range]
  LAYER          source picture layer [1]

Options:
  PICTURE | PARTITION | FRAME  use indicated coordinate system [PICTURE]
  NEGATED        invert thresholding condition
  CLIP           clip data at border limits
  RE | IM        write to real or imaginary part of complex display picture
                 [write to both parts]
  VIEW           switch view to make display region visible

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add page.command page terminal output wrap truncate prompt aspect ratio
You use the PAGE command to control how output to the terminal is formatted.

The WIDTH and LENGTH keys specify default dimensions for the terminal and are
used to configure output to the terminal.  If these dimensions exceed the
current size of the terminal window they will be truncated before they are
used.  The ASPECT key specifies the aspect ratio for characters displayed on
the terminal.  You can find out what the current page size is by setting the
option ENQUIRE.  This causes the variables PWIDTH and PLENGTH to be set to
the current page size

Each line of text output to the terminal is truncated to the current terminal
width unless the option WRAP is specified in the PAGE command, in which case
the line wraps-around onto subsequent lines.  Note that the size of the
terminal window may vary if Semper is being run on an engineering workstation.

Text displayed at the terminal will scroll as each line of text is output to
the terminal.  If the first line of text output since the last interactive
command was issued has scrolled up to the top of the terminal window, a page
prompt will be displayed.  This gives you the option to step forwards a line
or a page at a time or to quit out of the current sequence of commands.  The
page prompt can be suppressed by specifiying the NOPROMPT option in the PAGE
command.  The option to quit in response to the page prompt can be disabled by
setting the NOQUIT option in the PAGE commmand.  When the page prompt next
appears on the terminal, the 'quit' option in the page prompt will be omitted.

Exx: PAGE WIDTH 72 LENGTH 20 ASPECT 2.5
       sets up default terminal window size and character aspect ratio
     PAGE WRAP
       cause terminal output to wrap-around
     PAGE NOPROMPT
       suppress page prompt
$
The settings for the PAGE command at the start of a Semper session are as
follows:

     PAGE WIDTH 79 LENGTH 24 ASPECT 2.00 NOWRAP PROMPT

You would use the PAGE command at the start of a Semper session to change any
of the initial values that are not appropriate for your own terminal.

The command SHOW PAGE will list the current settings for the PAGE command.

See also: page.syntax
$add page.syntax
Keys:
  WIDTH           set terminal width
  LENGTH          set terminal page length
  ASPECT          set character aspect ratio

Options:
  [NO]WRAP        truncate/wrap terminal output [NOWRAP]
  [NO]PROMPT      enable/disable page prompt [PROMPT]
  [NO]QUIT        enable/disable QUIT option in page prompt [QUIT]
  ENQUIRE         set variables PWIDTH and PLENGTH to the current page size

Variables set:
  PWIDTH          if ENQUIRE, current page width
  PLENGTH         if ENQUIRE. current page length

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add panel.command panel
The command PANEL controls the creation and operations of
Semper 6 Plus panels.

Examples:
     PANEL CREATE
     creates a new, permanently visible, panel on the default device

     PANEL CREATE TRANSIENT ON FDI SIZE 40,10
     creates a new transient panel on the device FDI of size 40 by 10
$
There are two panel types, FIXED and TRANSIENT. FIXED panels
remain visible after they have been shown for the first time
until either they are destroyed or Semper 6 Plus is exited.
Conversely, a TRANSIENT panel may be hidden, moved around and re-
displayed again.

The AUTO option is intended to allow panels to be built so that
they are just big enough to contain the elements placed upon
them. The automatic sizing will only take place before the
fixed panels are shown on the screen, or while transient panels
are hidden. Any elements on an AUTO panel will retain their
position relative to each other, but when the size of the panel
is calculated, they will be moved so that the topmost and
leftmost element is at the top and left of the panel.

The MANDATORY option is included so that panels can be created
to gather information without which processing cannot continue.
If a mandatory panel is transient and not showing, then
interactions are allowed with any panel until it is showing.
If a mandatory panel is showing, then interactions are only
allowed with this panel, regardless of the setting of DEVICE
ACTIVE. Care should be taken to avoid popping up other panels,
etc. when a MANDATORY panel is showing as this will cause an
error.

Note that the size of the panel will be assumed to include a one
character wide border to allow for drawing a box around the
panel, which must be allowed for when defining the size.

By default, the foreground colour for newly created panels is 1
and the background is 0. The default values may be over-ridden by
using the FOREGROUND and BACKGROUND keys. The effect of
specifying a colour number which is higher than that returned in
NCO by DEVICE QUERY is undefined. It is possible to change the
colour of TRANSIENT panels after they have been created but they
must be hidden and redisplayed for this to be visible.

See also: panel.syntax
$add panel.syntax
Keys:
  BACKGROUND     Specifies the background colour of the panel.
  FOREGROUND     Specifies the foreground colour of the panel. The foreground
                 colour is that used for lines and text drawing.
  ID             Defines the panel on which to carry out actions [PNO].
  NAME text      Specifies the name to be given to the panel.
  ON             Specifies the device for the panel [CDI].
  POSITION(2)    Specifies position of the currently set location point
                 (justification) of the panel on the required device in device
                 dependent co-ordinates.
  SIZE(2)        Specifies X,Y size of the panel in device dependent
                 coordinates. If used with the AUTO option, the size given is
                 treated as the minimum size for the panel and will be
                 overridden if the elements comprising the panel dictate that
                 it must be larger.

Options:
  AUTO           Specifies that the panel size is defined automatically from
                 the extents of the elements which are added to it
                 subsequently.
  CREATE         Specifies that a new panel is to be created.
  DESTROY        Specifies that the panel is to be destroyed. All elements on
                 the panel are destroyed.
  HIDE           Requests that the transient panel is made invisible. Has no
                 effect on fixed panels.
  MANDATORY      Specifies that the panel is mandatory, i.e. only interactions
                 with elements on this panel are allowed.
  SHOW           Requests that the transient panel is made visible, and
                 processed. Has no effect on fixed panels except for the
                 first time.
  TRANSIENT      Specifies that the panel is transient, i.e. normally
                 invisible, but made visible by PANEL SHOW.

Variables set:
  PNO            Set by PANEL CREATE to the identifier of the newly created
                 panel. Also set by PANEL SHOW to the id of the panel last
                 shown.

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add particle.analysis analysis pplists features measurement objects +
 particles segmentedpictures
Semper's facilities for particle analysis (object analysis, object feature
measurement etc.) are centred on the ANALYSE command.  Briefly, you choose
intensity thresholds to delineate particles, use ANALYSE to count and measure
them, and then other commands to type, display or process the measured values.
An outline of the whole process appears below, with details available
separately.

Firstly, you use commands such as LUT KEYS (see LUT.COMMAND), followed by
key H to adjust intensity thresholds until you are satisfied; if you cannot
achieve proper particle separation by thresholding, you can use PDRAW to
edit the picture by hand as necessary.

You then use ANALYSE, usually passing the thresholds across via variables;
this generates a list of all the particles found, together with 25 basic
position/size/shape measurements for each one, a full list of which is given
in PARTICLE.PARAMETERS.  The output is called a 'particle parameter list', or
'ppl', and is held as a class Plist picture for later use.  The following
commands can then be used to type, display or recover the measured values:

  PHISTOGRAM  Generates histogram based on one of the particle parameters,
            for a selection of particles
  PMARK     Marks selected particles or parameter values on the display
  PSET      Returns selected particle parameter values in variables
  PTYPE     Types selected particle parameter values

If you are totally unable to achieve adequate particle separation by
thresholding, you can at least draw round one particle at a time particle with
XWIRES CLOSED CURVE, and use PCURVE instead of ANALYSE.

As an option, ANALYSE generates a 'segmented' version of the picture scanned,
in which all pixels belonging to a given particle are set to a particle
identifier (1,2,3...)  This is used to tell later commands which particle each
pixel belongs to:

  PCALCULATE Calculates further parameters for single particle
  PEDIT     Edits contents of particle parameter list and/or segmented picture
  PEXTRACT  Generates picture containing image of single particle
  PFERET    Calculates up to 9 feret diameters for single particle
  PID       Identifies the particle containing a given pixel
  PSHOW     Highlights selected particles on the display

Some of these commands make further measurements on the original picture
analysed.  In general, subsequent commands may accordingly need more several
source picture numbers; you do not usually need to retype these directly
however, as a set of variables are used to carry their number between commands
(see PA.PICTURENUMBERS), and you only need to be aware of them if you want
to handle several different ppls at once, or resume in a later Semper session
some analysis you left incomplete earlier.
$add particle.parameters pa.parameters pplist
The ANALYSE command records 25 parameters for each particle it finds in a
'particle parameter list' (ppl), held by Semper as a class Plist (position
list) picture.  For subsequent purposes, each parameter has a name and a
variable associated with it, as listed below: the names are used to specify
or select individual or sets of parameters in later printout, sorting or
display commands; and the variables are used to receive individual parameter
values for further manipulation (see PSET).

  Name             Variable       Parameter
  ----             --------       ---------
  XREF,YREF        XR,YR          Reference point
  ID               PID            Identifier
  PARENT           PA             Parent id
  HOLES            H              Number of holes
  BACKGROUND       BG             Background flag
  CONTACT          EC             Edge contact flag
  XMIN,XMAX        X1,X2          Limits - min,max X
  YMIN,YMAX        Y1,Y2                 - min,max Y
  HFERET,VFERET    HF,VF          Feret diameters - horizontal,vertical
  AFERET,BFERET    AF,BF                          - 45 degrees,135 degrees
  HPROJ,VPROJ      HP,VP          Projections - horizontal,vertical
  PERIMETER        P              Perimeter
  AREA             A              Area
  XCEN,YCEN        XC,YC          Centre of area
  MMIN,MMAX        M1,M2          Principal second moments of area - min,max
  ANGLE            THETA          Orientation
  CIRCULARITY      C              Circularity

For a detailed explanation of any parameter, use PP.-, where - is the name
of the parameter or the corresponding variable, e.g. PP.HOLES or PP.A.  All
positions and dimensions are recorded directly in terms of source picture
coordinates.

See also PA.ADDITIONAL for details of the additional parameters calculated
for single particles by PCALCULATE.
$add pp.ref pp.xref pp.yref pp.reference
The Reference Point recorded by ANALYSE for a particle (parameters XREF,YREF
variables XR,YR) is the position of the right-most pixel of its bottom-most
row, and serves as one record of a particle's position.

The point is guaranteed to be within the particle, which is not the case for
the Centre of Area (otherwise a better placed position reference for most
particles); it also lies on the perimeter of the particle, and so provides a
convenient starting point for some of the extra particle calculations.
$add pp.identifier pp.pid
The Identifier recorded by ANALYSE for a particle (parameter ID; variable PID)
is an identifying integer, unique within the field analysed.  Ids are assigned
from 1 upwards, in the order in which the particles are found during the
picture scan (top to bottom, left to right).

When a segmented output picture is generated, (see ANALYSE), the pixels
belonging to a given particle are set to the correponding particle id, with
background pixels (those which belong to no particle) being assigned id zero.
$add pp.parent
The Parent Id recorded by ANALYSE for a particle (parameter PARENT; variable
PA) is the Identifier for the region surrounding the particle.  In the present
release of Semper, this is currently zero for all particles (indicating that
they are surrounded by background pixels); in due course, the parameter will
provide information about nesting of particles and holes, with holes within
particles being counted as background particles (see PP.BACKGROUND).
$add pp.holes
The Number of Holes recorded by ANALYSE for a particle (parmeter HOLES;
variable H) is the number of distinct background areas enclosed within the
particle.
$add pp.background pp.bg
The Background Flag recorded by ANALYSE for a particle (parameter BACKGROUND;
variable BG) particle will be used in later releases of Semper to indicate
that the 'particle' is in fact a background area (hole) enclosed inside
another particle.  Currently it is set to zero for all particles.
$add pp.contact pp.ec pp.edge pp.border
The Edge Contact Flag recorded by ANALYSE for a particle (parameter CONTACT;
variable EC) particle is set to one if the particle makes contact with an
edge of the picture analysed, and to zero otherwise.  A non-zero value thus
implies that the particle has been truncated, and that the parameters measured
about it may therefore be unreliable.
$add pp.xmin pp.xmax pp.ymin pp.ymax pp.x1 pp.x2 pp.y1 pp.y2 pp.limits +
 pp.size
The Limits recorded by ANALYSE for a particle (parameters XMIN,XMAX,YMIN,YMAX;
variables X1,X2,Y1,Y2) are the minimum and maximum X and Y values of all
pixels belonging to the particle.

Taken together, the set defines a minimal rectangular area containing the
entire particle.
$add pp.hferet pp.vferet pp.aferet pp.bferet pp.feret pp.diameters
The Feret Diameters recorded by ANALYSE for a particle (parameters HFERET,
VFERET,AFERET,BFERET; variables HF,VF,AF,BF) are Feret or 'caliper' diameters
in 4 different directions - horizontally, vertically, at 45 anticlockwise from
the +X axis, and at 45 degrees clockwise from it.  As well as providing rough
size indicators, these can be used to detect elongation (via a large
difference between minimum and maximum diameters) and orientiation (via which
diameter is the largest).

It will be obvious from the above that HFERET is simply XMAX-XMIN+1, and
VFERET is YMAX-YMIN+1.
$add pp.hproj pp.vproj pp.hp pp.vp pp.projections
The Horizontal (and Vertical Projections recorded by ANALYSE for a particle
(parameters HPROJ,VPROJ; variables HP.VP) are 'projections' in an unusual
sense: they record the total the total number of right-facing (and
upward-facing) edge pixels for the object, or more loosely, the total
projected edge length facing the relevant direction.

An entirely convex particle (one with no indentations) has a horizontal
projection equalling its vertical Feret diameter, and vice versa; less simple
particles have projections that are larger however.  For example, something in
the shape of letter S has a vertical projection nearly three times the
horizontal Feret diameter.
$add pp.perimeter
The Perimeter recorded by ANALYSE for a particle (parameter PERIMETER;
variable P) is the length of the particle perimeter.  Diagonal distances are
used as appropriate in calculating the length, and a small correction is
applied at corners between horizontal and vertical edges; the resulting value
is accurate to within 1% for most particles, and at its least reliable for
very small particles.
$add pp.area
The Area recorded by ANALYSE for a particle (parameter AREA; variable A) is
simply the number of pixels in a particle.

See also: pa.additional
$add pp.centre pp.xcen pp.ycen
The Centre of Area recorded by ANALYSE for a particle (parameters XCEN,YCEN;
variables XC,YC) are the mean X and Y values for all pixels belonging to the
particle.  In many cases, it is a preferable reference point to that provided
by XREF,YREF, since it lies roughly at the centre of the particle; however it
may lie physically outside a particle of complex shape (e.g. a horse shoe).

See also: pa.additional
$add pp.mmin pp.mmax pp.m1 pp.m2 pp.moments pp.secondmoments
A second moment is the mean square distance of all pixels from an axis
through the centre of area in a given direction.  The Principal Second Moments
recorded by ANALYSE for a particle (parameters MMIN,MMAX; variables M1,M2) are
the second moments with respect to a pair of mutually perpendicular axes in
directions that achieve maximum and minimum moments (mathematically, the
principal axes of the second moment of area tensor).

Their square roots provide a relatively robust and accurate measure of
particle size, and their ratio a measure of elongation.

See also: pa.additional
$add pp.angle pp.theta pp.orientation
The Orientation recorded by ANALYSE for a particle (parameter ANGLE; variable
THETA) is the angle in radians clockwise from the +X axis to the axis giving
the lowest second moment of area - i.e. the 'long' axis of the particle.

The values recorded are always in the range -PI/2 to PI/2 (the measurement
having an intrinsic ambiguity of PI); if the two principal moments of area
are identical, i.e. if the particle is exactly circular, the orientation is
undefined and a zero value is recorded.

See also: pa.additional
$add pp.circularity
The Circularity recorded by ANALYSE for a particle (parameter CIRCULARITY;
variable C) measures, on a scale from 0 to 1, how nearly circular a particle
is; specifically, it is 4 * PI * AREA / (PERIMETER^2).

Values greater than one are sometimes recorded because of the approximations
used in calculating particle perimeters - particularly for particles with very
small areas.
$add pa.additional pp.i1 pp.i2 pp.si pp.mi pp.sdi pp.xcm pp.ycm +
 pp.mm1 pp.mm2 pp.phi pp.calculate cm
Besides the 25 basic parameters recorded by ANALYSE for each particle in a
given field, you can use PCALCULATE to measure some additional parameters, one
particle at a time. (The separation of the two sets is made in the interests
of speed, since many uses of ANALYSE do not require the additional
computationally expensive parameters.)

The additional parameters currently available are the range, total, mean and
standard deviation for pixel intensities belonging to a particle and the
intensity-weighted versions of the area, centre of area, principal second
moments and orientation - pixels are averaged with weights equal to their
value, rather than the equal weights used by ANALYSE - and are returned via
the following variables:

  Variable     Parameter
  --------     ---------
  I1,I2        Intensity range
  SI,MI        Total and mean intensity
  SDI          Standard deviation for intensity
  XCM,YCM      Centre of mass; X,Y coords (see also PP.CENTRE)
  MM1,MM2      Principal second moments of mass; minimum,maximum (see also
               PP.MOMENTS)
  PHI          Orientation (see also PP.ANGLE)
$add pa.picturenumbers pa.defaults pplist psegment pimage
Because particle analysis can involve several different pictures of different
types simultaneously, ANALYSE records the picture numbers concerned in
variables that are consulted by subsequent commands examining or printing
the results of the analysis, without your having to retype them frequently.
The variables are:

  PIMAGE     the source picture originally analysed
  PPLIST     the 'particle parameter list' in which the 25 basic parameters
             recorded for each particle found are stored
  PSEGMENT   the segmented version of the original picture (if any)

Ex: ANALYSE 3 GE 100 TO 101; PTYPE ALL
      analyses picture 3, storing the parameters in picture 101; it sets
      PIMAGE to 3 and PPLIST to 101; and the PTYPE command uses the PPLIST
      value to find the parameters it is to type

Another important variable used in a similar way is PID, set by the PID
and/or PSET commands to the identifier for a particular particle, and used
subsequently as the default id for PEXTRACT, PFERET and PCALCULATE.
$add pa.sort
The SORT key used by several commands concerned with presenting or processing
the particle size/shape measurements made by ANALYSE is unusual in that it
appears to take a parameter name as its value, which may be found confusing!
It allows you to request sorting of output values by any one of the particle
parameters recorded by ANALYSE (see PARTICLE.PARAMETERS); you give the
particle parameter name as the 'value' for the key.

Ex: PTYPE AREA PERIMETER SORT AREA
      types the area and perimeter of all particles, ordered by their areas

The key is always accompanied by options ASCENDING and DESCENDING, allowing
you to specify the sense of the sorting; the default is ASCENDING.
$
For those whom it bothers: Semper actually interprets the key by taking each
particle in turn, setting variables with the same names as the 25 parameters
to suitable values (locally), and then treating SORT as a textual key, and
evaluating what follows it as an expression the value of which indicates which
of the names appears following the word SORT in the original command.
$add pa.if pa.conditionals pa.unless
The IF and UNLESS keys used by several commands concerned with presenting or
processing the particle size/shape measurements made by ANALYSE each take a
textstring as their value, and expect the textstring to be a logical
expression selecting a group of particles of interest.  As well as all the
standard functions, and any (set) variables and constants you might need, the
expression may also contain as variables the names of any of the particle
parameters recorded by ANALYSE (see PARTICLE.PARAMETERS)

Exx: PTYPE AREA IF ID=4
       types the area of the particle with identifier 4
     PTYPE ... IF AREA>230 & CIRCULARITY<.3
       types information on particles with areas greater than 230 and
       circularity less than .3
     PHISTOGRAM ANGLE IF M1/M2 > 2
       displays a histogram of the orientations of those particles for which
       the ratio of the two principal moments of area exceeds 2
$
For those whom it bothers: how Semper actually interprets these keys is to
take each particle in turn, to set the 25 parameter variables (locally) to
the appropriate values for the particle in question, and then to treat IF and
UNLESS as textual keys, evaluating the expressions that follow to determine
whether or not the condition expressed is satisfied by the particle in
question.
$add partition.command partition
You use PARTITION to define or redefine the position/dimensions of display
partitions, and to establish default luts for viewing them.

Exx: PARTITION DIS:3 SIZE 256 TOP LEFT
       makes DIS:3 the top left 256 square of frame 1
     PARTITION DIS:11 FRAME 2 LUT 3
       makes DIS:11 refer to the whole of frame 2, and makes lut 3 the viewing
       default
     PARTITION DIS:4 FRAME 1,3
       makes DIS:4 refer to the whole of frames 1, 2 and 3 (suitable for the
       display of full colour pictures)
     LIBRARY PARTITIONS
       runs a program that defines partitions dividing a frame into several
       rows and columns, prompting at the terminal for all details
$
A partition defines a sub-region of the display.  You use the standard 2D
sub-region keys to specify the X and Y limits of the partition (in frame
coordinates) and the FRAME key to specify a range of frames for the partition.
Pictures are displayed by directing them into a partition.  Partitions
therefore provide an easy way for you to organise the display/storage of
images and annotation within the framestore.

You can override the default lut for a partition by giving a different number
in a VIEW command (e.g. VIEW LUT 2), or by assigning a different default (e.g.
LUT=2); the default mechanism allows you however to attach monochrome / false
colour / full colour assumptions to individual partitions if you wish.

Redefining a partition causes any picture in it to be deleted, though not
actually erased; use a suitable CREATE DISPLAY if you want further access to
it. Partitions may overlap each other freely, and be redefined as often as is
desired - for example, defining a new partition enclosing two initially
distinct displays will allow you to treat them as one.

To delete a partition altogether, use option DELETE, e.g. PARTITION DELETE 3.

See also: partition.syntax
$add partition.syntax
Keys:
  [NUMBER]       partition to be defined/deleted/enquired [DISPLAY]
  SIZE(2)        partition dimensions [whole frame]
  POSITION(2)    position/offset of partition [0,0]
  FRAME(2)       first and last frame number for partition [1,FRAME]
  LUT            default lut number for viewing partition [1]

Options:
  LEFT | RIGHT   define partition abutting indicated frame border
  BOTTOM | TOP
  DELETE         delete partition [NO]
  ENQUIRE        report partition size and position by setting variables [NO]

Variables set:
  PSIZE(2)       partition size
  PPOSITION(2)   partition centre position
  PFRAME(2)      first and last frame number for partition

See SUBREGIONS for more details of subregion keys/options.

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add paste.command paste insert
You use PASTE to insert one picture in another: it does the opposite job to
CUT.

Exx: PASTE 1 TO 2 TOP LEFT
       inserts picture 1 at the top left of picture 2
     XWIRES; PASTE 50 TO 51 @XY
       inserts picture 50 into picture 51 centred at the position indicated
     PASTE 90 LAYER 2
       inserts picture 90 as layer 2 of the current picture

The output picture (TO) must already exist.  You use the standard keys/opts to
position the picture to be inserted; any parts that overflow the source are
ignored.

If the MARK key is set, the border of the output region is marked on the
indicated display picture.
$
                                           Display marking: subregion altered
                                      Multi-layer pictures: fully supported
                                     Forms used internally: integer,fp,complex

See also: paste.syntax
$add paste.syntax
Keys:
  [FROM]         source picture [SELECT]
  [TO]           destination picture [SELECT]
  POSITION(3)    position/offset of region pasted to [0,0,0]
  LAYER(2)       range of output layers to paste into [paste region positioned
                 according to POSITION]
  MARK           display to be marked with border indicating target subregion
                 [none]

Options:
  LEFT | RIGHT
  BOTTOM | TOP   paste to subregion abutting indicated border
  NEAR | FAR

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add pcalculate.command pcalculate
PCALCULATE is one of the commands you can use after the ANALYSE command.  It
uses the particle paramenter list (ppl) and segmented picture produced by
ANALYSE, as well as the original picture analysed and calculates several
further parameters for a single particle, using the actual pixel values rather
than a binary mask.

Exx: PCALCULATE ID 26
       measures further parameters for the particle with identifier 26; sets
       variables SI,MI..PHI to their values and types them on the console
     PCALCULATE IMAGE 4 ID 26
       does the same, but taking the particle from picture 4 instead of PIMAGE

The additional parameters are returned in the following variables:
  I1,I2        Intensity range
  SI,MI        Total and mean intensity
  SDI          Standard deviation for intensity
  XCM,YCM      Centre of mass; X,Y coordinates
  MM1,MM2      Principal second moments of mass; minimum,maximum
  PHI          Orientation
$
You can use the keys IMAGE, SEGMENT and PLIST to specify a different original
picture, segmented picture or ppl from the current defaults.  Option NOVERIFY
may be used to suppress the listing on the console of the measured values.

See also: pcalculate.syntax, analyse, pa.additional
$add pcalculate.syntax
Keys:
  [ID]           identifier of particle to be measured [PID]
  [IMAGE]        original image containing particle [PIMAGE]
  [SEGMENT]      segmented picture produced by ANALYSE [PSEGMENT]
  [PLIST]        particle parameter list produced by ANALYSE [PPLIST]

Options:
  VERIFY         print results on the console [YES]

Variables used:
  PID            default identifier for particle
  PIMAGE         default picture number for source image
  PPLIST         default picture number for particle parameter list
  PSEGMENT       default picture number for segmented picture

Variables set:
  I1,I2          intensity range - minimum,maximum
  SI             total intensity
  MI             mean intensity
  SDI            standard deviation for intensity
  XCM,YCM        centre of mass - X,Y coordinates
  MM1,MM2        principal second moments of mass - minimum,maximum
  PHI            orientation of long axis of mass

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add pcb.command pcb dimensions classes forms writeprotect wp +
     coordinates coords
PCB retrieves 'picture control block' information for a picture, setting
variables X1,X2, Y1,Y2 and Z1,Z2 to the ranges of the X, Y and Z coordinates,
NCOLS, NROWS and NLAYS to the dimensions, CLASS to the class number, FORM to
the form number and WPF to YES or NO (write protction flag) - you may want to
use these in short command sequences.  A better alternative to using the PCB
command is to use the PICTURE command which can provide more information about
a picture and is easier to use.

Exx: PCB 50; FOR X=X1,X2; P X,0=0; LOOP
       sets the central row of picture 50 to zero
     PCB; UNLESS CLASS=3 | CLASS=4 ..
       tests whether the current picture is class Fourier or Spectrum
     PCB; SURVEY FULL; TYPE MEAN*NCOLS*NROWS
       types the sum of all the pixels in a 2-D picture

NOTE: CLASS and FORM should be unset as soon after the PCB command as
      is possible.  This is because they will interfere with the operation
      of several other commands (notably most of the UIF commands and the
      WAIT command). If you require to keep their values, put them into
      another variable.

Exx:
	PCB; MYFORM = FORM; UNSET FORM,CLASS

See also: pcb.syntax, picture
$add pcb.syntax
Key:
  [FROM]         picture whose parameters are required [SELECT]

Variables set:
  X1,X2          X coordinate range
  Y1,Y2          Y coordinate range
  Z1,Z2          z coordinate range
  NCOLS          number of columns
  NROWS          number of rows
  NLAYS          number of layers
  CLASS          picture class (see CLASSES for class numbers)
  FORM           data form (see FORMS for form numbers)
  WPF            write-protection flag (YES if write-protected, NO otherwise)

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add pct.command pct principal.components hotelling.transform hotelling
The PCT command performs a Principal Component Transform or Hotelling
Transform.

Exx: PCT 1 2 COVARIANCE 3
       transforms picture 1 to picture 2 using the covariance details stored
       in picture 3
     PCT 1 2 COVARIANCE 3 EIGEN 4
       as above but store the eigenvalues and eigenvectors in picture 4
     PCT 2 5 COVARIANCE 3 INVERSE
       perform an inverse transform from picture 2 to picture 5, the
       covariance matrix being held in picture 3
$
This command performs a Principal Component Transformation (or Hotelling
Transform).  The forwards Hotelling transform is calculated as follows:

     [O] = [G] * ([I] - [Mo])

and its inverse is

     [O] = [G]-1 * [I] + Mo

and the non-mean adjusted transform is

     [O] = [G] * [I]

where [I] is the source picture, [G] is the eigenmatrix derived from the
covariance matrix, [O] is the output picture and [Mo] is the mean vector of
the picture from which the statistics were obtained.  You use the COVARIANCE
command to generate the required picture statistics.

The number of columns of the covariance matrix and the number of source
picture layers must be the same.  The eigenvalues and eigenvectrs are
determined using Jacobi's iterative method.  This relies on the fact that the
covariance matrix is symmetric.  This is always the case for covariance data
generated by the COVARIANCE command. If the covariance data is not symmetric,
the PCT command will fail if the number of iterations exceeds a certain limit.

The source picture must contain at least two layers.  The maximum number of
layers that can be processed depends on the number of columns in the source
picture and the length of Semper row buffers.  PCT will complain about
pictures which contain complex data.

Output data is always positive but even for byte input data, the output can
exceed the byte range of 0 to 255.  If the input data form is Byte and a
forward transform is being calculated, you can specify the STRETCH option to
rescale the output data into the range 0 to 255. Normally, the scaling factor
is determined directly from the range of the resulting transform.  If you
specify the ESTIMATE option instead, an estimate of the output range is
obtained by transforming the data ranges for the source layers.  This is
likely to give an overestimate for the output range, but it means that the
output data can be scaled immediately into byte form.

See also: pct.syntax, covariance
$add pct.syntax
Keys:
  [FROM]         multi-layer source picture [SELECT]
  [TO]           output picture [FROM]
  COVARIANCE     picture containing the covariance matrix (must be given if
                 INVERSE is set) [covariance matrix obtained from source data]
  EIGEN          output picture for eigenvalues and eigenvectors [none]
  SIZE(2)        dimensions of subregion to be processes [whole picture]
  POSITION(2)    position/offset of subregion [0,0]

Options:
  HOTELLING      perform Hotelling transform [perform transform without
                 adjusting the mean]
  INVERSE        perform inverse transform [perform forward transform]
  STRETCH        if INVERSE not set and input form is Byte, rescale output
                 data into range 0 to 255
  ESTIMATE       estimate output range using source data ranges
  LEFT | RIGHT   process subregion abutting indicated picture border
  TOP | BOTTOM

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add pcurve.command pcurve
You can use PCURVE to make measurements equivalent to those made
by ANALYSE and PCALCULATE for a 'particle' outlined by an arbitrary
closed curve you supply in the form of a Plist (See ANALYSE and PCALCULATE).

When a source picture is specified, PCURVE produces the same picture
statistics as SURVEY (See SURVEY) but for the region enclosed by the
curve instead of a rectangular region.

Exx: XWIRES CLOSED CURVE; PCURVE
       measures the 25 parameters normally measured by ANALYSE for the region
       you draw round with the cursor, sets variables to their values, and
       types their values on the console
     PCURVE IMAGE DISPLAY
       does the same, but including the 10 additional parameters normally
       measured by PCALCULATE, taking pixel values from the display
     PCURVE 51
       measures the parameters for the curve in Plist 51

See PARTICLE.PARAMETERS and PA.ADDITIONAL for details of the parameters
measured and the variables set to their values.
$
You may use the NOVERIFY option to suppress the listing on the console of the
values measured.

Most parameters are calculated exactly rather than on the basis of the pixels
included within the curve.  The centre of area, second moments of area, the
direction of lowest second moment of area and all the intensity related
parameters are calculated on the latter basis however, and an additional
variable NP (number of pixels) returns the area calculated on this basis as
well.  The variables PID, PA, H, BG and EC (which the commands PID and PSET
would also set) are not meaningful for a closed curve taken in isolation, and
are not set by PCURVE.

See also: pcurve.syntax, pcalculate, particle.parameters, pa.additional
$add pcurve.syntax
Keys:
  [WITH]         Plist containing closed curve definition [999]
  IMAGE          source picture for measuring intensity-weighted parameters
                 [intensity-weighted parameters not measured]

Options:
  VERIFY         print results on the console [YES]

Variables set:
  XR,YR          reference point
  X1,X2          X limits - minimum,maximum
  Y1,Y2          Y limits - minimum,maximum
  HF,VF          feret diameters - horizontal,vertical
  AF,BF          feret diameters - 45 degrees,135 degrees
  HP,VP          projections - horizontal,vertical
  P              curve perimeter
  A              area enclosed by curve
  NP             number of pixels enclosed by curve
  XC,YC          centre of area - X,Y coordinates
  M1,M2          principal second moments of area - minimum,maximum
  THETA          orientation of long axis of area
  C              circularity
  I1,I2          intensity range
  SI             total intensity
  MI             mean intensity
  SDI            standard deviation for intensity
  XCM,YCM        centre of mass - X,Y coordinates
  MM1,MM2        principal second moments of mass - minimum,maximum
  PHI            orientation of long axis of mass

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add pdraw.command pdraw
You use PDRAW to make minor adjustments to pictures, drawing lines or curves
to separate or join particles where thresholding does not achieve the desired
result.

Exx: PDRAW
       lets you draw a line/curve on the current display, along which picture
       PIMAGE is reset to zero so as to separate particles initially touching
     PDRAW 11 PICTURE DIS:3 VALUE MAX
       lets you mark a curve curve on DISPLAY:3 along which picture 11 is
       reset to MAX, so as to join particles initially separated

You indicate the display on which want to draw via the first assumed key
(default DISPLAY), and the image you want to modify via the key IMAGE (default
PIMAGE).  You indicate a curve via two or more points, terminating by
repeating your last point (to within a finite tolerance).  The band of pixels
reset in the picture is wide enough to prevent diagonal contact between points
on the two sides of the curve (PDRAW generates 4-connected lines of pixels).

See also: pdraw.syntax
$add pdraw.syntax
Keys:
  [PICTURE]      display picture on which you draw [DISPLAY]
  [IMAGE]        image whose pixels are modified (in situ) [PIMAGE]
  VALUE          value to which pixels are reset [0]
  POSITION(2)    initial cursor position [0,0]

Options:
  VERIFY         verify cursor input on display [YES]

Variables used:
  PIMAGE         default picture number for source image

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add peaks.command peaks search
You use PEAKS to locate local peaks in a picture and make a list of them,
sorted in order of descending size.

Exx: MAX=1; LIBRARY MOLECULE
     DISPLAY TIMES 4; PEAKS THRESH .5 MARK DISPLAY
       displays a small test picture, marks all the peaks, and lists their
       positions in Plist 999
     PEAKS THRESH 3*SD RADIUS 8
       locates/lists peaks higher than thrice the s.d., calculating centres of
       mass over regions 8 points in radius
     PS 1; SURVEY; PEAKS THRESHOLD MAX/5 SRADIUS 6
       (in principle) locates/lists all the peak positions in a power
       spectrum, suppressing any peaks within 6 pixels of a higher peak
$
The basic action of PEAKS is to search from the top left for points higher
than THRESHOLD (zero in default) at which the value is greater than the 8
neighbouring values (2 neighbours for 1-D pictures), that is, PEAKS locates
all the single-pixel local maxima in the source picture.

If your picture is noisy, you may find the two optional features triggered by
keys RADIUS and SRADIUS helpful.  If SRADIUS ('suppress radius') is set, lower
peaks within SRADIUS of any existing peak are suppressed.  If RADIUS is
set, raw peak positions are 'refined' by a local centre of mass determination
over a region with the indicated radius, exactly as if by FIND CM; you can use
the FIND options relevant to the centre of mass mode (SQUARED etc.) to adjust
the action as you wish.

The final list is sorted into descending order by peak height (or mass, if
c.m. calculation is included); the sorted positions (and heights/masses) are
then output as a Plist picture (number 999 in default), and listed on the
console if you use the VERIFY option; and their total number is returned in
variable N.

If the MARK key is set, all the peak positions found are marked on the
indicated display picture.
                                              Display marking: positions found
                                         Multi-layer pictures: faulted
                                         Form used internally: fp

See also: peaks.syntax
$add peaks.syntax
Keys:
  [FROM]         source picture [SELECT]
  [TO]           output Plist picture [999]
  THRESHOLD      minimum height of peaks listed [0]
  SRADIUS        radius from each peak within which any lower peaks are
                 discarded [none]
  RADIUS         radius around each peak over which a local centre-of-mass
                 is calculated to replace the raw peak position [0]
  MARK           display to be marked with peak positions [none]
  MKMODE         mark mode [1]
  MKSIZE         mark size [2]

Options:
  NEGATIVE       include negative pixels in c.m. search [YES]
  SQUARED        find c.m. of squared pixels
  ITERATED       repeat the c.m. location once, with a region shifted so as
                 to be centred at the c.m. found initially
  VERIFY         print results on the console

Variable set:
  N              number of peaks found

Options NEGATIVE, SQUARED and ITERATED are relevant only in the centre of mass
mode, i.e. when RADIUS is set.

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add pedit.command pedit
PEDIT is one of the commands you can use after the ANALYSE command.  It allows
you to revise a particle parameter list (ppl) and/or a segmented picture so as
to retain only particles meeting particular conditions you specify.

Exx: ANALYSE ...; PEDIT IF HFERET/VFERET < 5
       revises the current ppl (PPLIST), retaining only particles for which
       the horizontal feret diameter is less than five times the vertical one
       (i.e. only long thin particles, oriented vertically)
     PEDIT SEGMENT 4,5 UNLESS CIRCULARITY>.7
       assuming picture 4 corresponds to the current ppl (PPLIST), copies it
       to picture 5, removing particles of near-circular shape
     PEDIT 50 TO 51 SEGMENT 4,5 IF XCEN>0
       revises ppl 50 and the corresponding segmented picture 4 together,
       retaining only particles in the right half of the field analysed; the
       final ppl is stored as 51, and the new segmented picture as 5

To revise a ppl, you specify an output ppl number via the key TO.  To update a
segmented picture described by the source ppl, you specify the source and
output numbers as a pair of values with the SEGMENT key, as in the last
example.  If you omit both TO and SEGMENT, PEDIT does nothing.  If you specify
one value for SEGMENT, the output replaces the source.

You use the keys IF and UNLESS to specify the conditions you want to impose on
the particles retained (see PA.IF for details).

See also: pedit.syntax, analyse, pa.if
$add pedit.syntax
Keys:
  [PLIST]        source ppl containing results from ANALYSE [PPLIST]
  [TO]           output ppl [none]
  SEGMENT(2)     source,output segmented picture numbers [no updating of
                 segmented picture,SEGMENT]
  IF expr        logical expression specifying which particles to include
                 according to particle parameter values [true]
  UNLESS expr    logical expression specifying which particles to exclude
                 according to particle parameter values [false]

Variables used:
  PPLIST         default picture number for particle parameter list

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add pextract.command pextract
PEXTRACT is one of the commands you can use after the ANALYSE command.  It
uses the particle parameter list (ppl) and segmented picture produced by
ANALYSE and it extracts a single particle in a separate picture, in grey-level
form (if the original source picture is supplied also) or in binary form.

Exx: PEXTRACT ID 5 TO 12
       produces, in a minimal size picture 12, the binary representation of
       the particle with identifier 5
     PEXTRACT IMAGE 2 TO 3 VALUE -1
       extracts as picture 3 a region of picture 2 just large enough to
       contain the current particle (default identifier PID), retaining the
       original intensity values within the particle boundary and setting the
       rest of the picture to -1

Normally, PEXTRACT generates a binary picture just large enough to contain the
particle with the given identifier, with a one pixel border on all sides.
Pixels belonging to the particle are set to 1 and pixels belonging to the
background or to other particles are set to 0.  If you specify a source
picture with the IMAGE key, the original pixel values are copied from the
source picture within the particle boundary.
$
A zero value for ID extracts the picture background.  In default, the output
form is that of the source picture if the IMAGE key is set, and Byte if not.

                                                      Form used internally: fp

See also: pextract.syntax, analyse
$add pextract.syntax
Keys:
  [ID]           identifier of particle to be extracted [PID]
  [SEGMENT]      segmented picture produced by ANALYSE [PSEGMENT]
  [PLIST]        ppl produced by ANALYSE [PPLIST]
  [TO]           output picture number [997]
  VALUE          background pixel value [0]
  IMAGE          source picture to generate grey-scale representation of
                 particle [generate binary representation of particle]

Variables used:
  PID            default identifier for particle
  PPLIST         default picture number for particle parameter list
  PSEGMENT       default picture number for segmented picture

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add pferet.command pferet
PFERET is one of the commands you can use after the ANALYSE command.  It uses
the particle parameter list (ppl) and segmented picture produced by ANALYSE
and it calculates up to nine Feret diameters for a single particle, returning
the diameters in the variables F, F2, F3, and so on up to F9.

Exx: PFERET ANGLE PI/8
       sets F to the Feret diameter of the current particle (identifier PID)
       at PI/8 anticlockwise from the positive X axis, and types the result
       on the console
     PFERET ID 4 ANGLES 0,.3,.6,.9,1.2 NOVERIFY
       sets F,F2,F3,F4,F5 to the Feret diameters of the particle with
       identifier 4 in the five directions given

The purpose of PFERET is to allow you to obtain up to 9 Feret diameters at
different angles from the four angles at which ANALYSE measures them.  The
HFERET,VFERET parameters measured by ANALYSE correspond to angles of 0 and
PI/2 respectively, and the AFERET,BFERET parameters correspond to angles of
PI/4 and 3*PI/4.

See also: pferet.syntax, analyse
$add pferet.syntax
Keys:
  [ID]           identifier for particle to be measured [PID]
  [SEGMENT]      segmented picture produced by ANALYSE [PSEGMENT]
  [PLIST]        ppl produced by ANALYSE [PPLIST]
  ANGLE(9)       one or more angles at which Feret diameters are measured,
                 in radians anticlockwise from positive X axis [none]

Options:
  VERIFY         type results on console [YES]

Variables used:
  PID            default identifier for particle
  PPLIST         default picture number for particle parameter list
  PSEGMENT       default picture number for segmented picture

Variables set:
  F(9)           feret diameters in directions requested

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add pfilter.command pfilter filter position list curve
PFILTER generates an approximation to the curve described in the source
position list picture.  The number of points to describe the curve is reduced
in such a way that the output curve departs from the source curve by a
distance that nowhere exceeds the specified tolerance value.

Exx: PFILTER
       filter the curve defined by the current picture using the default
       tolerance of 1 and replacing the current picture with the result.
     PFILTER 1 TO 2 TOLERANCE 3.5
       generate a more coarse approximation to the curve described by
       picture 1 and place the result in picture 2
$
PFILTER provides a simple-to-use curve filtering facility.  It can be used in
conjunction with the SKETCH command to reduce the volume of curve data after
free-hand sketching a curve with the mouse.

The filtering process is controlled by the TOLERANCE key which specifies the
maximum departure of the approximation to the curve from the original curve.
PFILTER marches along the curve until the line between the current point to
the start point departs from the curve by more than the specified tolerance.
The point before the current point is retained and all previous points except
the start point are discarded.  The process is then repeated starting from the
last point to be retained.

PFILTER will fault a source picture that is not a position list or if the
picture does not have at least two columns and layers or has more than one
row.  The data from all source layers are transferred to the output picture.

The length of the resulting curve is returned in variable P, and the area for
a closed curve is returned in variable A.

See also: pfilter.syntax, sketch
$add pfilter.syntax
Keys:
  [FROM]         source position list picture [SELECT]
  [TO]           output position list picture [999]
  TOLERANCE      tolerance for approximating the curve [1.0]

Variables set:
  P              length of the curve
  A              area enclosed by the curve (closed curve only)

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add phistogram.command phistogram
PHISTOGRAM is one of the commands you can use after the ANALYSE command.  It
uses the particle parameter list (ppl) produced by ANALYSE and allows you to
generate or display histograms of any of the parameters measured, for any set
of particles.

Exx: ANALYSE ...; PHISTOGRAM CIRCULARITY
       presents a histogram of the circularity values of all particles
     PHISTOGRAM AREA TO 51 IF PERIMETER > 200
       compiles as class Histogram picture 51 a histogram of the areas of
       particles whose perimeters exceed 200
     PHISTOGRAM AREA TO 999; SURVEY FULL
       determines and types the min, max, mean, standard deviation, median and
       mode of the areas of the particles
     PHISTOGRAM 46 AREA TO DIS:3
       draws in DIS:2 a histogram of the areas of all particles in ppl 46

You give the name of the parameter whose histogram you want as an option to
PHISTOGRAM.  The available options are XREF,YREF,ID,PARENT,HOLES,BACKGROUND,
CONTACT,XMIN,XMAX,YMIN,YMAX,HFERET,VFERET,AFERET,BFERET,VPROJ,HPROJ,PERIMETER,
AREA,XCEN,YCEN,MMIN,MMAX,ANGLE and CIRCULARITY.  If you specify more than one,
the first one in the above list is selected.  You can use keys IF and UNLESS
to select only particles that meet particular conditions you impose, as in the
second example (see PA.IF for details).

The histogram is displayed in graphical form if you direct it to a display
partition, but is otherwise stored as a class Histogram picture, which you can
display with the DISPLAY command when you want to subsequently, exactly as for
the HISTOGRAM command.  The keys CHANNELS, HEIGHT and TIMES allow you to
control the number of histogram channels, and the height and magnification of
a graphical display, and are used exactly as they are with the HISTOGRAM
command.  The TYPE or LOG options allow you to display the histogram in
character form either on the console or to the log output stream.

See also: phistogram.syntax, analyse, pa.if, display, histogram
$add phistogram.syntax
Keys:
  [PLIST]        source ppl containing results from ANALYSE [PPLIST]
  [TO]           output histogram [DISPLAY]
  IF expr        logical expression specifying which particles to include
                 according to particle parameter values [true]
  UNLESS expr    logical expression specifying which particles to exclude
                 according to particle parameter values [false]
  CHANNELS       number of histogram channels [MAX-MIN if in range 20-256;
                 otherwise 256]
  HEIGHT         histogram height in framestore pixels [lesser of half
                 histogram width and half partition height]
  TIMES          integral display magnification factor [1]
  ASPECT         for character form displays, aspect ratio (no. columns/inch
                 divided by no. lines/inch) [default given by PAGE command]
  WIDTH          for character form displays, the number of characters/line
                 [default given by PAGE command]

Options:
  XREF,YREF,ID,PARENT,HOLES,BACKGROUND,CONTACT,XMIN,,XMAX,YMIN,YMAX,HFERET,
  VFERET,AFERET,BFERET,VPROJ,HPROJ,PERIMETER,AREA,XCEN,YCEN,MMIN,MMAX,ANGLE,
  CIRCULARITY    parameter whose histogram you want (first one in list is
                 selected if more than one option is specified) [none]
  PRESET         set histogram channel limits from MIN,MAX [lowest,highest
                 parameter values present used]
  LETTER         letter top of partition with picture number, title etc. [YES]
  BORDER         mark display border [YES]
  REPEATING      repeat histogram counts when magnifying, instead of
                 interpolating
  TYPE | LOG     present histogram in character form on console or log output
                 stream [present histogram on display]

Variables used:
  PPLIST         default picture number for particle parameter list

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add phr.command phr randomise
You use PHR to 'phase-randomise' a Fourier transform, i.e. assign it random
phases while preserving its modulus; this form of filter can be used to test
for significant local ordering in disordered pictures with strongly 'coloured'
spectra.

Exx: PHR 1 TO 2
       randomises the phase of picture 1

The source must be a Fourier picture; if the origin is at the left, a half
plane transform with conjugate symmetry is assumed, and the symmetry is
preserved.
$
The 'phase randomisation' test assesses the presence of local ordering as
follows.  An original showing signs of local order (e.g. small patches of
fringes throughout the image) is compared visually with a phase-randomised
version (produced by FOURIER; PHR; IMAGE); the two invariably differ in
specific detail of course, but if they do not differ in general texture as
well then the structures apparent in the original reflect no more than white
noise (the transform of which has random phases) suitably filtered to impose a
particular power spectrum.

Preserving conjugate symmetry requires that the column length is not greater
than the maximum row length supported by your installation.

The random number generator 'seed' is held in Semper variable RNM, and you
can initiate reproducible 'random' sequences by setting this yourself.

                                                 Multi-layer pictures: faulted
                                                 Form used internally: complex

See also: phr.syntax
$add phr.syntax
Keys:
  [FROM]         source picture [SELECT]
  [TO]           output picture [FROM]

Variable used and set:
  RNM            random number generator seed; range 0 to 1

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add picture.command picture information variables pcb
Use the PICTURE command to obtain information about a given picture.  The
information is returned in Semper variables.  You select the required
parameters by specifying the corresponding option.  This command supersedes
the PCB command.

Exx: PICTURE SIZE
       returns the dimensions of the current picture in the variables
       NX, NY and NZ
     PICTURE 2:5 ALL
       returns all available information for picture 5 on device 2
     THRESHOLD GT 100; PICTURE SUM
       returns the number of pixels in the current picture whose intensity is
       greater than 100 in the variable S
$
The PICTURE commands sets only the variables associated with the data you
request.  If the data is not defined (for example, the position list type for
a picture which is not a position list), the corresponding variables are
returned unset.  Use the SET function to check for an unset variable.

The names of variables have been chosen so that they do not clash with key or
option names for any of the existing commands.  By using the individual
options, you can control directly which variables are set.  You should use
this command in preference to the PCB command which sets all its variables in
one go (including the FORM variable which can interfere with the operation of
other commands).

If you specify the option ALL, all available information about the source
picture is returned.

See also:picture.syntax
$add picture.syntax
Keys:
  [FROM]         source picture [SELECT]

Options:
  SIZE           return picture dimensions
  LIMITS         return X, Y and Z picture coordinate limits
  CLASS          return picture class
  FORM           return data form
  WP             return write-protect flag
  DATE           return creation date
  TIME           return creation time
  RANGE          return intensity range
  SUM            return intensity sum
  STATISTICS     return intensity mean and standard deviation
  BW             return black and white levels (display picture only)
  SAMPLING       return sampling interval (display picture only)
  TYPE           return position list type (position list picture only)
  ALL            return all available information

Variables set:
  NX,NY,NZ       picture dimensions
  X1,X2          X coordinate limits (X1 <= X2)
  Y1,Y2          Y     "        "    (Y1 <= Y2)
  Z1,Z2          Z     "        "    (Z1 <= Z2)
  C              picture class
  F              data form
  W              write-protect flag (0 = off, 1 = on)
  YD,MD,DD       creation date - year,month,day
  HT,MT,ST       creation time - hours,minutes,seconds
  I1,I2          intensity range
  S              intensity sum (real part for complex picture)
  S2             intensity sum (imaginary part for complex picture)
  M              intensity mean (real part for complex picture)
  M2             intensity mean (imaginary part for complex picture)
  SD             intensity standard deviation
  DB,DW          display intensity scaling - black,white source levels
  DS             display sampling interval
  PT             position list type

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add pid.command pid
PID is one of the commands you can use after the ANALYSE command.  It reads
the segmented picture produced by ANALYSE and allows you to determine to which
particle any given position belongs.  The corresponding particle identifier is
typed on the console and returned as variable PID.

Exx: ANALYSE .. SEGMENT 51; XWIRES; PID @XY; PTYPE ALL IF ID=PID
       sets variable PID to the identifier of the particle you indicate via
       the display cursor, then types all its parameters
     PID SEGMENT 23 POSITION X,Y NOVERIFY
       sets variable PID to the identifier of the particle that contains
       position X,Y in segmented picture 23

If the position indicated lies in the background rather than a particle, PID
is set to zero and the message 'Background hit' is typed.  You can suppress
any console messages with the NOVERIFY option.
$
Except for the console messages, PID does no more than pick up the value of
the segmented picture at the indicated position, so the second example above
is equivalent to

     SELECT 23; PID=P(X,Y)

See also: pid.syntax, analyse
$add pid.syntax
Keys:
  SEGMENT        segmented picture produced by ANALYSE [PSEGMENT]
  POSITION(2)    position for which particle identifier is required [0,0]

Options:
  VERIFY         type identifier on the console [YES]

Variables used:
  PSEGMENT       default picture number for segmented picture

Variable set:
  PID            identifier of particle indicated (0 if no particle hit)

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add pixel.command pixel p p.command points
You use the PIXEL or P commands to change the value of any pixel in the
current picture.  Use the SELECT command to select the current picture.

Exx: P X,Y,Z=1,2,3
       sets the 3 pixels at positions (X,Y,Z), (X+1,Y,Z) and (X+2,Y,Z) in the
       current picture to the values 1, 2 and 3 respectively
     CREATE 1 SIZE 256,1; ORIGIN LEFT; FOR X 0,255; PIXEL X=X; LOOP
       creates a linear ramp in picture 1
     FOURIER 1; PIXEL 0,0=0,0
       sets the real and imaginary parts of the centre value of the Fourier
       transform of picture 1 to zero
$
                                      Forms used internally:  Complex

See also: pixel.syntax coordinates
$add pixel.syntax p.syntax
PIXEL uses a special syntax:
   Items up to the equal sign specify the co-ordinate position of the pixel
   to change.  Any omitted coordinate value defaults to zero.  One or more
   comma-separated expressions should follow the equal sign. These define the
   new value of the pixel at the indicated pixel (and subsequent pixels to
   the right, if more than one value is specified).

        PIXEL X [,Y [,Z]] = EXPR1[,EXPR2[,EXPR3[,EXPR4...]]]

   If the current picture is complex, the values are taken in pairs to define
   the new real and imaginary parts of the pixel(s) being changed.

        PIXEL X [,Y [,Z]] = REXPR1,IEXPR1[,REXPR2,IEXPR2[,...]]

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add pmark.command pmark
PMARK is one of the commands you can use after the ANALYSE command.  It uses
the particle parameter list (ppl) produced by ANALYSE and it allows you to
mark on a display the position of any set of particles, or the values of any
one of their parameters.

Exx: ANALYSE ...; PMARK AREA
       marks (as text) the area of all particles on picture DISPLAY
     PMARK IF PERIMETER > 200
       marks the position of all particles whose perimeter exceeds 200
     PMARK PICTURE DIS:3 HFERET CM
       marks in DIS:3 the horizontal Feret diameters of all particles, at the
       CM rather than the reference point

To mark the value of a particular parameter, you give its name as an option.
The available options are XREF,YREF,ID,PARENT,HOLES,BACKGROUND,CONTACT,XMIN,
XMAX,YMIN,YMAX,HFERET,VFERET,AFERET,BFERET,VPROJ,HPROJ,PERIMETER,AREA,XCEN,
YCEN,MMIN,MMAX,ANGLE and CIRCULARITY.  If you specify more than one, the first
one in the above list is selected.  If you give none, PMARK simply marks the
position of the particle (in a style determined by MKMODE,MKSIZE in the usual
way).

You can use keys IF and UNLESS to select only particles that meet particular
conditions you impose, as in the second example (see PA.IF for details).
$
If you want to mark a display other than the current one (DISPLAY), you
can specify it with the key PICTURE.  The mark itself is normally placed
at the particle reference point (see PP.REF). If you use option CM the mark
is placed at the centre of area (see PP.CENTRE) instead.

See also: pmark.syntax, analyse, pa.if, pp.ref, pp.centre
$add pmark.syntax
Keys:
  [PICTURE]      display picture to be marked [DISPLAY]
  [PLIST]        source ppl containing results from ANALYSE [PPLIST]
  IF expr        logical expression specifying which particles to include
                 according to particle parameter values [true]
  UNLESS expr    logical expression specifying which particles to exclude
                 according to particle parameter values [false]
  MKMODE         mark mode [1]
  MKSIZE         mark size [2]

Options:
  XREF,YREF,ID,PARENT,HOLES,BACKGROUND,CONTACT,XMIN,,XMAX,YMIN,YMAX,HFERET,
  VFERET,AFERET,BFERET,VPROJ,HPROJ,PERIMETER,AREA,XCEN,YCEN,MMIN,MMAX,ANGLE,
  CIRCULARITY    parameter you want marked (first one in list is selected if
                 more than one option is specified) [mark position]
  CM             place marks at particle centres of area [reference points]

Variables used:
  PPLIST         default picture number for particle parameter list

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add pmoment.command pmoment Hu invariant moments
PMOMENT is one of the commands you can use after the ANALYSE command.  It
uses the particle parameter list (ppl) and segmented picture produced by
ANALYSE and it calculates the seven Hu invariant moments for a single
particle, returning the moments in the variables M1, M2, M3, M4, M5, M6
and M7.  The moments values are calculated independently of the position,
size and orientation of the particle.  They are also printed on the
console unless option NOVERIFY is set.  If the IMAGE key points to a
corresponding grey-scale image, the intensity-weighted values for the
moments are calculated instead.

Exx: PMOMENT
       sets M1, M2, M3, M4, M5, M6 and M7 to the Hu invariant moments for
       the current particle (indentifier PID) and types the results on the
       console
     XWIRES NOVERIFY; PID @XY; PMOMENT
       same as above but using the display cursor to point to the selected
       particle
     PMOMENT ID 4 IMAGE 2:3 NOVERIFY
       calculates intensity-weighted moments for particle 4

See also: pmoment.syntax, analyse
$add pmoment.syntax
Keys:
  [ID]           identifier for particle to be measured [PID]
  [SEGMENT]      segmented picture produced by ANALYSE [PSEGMENT]
  [PLIST]        particle parameter list produced by ANALYSE [PPLIST]
  IMAGE          source picture for calculating intensity-weighted moments
                 [calculate plain moments]

Options:
  VERIFY         type results on console [YES]

Variables used:
  PID            default identifier for particle
  PPLIST         default picture number for particle parameter list
  PSEGMENT       default picture number for segmented picture

Variables set:
  M1,M2,M3,M4,M5,M6,M7  Hu invariant moments

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add postscript.command postscript encapsulated hardcopy screen dump
The POSTSCRIPT command writes out Semper images or screen dumps in a form
suitable for output to a PostScript printer.

Exx. POSTSCRIPT 5 NAME 'IMAGE' TIMES 2.3 LANDSCAPE
       Creates the file "image.ps" which will print the whole of picture 5,
       scaled up by a factor of 2.3 and in landscape orientation together
       with header information, when sent to a PostScript printer

     POSTSCRIPT FRAME NAME 'SCREEN' ENCAPSULATED
       Creates the file "screen.eps" so that the image contained in the
       current display frame together with any display annotation can be
       included into another PostScript document

     POSTSCRIPT 2:33 NAME 'FIG10_6' TEXT 'Fig. 10.6  Original sample'
       Outputs picture 2:33 with suitable figure caption
$
The POSTSCRIPT command provides the facility to write out images in PostScript
format.  An image can be either all or part of a Semper picture or else all or
part of a display frame, partition or picture.  The latter case is a screen
dumping facility which is invoked by specifying one of the FRAME, PARTITION or
PICTURE options.

You may choose one of two forms of PostScript output depending on whether or
not the ENCAPSULATED option is set.  The ENCAPSULATED option should be used
for including Semper images into other PostScript documents.  Both forms
follow the PostScript Document Structuring Conventions defined by Adobe
Systems Incorporated (PostScript is a registered trademark of Adobe Systems
Incorporated).

You specify the output file name by means of the NAME key.  The extension for
the file name defaults to ".ps" unless the ENCAPSULATED option is set, in
which case it defaults to ".eps".

You can use the standard 2D sub-region keys and options to output part of the
region of interest.  If a multi-layer Semper picture is to be output, the
LAYER keys may be used to specify a range of layers to output (by default all
layers are output).  If, however, the ENCAPSULATED option is set, only the
first (specified) layer is output.   When dumping from the display, only the
specified frame (if the FRAME option is used) or the start frame (if the
PARTITION or PICTURE option is used) is output.

By default, a Semper picture is printed so that the lowest pixel intensity
appears black and the highest intensity appears white.  You may force
different levels to be used for black and white by specifying the PRESET
option.  In that case, the levels are taken from the variables MIN and MAX.
Identical levels for black and white will be faulted.

When dumping from the display, the image is printed so that the lowest and
highest display intensities appear as black and white (it is assumed that any
necessary intensity scaling is carried out when the image is first displayed).
Any annotation that overlays the image will appear superimposed on the image
when it is printed out.  The options BLACK and WHITE determine whether the
annotation appears as black or white (white is the default).

If the ENCAPSULATED option is set, a PostScript program is output that prints
the source image onto the current page with the bottom left-hand corner of the
image at the origin and with the image scaled so that each pixel is one unit
square.  This form is suitable for including into other PostScript documents.

If the ENCAPSULATED option is not set, a complete PostScript program is
generated, that prints the source image along with various annotation.  Any
number of copies may be run off by setting the COPIES key.  The image is
centred on the bounding box of the current clipping path (by default the
limits of the page) and is scaled so that each pixel is TIMES units square
(the default unit is 1 printer's point = 1/72 inch).  The image may appear in
either portrait or landscape orientation (Y-axis pointing upwards or right-to-
left on the page).  A border is drawn around the image.  You can suppress the
printing of the border by specifying the NOBORDER option.  If the ORIGIN
option is set, the position of the origin is indicated by tick marks around
the edge of the image.  A caption string can be specified with the TEXT key.
The string will appear either above or below the image, depending on whether
the option ABOVE or BELOW is set.  A header is printed at the top of the page
listing information about the source image. The header information can be
suppressed with the NOHEADER option.

See also:  postscript.syntax
$add postscript.syntax
Keys:
  [ ]            if FRAME, PARTITION or PICTURE set, display frame, partition
                 or picture number [CFRAME for frame number, DISPLAY for
                 partition or picture number]
                 otherwise, source picture number [SELECT]
  NAME text      output file name
  COPIES         number of copies to print [1]
  TIMES          output scaling factor [1.0]
  SIZE(2)        sub-region size [whole region]
  POSITION(2)    sub-region offset [0,0]
  LAYER(2)       range of source picture layers [if ENCAPSULATED, first layer,
                 otherwise all layers]
  TEXT text      caption string

Options:
  ENCAPSULATED   generate PostScript file for including image into other
                 PostScript documents
  PICTURE | PARTITION | FRAME  dump all or part of display picture, partition
                 or frame
  PRESET         use pre-defined intensity scaling (see MIN,MAX)
  BLACK | WHITE  output level for any display annotation [WHITE]
  PORTRAIT | LANDSCAPE  output orientation [PORTRAIT]
  LEFT | RIGHT   output sub-region abutting indicated border
  TOP | BOTTOM
  RE | IM        output real/imaginary part of a complex display picture
  BORDER         print border around image [YES]
  ORIGIN         print tick marks aligned with source picture origin
  ABOVE | BELOW  print caption string above/below image [BELOW]
  HEADER         print header information [YES]
  OLD | NEW      if OLD set, reuse existing file, starting from the beginning
                 if NEW set, overwrite existing file [if file exists, fault
                 its reuse, otherwise, create new file]

Variables used:
  MIN, MAX                 if PRESET option is set:
                             define intensity levels for black and white

If the ENCAPSULATED option is set, the default extension for the output file
name is ".eps".  Otherwise, the default extension is ".ps".

If the FRAME, PARTITION or PICTURE option is set, the PRESET option and the
LAYER keys are ignored.

If the PICTURE option is not set, the options RE and IM are ignored.

If none of the options FRAME, PARTITION or PICTURE is set, the options BLACK
and WHITE are ignored

If the ENCAPSULATED option is set, the keys COPIES, TIMES and TEXT and the
options PORTRAIT, LANDSCAPE, BORDER, ORIGIN, ABOVE, BELOW and HEADER are
ignored.

The options ABOVE and BELOW are ignored if the TEXT key is not set.

Use option OLD to access write-only output devices such as the printer port.

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add print.command print
You use PRINT to print small blocks of pixels, on the console.

Exx: XWIRES; PRINT @XY SIZE 5
       prints a 5 by 5 blocks of values around a position indicated with the
       cursor
     PRINT TOP LEFT MP LAYER 4
       (for a Complex picture) prints a block of values from the top left of
       layer 4, in modulus and phase form
     PRINT SIZE 7,3 LOG
       prints a central block of values, 7 points by 3
$
The block to be printed is indicated by the standard 2-D subregion keys and
options, and the key LAYER can be used to select one layer from a multi-layer
picture.

The block size defaults to the largest odd number that fits the page width
(see the commands PAGE and SHOW PAGE).  The X and Y coordinates are written at
the side and across the top of the block printed.  Imaginary parts, where
present, are printed separately, following the real parts.

                             Multi-layer pictures: one layer selected by LAYER
                            Forms used internally: integer,fp,complex

See also: print.syntax, page, show
$add print.syntax
Keys:
  [FROM]         picture printed [SELECT]
  SIZE(2)        dimensions of subregion printed [maximum allowed by current
                 page width,SIZE]
  POSITION(3)    position/offset of subregion [0,0,0]
  LAYER          layer for subregion [layer including origin]

Options:
  LEFT | RIGHT
  BOTTOM | TOP   print subregion abutting indicated border
  NEAR | FAR
  MP             print complex values as modulus and phase rather than real
                 and imaginary parts

See SUBREGIONS for more details of subregion keys/options.

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add project.command project
You use PROJECT to project or average a picture, in any direction, to form a
1-D picture - for example, to obtain a relatively noise-free image of linear
structures (e.g. edges or interfaces); you can also use it, in conjunction
with BACKPROJECT, to reconstruct a picture from its projections.

Exx: PROJECT 1 TO 2 VERTICALLY
       sums the columns of picture 1 to form a 1-D picture 2
     XWIRES LINE; PROJECT DISPLAY TO 10 ANGLE THETA AVERAGE
       averages the display picture along a direction indicated via the cursor
     PROJECT 50 TO 51 HORIZONTALLY
       projects horizontally, i.e. along the rows

The width of the output is chosen so as just to accommodate all projected
source pixels, and its origin is placed where the source origin projects. The
positive X direction in the projection lies to your right as you look in the
projection direction.
$
The AVERAGE option causes the projection sums to be divided by the area of the
source picture that contributes to each sum, compensating for the "thinning
out" of data towards the corners of the source picture.

If you use the option HORIZONTALLY or VERTICALLY, PROJECT accumulates row or
column sums, which gives a faster but equivalent result to setting the ANGLE
key to 0 or PI/2.  The ANGLE key allows you to specify an arbitrary projection
direction, in radians anticlockwise from the positive X axis.  The
contribution from each source pixel is shared between two projection columns
in proportion to the projected distance from the two column centres.
Otherwise fluctuations in the number of points that happen to project into
each column could lead to uneven projections even from smooth source data.

                                              Display marking: projection line
                                                 1-D pictures: faulted
                                         Multi-layer pictures: faulted
                                         Form used internally: complex

See also: project.syntax, backproject
$add project.syntax
Keys:
  [FROM]        source picture [SELECT]
  [TO]          output picture [FROM]
  ANGLE         projection direction, in radians anticlockwise from +X axis
                [horizontally]
  MARK          display to be marked with projection line and direction [none]

Options:
  AVERAGE       divide projection sums by contributing source picture area
  HORIZONTALLY | VERTICALLY   project horizontally or vertically

Note:
  Globally setting the VERIFY option will trigger the VERTICALLY option for
  this command.

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add ps.command ps powerspectrum spectrum diffractogram
You use PS to calculate the power spectrum (Fourier transform intensity) of a
picture.  This is a widely used tool for detecting or measuring periodic
features, and for assessing resolution or image formation condition.  The X
and Y dimensions of a picture must be a multiple of 4 and 'factorisable' (no
factors other than 2, 3, 4 or 5).  The command SHOW SIZES lists all the
factorisable sizes.

Exx: PS 1 4
       obtains the spectrum of picture 1 as picture 4
     PS LN; SURVEY FULL; MIN=MEAN; DISPLAY PRESET
       replaces the current picture with the (natural) log of its spectrum, to
       accommodate the wide dynamic range of the specrum, and displays this
       with the very small values suppressed.
$
In general, PS Fourier transforms the picture and then takes its squared
modulus (intensity).  You can supply the picture already transformed (as a
Fourier picture), in which case PS simply calculates the squared modulus.

The output is class Spectrum, form Fp.  PS follows the same pattern as FOURIER
with respect to real/complex data: when the source data are real (real Image
or (auto-)Correlation, or half-plane Fourier), the right half-plane only is
output; when they are complex (Complex Image or (auto-)Correlation, or full-
plane Fourier), the full plane is output.  Use commands FULLPLANE or HALFPLANE
to interconvert these further if you wish.

                         Restrictions: image sizes must be factorisable
                                     : unsuitable for direct output to display
                 Multi-layer pictures: faulted
                Forms used internally: fp,complex

See also: ps.syntax, fourier, show, fullplane, halfplane
$add ps.syntax
Keys:
  [FROM]         source picture [SELECT]
  [TO]           output picture [FROM]

Options:
  LN             produce (natural) logarithm of transform intensity

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add pset.command pset
PSET is one of the commands you can use after the ANALYSE command.  It allows
you to set variables to the values of the various parameters recorded in a
particle parameter list (ppl) for any one of the particles found.

Exx: ANALYSE ...; PSET ALL INDEX 3
       returns in variables XR,YR.. all 25 parameters recorded for the third
       particle found by ANALYSE
     PSET PERIMETER IF ID=4
       returns in variable P the perimeter of the particle with identifier 4
     PSET COUNT IF AREA>99
     FOR INDEX=1,N; PSET XCEN YCEN IF AREA>99 SORT AREA DESCENDING; ... ; LOOP
       returns in variable N the number of particles with areas greater than
       100, and then retrieves in variables XC and YC the centre position of
       each of these particles in turn, starting with the particle with the
       largest area
$
You use parameter options to specify the names of the parameters whose values
you want returned. The available options are XREF,YREF,ID,PARENT,HOLES,
BACKGROUND,CONTACT,XMIN,XMAX,YMIN,YMAX,HFERET,VFERET,AFERET,BFERET,HPROJ,
VPROJ,PERIMETER,AREA,XCEN,YCEN,MMIN,MMAX,ANGLE and CIRCULARITY. The
corresponding variables set are XR,YR,PID,PA,H,BG,EC,X1,X2,Y1,Y2,HF,VF,AF,BF,
VP,HP,P,A,XC, YC,M1,M2,THETA and C. You can also, with option COUNT, ask for
the number of particles in the list to be returned as variable N.
Alternatively, option ALL gives you all 25 parameters for a single particle.

The particle whose parameters are returned is the first one found in the list
generated according to the keys IF, UNLESS and SORT (see PA.IF and PA.SORT for
details).  IF and UNLESS allow you to select/reject particles according to
criteria based on the particle parameters.  The SORT key allows you to select
a particle parameter on which to order the list.  The parameter names you can
specify are XREF,YREF,ID,PARENT,HOLES,BACKGROUND,CONTACT,XMIN,XMAX,YMIN,YMAX,
HFERET,VFERET,AFERET,BFERET,VPROJ,HPROJ,PERIMETER,AREA,XCEN,YCEN,MMIN,MMAX,
ANGLE and CIRCULARITY.  The options ASCENDING and DESCENDING control the
direction for sorting.

If you want to select a particle further down the list, you set the INDEX key
to the ranking (1,2,3..) of the particle you want.  An error is generated if
INDEX is larger than the number of particles in the list.  By first using the
PSET COUNT command, you can obtain the number of particles in a list, so that,
for example, you can execute a FOR loop recovering parameters for all listed
particles in turn, as in the last example above.

See also: pset.syntax, analyse, pset, pa.if, pa.sort
$add pset.syntax
Keys:
  [PLIST]        source ppl containing results from ANALYSE [PPLIST]
  IF expr        logical expression specifying which particles to include
                 according to particle parameter values [true]
  UNLESS expr    logical expression specifying which particles to exclude
                 according to particle parameter values [false]
  SORT name      name of parameter by which particles are to be sorted [none]
  INDEX          ranking in list determined by IF, UNLESS and SORT of the
                 particle whose parameters are to be returned [1]

Options:
  COUNT          return number of selected particles
  ALL            return the values of all parameters
  XREF,YREF,ID,PARENT,HOLES,BACKGROUND,CONTACT,XMIN,,XMAX,YMIN,YMAX,HFERET,
  VFERET,AFERET,BFERET,VPROJ,HPROJ,PERIMETER,AREA,XCEN,YCEN,MMIN,MMAX,ANGLE,
  CIRCULARITY    parameter whose value you want returned
  ASCENDING | DESCENDING if SORT set, sort list in sense indicated [ASCENDING]

Variables used:
  PPLIST         default picture number for particle parameter list

Variables set:
  N              number of selected particles
  XR,YR          reference point
  PID            identifier
  PA             parent id
  H              number of holes
  BG             background flag
  EC             edge contact flag
  X1,X2          X limits - minimum,maximum
  Y1,Y2          Y limits - minimum,maximum
  HF,VF          feret diameters - horizontal,vertical
  AF,BF          feret diameters - 45 degrees,135 degrees
  HP,VP          projections - horizontal,vertical
  P              perimeter
  A              area
  XC,YC          centre of area - X,Y coordinates
  M1,M2          principal second moments of area - minimum,maximum
  THETA          orientation of long axis of area
  C              circularity

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add pshow.command pshow
PSHOW is one of the commands you can use after the ANALYSE command.  It uses
the particle parameter list (ppl) produced by ANALYSE and relies on an
unscaled display of the corresponding segmented picture (also produced by
ANALYSE), allowing you to alter the display look-up-table in such a way as to
highlight all particles meeting any particular condition you specify.

Exx: ANALYSE ... SEGMENT ...; DISPLAY PSEGMENT NOSCALE; PSHOW IF AREA>100
       analyses a field, displays the segmented picture and then shows the
       larger particles as white, and the smaller as grey, against a black
       background
     PSHOW IF ID=25
       picks out the particle with identifier 25
     PSHOW IF HFERET < 50 HUE 0,240 SATURATION .8 SORT AREA
       picks out the selected particles with not quite saturated colours
       spanning a range of hues from red to blue with increasing area

PSHOW relies on false colour lut manipulation, and it will only display
correct results if the number of particles present in the segmented image is
less then the number of lut entries.  The LUT ENQUIRE command returns this
number in the variable LSIZE.  PSHOW also requires that the segmented picture
produced by ANALYSE is displayed unscaled, which you can achieve as in the
first example above with the command DISPLAY NOSCALE.

PSHOW replaces the current display look-up table with a look-up table which
makes particles satisfying the conditions you specify appear white (or
coloured), all other particles grey, and the background black.  If you give a
non-zero value for the SATURATION key, the selected particles are displayed in
colour with the given saturation value.  Saturation values range from 0 (no
colour) to 1 (fully saturated colour).  The HUE key defines the colour for the
first and last particle in the list, with intervening particles taking on
interpolated hues.  Hue defines colour on a circular scale from 0 to 360
degrees, with values 0, 60, 120, 180, 240, 300 and 360 corresponding to
colours red, yellow, green, cyan, blue, magenta and red respectively.

The keys IF and UNLESS allow you to select/reject particles according to
criteria based on the particle parameters (see PA.IF).  The SORT key allows
you to select a particle parameter on which to order the list (see PA.SORT).
The parameter names you can specify are XREF,YREF,ID,PARENT,HOLES,BACKGROUND,
CONTACT,XMIN,XMAX,YMIN,YMAX,HFERET,VFERET,AFERET,BFERET,VPROJ,HPROJ,PERIMETER,
AREA,XCEN,YCEN,MMIN,MMAX,ANGLE and CIRCULARITY.  The options ASCENDING and
DESCENDING control the direction for sorting.

See also: pshow.syntax, analyse, display, lut, pa.if, pa.sort
$add pshow.syntax
Keys:
  [PLIST]        source ppl containing results from ANALYSE [PPLIST]
  IF expr        logical expression specifying which particles to include
                 according to particle parameter values [true]
  UNLESS expr    logical expression specifying which particles to exclude
                 according to particle parameter values [false]
  SORT name      name of parameter by which particles are to be sorted [none]
  SATURATION     colour saturation for highlighted particles [0]
  HUE(2)         range of hues for highlighting particles [0,0]

Options:
  ASCENDING | DESCENDING  if SORT, sort list in sense indicated [ASCENDING]

Variables used:
  PPLIST         default picture number for particle parameter list

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add ptype.command ptype
PTYPE is one of the commands you can use after the ANALYSE command.  It uses
the particle parameter list (ppl) produced by ANALYSE and it allows you to
list the values of particle parameters.

Exx: ANALYSE ...; PTYPE AREAS PERIMETERS
       types the perimeters of all particles
     PTYPE ID ANGLES UNLESS CIRCULARITY > .5 SORT MMAX
       types the identifier and 'long' direction of all particles whose
       circularity is not more than 0.5, ordered by the 'long' axis length
     PTYPE 23 ALL IF ID=4
       types all parameters for the particle given identifier

You use parameter options to specify the names of the parameters you want
typed.  The available options are XREF,YREF,ID,PARENT,HOLES,BACKGROUND,
CONTACT,XMIN,XMAX,YMIN,YMAX,HFERET,VFERET,AFERET,BFERET,VPROJ,HPROJ,PERIMETER,
AREA,XCEN,YCEN,MMIN,MMAX,ANGLE and CIRCULARITY.  The parameters are printed in
columns in the order in which they appear in the above list, up to a maximum
of 5 parameters.

The keys IF and UNLESS allow you to select/reject particles according to
criteria based on the particle parameters (see PA.IF).  The SORT key allows
you to select a particle parameter on which to order the list (see PA.SORT).
The parameter names you can specify are XREF,YREF,ID,PARENT,HOLES,BACKGROUND,
CONTACT,XMIN,XMAX,YMIN,YMAX,HFERET,VFERET,AFERET,BFERET,VPROJ,HPROJ,PERIMETER,
AREA,XCEN,YCEN,MMIN,MMAX,ANGLE and CIRCULARITY.  The options ASCENDING and
DESCENDING control the direction for sorting.

Option ALL causes all 25 parameters to be listed for the first particle in the
list.  If you want to select a particle further down the list, you set the
INDEX key to the ranking (1,2,3..) of the particle you want.  An error is
generated if INDEX is larger than the number of particles in the list.  By
first using the PSET COUNT command, you can obtain the number of particles in
a list, so that you can execute a FOR loop listing all the parameters for each
selected particle in turn, for example

     PSET COUNT IF AREA>99; FOR INDEX=1,N; PTYPE ALL IF AREA>99; LOOP

See also: ptype.syntax, analyse, pset, pa.if, pa.sort
$add ptype.syntax
Keys:
  [PLIST]        source ppl containing results from ANALYSE [PPLIST]
  IF expr        logical expression specifying which particles to include
                 according to particle parameter values [true]
  UNLESS expr    logical expression specifying which particles to exclude
                 according to particle parameter values [false]
  SORT name      name of parameter by which particles are to be sorted [none]
  INDEX          if ALL set, ranking in list determined by IF, UNLESS and SORT
                 of a single particle whose parameters are to be listed [1]

Options:
  XREF,YREF,ID,PARENT,HOLES,BACKGROUND,CONTACT,XMIN,,XMAX,YMIN,YMAX,HFERET,
  VFERET,AFERET,BFERET,VPROJ,HPROJ,PERIMETER,AREA,XCEN,YCEN,MMIN,MMAX,ANGLE,
  CIRCULARITY    parameter you want typed (first five in list are selected if
                 more than five options are specified) [none]
  ALL            print all parameters for one particle
  ASCENDING | DESCENDING  if SORT, sort list in sense indicated [ASCENDING]

Variables used:
  PPLIST         default picture number for particle parameter list

Option ALL is a mutually exclusive alternative to the parameter options XREF,
YREF, ID, ..., CIRCULARITY.

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add ramps.command ramps test
You use RAMPS to generate full-range grey level ramps on the display, for test
purposes or to allow you to adjust the monitor contrast and brightness
controls conveniently.

Exx: RAMPS FRAME 1 VIEW
       fills the entire frame with ramps, and brings it into view on the
       display monitor
     RAMPS PARTITION DIS:5 SIZE 256,20 TOP
       displays ramps of the indicated size at the top of the partition
     XWIRES DIS:3 REGION; RAMPS @REGION
       writes ramps to the region of picture DIS:3 indicated with the cursor
$
In default, RAMPS works on DISPLAY, in picture coordinate mode; however,
you can also use it in PARTITION or FRAME mode -
     e.g., RAMPS PARTITION DIS:7 (see GRAPHICS).

You may specify a subregion if you wish via SIZE, POSITION, LEFT, RIGHT,
TOP and BOTTOM in the standard way.

Four ramps, rising in intensity from left to right, are normally displayed
across the target region.  You can specify the number of ramps with
the TIMES key.  Alternatively, you may specify the option FULL, in which case
the ramps are displayed with unit increments of intensity between adjacent
pixels.

For complex display pictures, where the real and imaginary parts of the image
are displayed side by side, RAMPS would normally display ramps in both parts.
You can restrict the ramps to just the real or imaginary part by specifying
the option RE or IM.

If you want to ensure that the ramps are visible on the display monitor,
specify the VIEW option.

See also: ramps.syntax
$add ramps.syntax
Keys:
  []            picture/partition/frame filled [DISPLAY if picture or
                partition; CFRAME if frame]
  SIZE(2)       dimensions of target subregion [whole frame/partition/picture]
  POSITION(2)   position/offset of subregion [0,0]
  TIMES         number of ramps to display [4]

Options:
  PICTURE | PARTITION | FRAME  use indicated coordinate system [PICTURE]
  LEFT | RIGHT  erase subregion abutting indicated border
  BOTTOM | TOP
  FULL          display ramps with unit intensity increments [NO]
  RE | IM       display ramps in real or imaginary part of complex display
                picture [display ramps in both parts]
  VIEW          switch view to make display region visible [NO]

See SUBREGIONS for more details of subregion keys/options.

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add rank.command rank median erosion erode dilation dilate minimum maximum
You use RANK for local median, minimum or maximum filtering, and multi-level
erosion and dilation.  It ranks the pixels in a small neighbourhood around
a given pixel in order of increasing brightness, and replaces the pixel by
the 1st, 2nd.. middle.. or last ranked pixel, depending on the options
selected.

Exx: RANK DISPLAY
        applies a 3x3 median filter to the display picture, removing isolated
        spurious values without softening edges.
     FOR N=1,3; RANK ERODE OVER 5; LOOP
        erodes all bright regions of the current picture by about 6 pixels
     RANK POSITION 9
        replaces each pixel by the maximum (brightest) within its 3x3
        neighourhood
$
RANK effectively sorts the pixels within a finite neighbourhood (3x3, or 5x5
if OVER 5) into ascending numerical order, and replaces the source pixel by
the value found to lie at a particular place in the ranking.

In default, the output is middle ranked, or median, value; this is a widely
used means of removing isolated spurious values - removing one kind of noise -
without degrading the sharpness of lines and edges in the picture in the way
that linear filters such as LMEAN or FIR do.

Selecting a low-ranked value causes dark regions of a picture to expand, while
conversely a high-ranked value causes bright regions to expand; thus a multi-
grey level form of erosion and dilation can be achieved.  The key POSITION
gives you complete control of the output ranking chosen, while options ERODE
and DILATE select positions just short of the extremes (2 and 8 for 3x3
kernels, 4 and 21 for 5x5 kernels) as this makes the result less noise
sensitive and achieves better rounding of corner features.  (For 1-D pictures,
ERODE and DILATE simply select the extreme positions.)

The algorithm used requires data in the range 0-255; you can apply it to other
data reasonably easily by DISPLAYing the data, and then re-CREATing the
display with MIN=0 and MAX=255.  If you want your data treated as binary, use
CALC to threshold it suitably, or output to the display with MIN=0 and MAX=1;
RANK runs slightly faster with such data.

                                                 Multi-layer pictures: faulted
                                                 Form used internally: integer

See also: rank.syntax
$add rank.syntax
Keys:
  [FROM]         source picture [SELECT]
  [TO]           output picture [FROM]
  OVER           neighbourhood size = 3 or 5 only [3]
  POSITION       ranking position required as output [middle ranked for median
                 mode; low value for erosion and high for dilation, but exact
                 value depends on OVER and whether source is 1-D or 2-D]

Options:
  ERODE | DILATE apply grey-scale erosion dilation filter [apply median
                 filter]

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add rcf.command rcf
You use RCF to assess the useful resolution of an image of which you have two
copies with independent noise, by tabulating how well their Fourier components
agree at different spatial frequencies.  You can choose either cross-
correlation coefficients (RCF abbreviates 'Radial Correlation Function') or
phase-residual values.

Exx: RCF 1 WITH 2 TO 3; DISPLAY TIMES 4
       displays the 'radial correlation function' between transforms 1 and 2,
       with a significance threshold curve superposed
     RCF 1 WITH 2 PHASERESIDUAL OVER 3
       puts in picture 999 the 'phase residual' function between transforms 1
       and 2 calculated over bands 3 pixels wide
     FOR N=1,2; MASK N RADIUS 45 WIDTH 5; FOURIER; LOOP
     RCF 1 WITH 2
       generates the r.c.f. for two Images, including the smooth-edged masks
       necessary in general to prevent spurious high frequency mismatches

The source pictures must be half-plane Fourier transforms of square pictures.
$
The output is 1-D, with zero spatial frequency at the left (the origin) and
the maximum spatial frequency (0.5/pixel) at the right. The correlation values
(generated in default) are standard cross-correlation coefficients between
corresponding (complex) Fourier components, normalised to lie in the range -1
to 1; the phase residual values are the r.m.s. phase difference (in radians)
between corresponding Fourier components, with the differences weighted in
proportion to the sum of the two relevant moduli.

In default, the Fourier components of each picture are grouped into annular
bands one pixel wide; if you quote a larger value for OVER, as in the second
example, appropriately wider overlapping bands are used, effectively smoothing
the output.

To prevent opposite-edge mismatches or sharp features at mask edges from
generating artificially raised high-frequency agreement, you should use a
smooth-edged mask as in the last example above to make both images fade out
smoothly towards the picture edges beyond the features of interest before
using RCF.

The output in fact has two layers, the second layer containing a 'limiting
significance threshold' curve to assist assessment of the former.  (DISPLAY
LAYER 1 to see the rcf only, without the significance threshold superposed).
For the cross-correlation mode, the threshold is 2/root(N), where N is the
number of independent Fourier components in the relevant band: where
correlation levels are low, this is twice the expected standard deviation of
the correlation values.  For the PHASERESIDUAL mode, it is simply a constant
value of pi/4 - a less optimistic threshold corresponding to a correlation
level of 0.71.

If the original images are severely masked off, the number of independent
Fourier components is reduced, and RCF adjusts the significance threshold
curve appropriately if you tell it the mask RADIUS (e.g., RCF 1 WITH 2 RADIUS
45 in the last example above).
                                                 Multi-layer pictures: faulted
                                                 Form used internally: complex

See also: rcf.syntax
$add rcf.syntax
Keys:
  [FROM]         first source picture [SELECT]
  [TO]           output picture for correlation function [999]
  WITH           second source picture [none]
  OVER           width in pixels of bands of Fourier components compared at
                 each spatial frequency [1]
  RADIUS         radius of real-space mask applied to images compared;
                 affects significance threshold only [infinite]

Options:
  PHASERESIDUAL  produce phase-residual instead of radial correlation function

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add read.command read get
You use READ to read pictures from files created by programs other than
Semper, or to recover pictures from files create previously with the WRITE
command.

Exx: READ 20 NAME 'SEC34.DAT'
       reads picture 20 from the file "sec34.dat"
     READ UNFORMATTED
       prompts at the terminal for the file name, and reads to the current
       picture, using Fortran unformatted input
$
The default file extension for reading formatted files is ".dat" and for
reading unformatted files is ".unf".  Prior to release 6.4, Semper used ".dat"
for unformatted files.  Therefore, if the file is not found using the file
extension ".unf", READ will try again with the extension ".dat" before
reporting an error.

If a file has been written using Fortran unformatted output, you must specify
the UNFORMATTED option with the READ command.

A precise description of the file formats supported by the READ and WRITE
commands is to be found in the separate document entitled

    Semper 6 READ/WRITE file format

This document can be obtain on request from Synoptics.

                                      Multi-layer pictures: fully supported
                                     Forms used internally: integer,fp,complex

See also: read.syntax, write
$add read.syntax
Keys:
  [TO]           picture to be read [SELECT]
  NAME text      name of file containing picture data  [none; prompts if
                 interactive]

Options:
  AGAIN          If NAME omitted and no write operations have taken place
                 since the last read, use the last value of NAME.
  UNFORMATTED    read the file using Fortran unformatted input

The UNFORMATTED option must be specified if the file was written using Fortran
unformatted output.

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add reclass.command reclass
You use RECLASS if you want to override Semper's default classing of pictures,
and make it treat a picture as if it contained data of a different or special
kind.

Exx: RECLASS 53 PLIST
       makes Semper treat picture 53 as a Plist (position list) picture
       subsequently (sensible only if you have set its contents appropriately)
     PS 1; RECLASS IMAGE; FOURIER; WEIGHT WITH..; IMAGE
       reclasses a Spectrum so that it can be Fourier-filtered
$
RECLASS alters pictures labels only, not the data in the pictures or any other
characteristic such as the origin.  You may give any of the class names as the
option; you cannot however reclass Macro pictures, or change other classes to
Macro.

If you are reclassing a picture as a Plist, the additional options LIST,
CURVE, OPEN and CLOSED can be used to force the type as follows:
   .. PLIST  or  .. PLIST LIST                list
   .. PLIST CURVE  or  .. PLIST OPEN CURVE    open curve
   .. PLIST CLOSED CURVE                      closed curve

See also: reclass.syntax
$add reclass.syntax
Keys:
  []             picture to be reclassed [SELECT]

Options:
  IMAGE|FOURIER|SPECTRUM|CORRELATION|UNDEFINED|WALSH|HISTOGRAM|PLIST|LUT
                 new picture class [IMAGE]
  LIST | CURVE   if PLIST set, position list type [LIST]
  OPEN | CLOSED  if CURVE set, open or closed curve [OPEN]
  AS             ignored

The option AS is permitted for readability only, e.g. RECLASS 51 AS LUT.

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add reinitialise.command reinitialise
You use REINITIALISE to delete the contents of picture storage devices,
program libraries and help libraries.  You can also alter the size of the
directory by using the SLOTS key.

Exx: REINITIALISE SLOTS 100
       reinitialises the current device CD with a 100 slot directory
     REINITIALISE DEVICE 5
       reinitialises device 5 with the largest directory possible
$
REINITIALISE completely ignores any information already on the device, whether
protected or not.  However, it seeks confirmation from the terminal before
proceeding in any case, and refuses to alter a write-protected device.

The SLOTS key allows you to specify the directory size.  For picture files,
the default directory size is the maximum possible (each slot requires 8 bytes
and the absolute maximum number of slots required is 2002, giving a maximum
size of 16KB), so the SLOTS key allows you to create a picture file with a
smaller directory.  Each program in a program library takes up one slot of 64
bytes and the default is to create a program library with 64 slots. Directory
entries in a help library vary in size, but the slot size is assumed to be 64
bytes, with a default directory size of 400 slots (a total size of 25KB).

See also: reinitialise.syntax
$add reinitialise.syntax
Keys:
  DEVICE         device number [CD]
  SLOTS          number of new directory slots [maximum possible for picture
                 storage device, 64 for program library, 400 for help library]

Options:
  VERIFY         confirm initialisation on the console [YES]

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add rename.command rename
You use RENAME to change the name by which a program in a program library is
identified, without altering or copying its text.

Exx: RENAME PROGRAM 'COMBINE' AS 'OLD$COMBINE'
        does just that
     RENAME PROGRAM 'COMBINE'
        prompts at the terminal for the new name

As always, if more than one copy of a program exists in your libraries, it is
the first one found in the current search order that is renamed.
$
Since Semper only considers the first three letters of names, RENAME is not in
fact distinguished from RENUMBER (which renumbers pictures).  The presence of
one or other of the keys PROGRAM and AS is therefore essential for the RENAME
command to take effect.  However you may omit the other if you like, in which
case Semper prompts for it at the terminal.

See also: rename.syntax
$add rename.syntax
Keys:
  PROGRAM text   old program name [none; prompts if interactive]
  AS text        new program name [none; prompts if interactive]

Options:
  VERIFY         confirm renaming of program on the console [YES]

You must specify at least one the the keys PROGRAM and AS.

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add renumber.command renumber
You use RENUMBER to change the number by which a picture is identified,
without altering or copying its contents.

Exx: RENUMBER 1 TO 10
       changes the number of picture 1 to 10
     RENUMBER TO 772
       changes the number of the current picture to 772
$
You can only change picture numbers within a device and the new number you
give must not be that of an existing picture.

Display pictures cannot be renumbered because the display partitions
associated with each display picture number can occupy different areas of
display memory and therefore it cannot be guaranteed that the picture contents
will not change, or, indeed, that the new display partition is even large
enough to contain the original picture area.  However, there is nothing to
prevent you from creating overlapping display partitions and pictures and
accessing the same data using different display picture numbers.

See also: renumber.syntax
$add renumber.syntax
Keys:
  [FROM]         old picture number [SELECT]
  [TO]           new picture number [FROM]

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add report.command report last trap error
You use REPORT to repeat the last error message or to print the message for
the last error that was trapped.  The text is output to the diagnostic output
stream.

Exx: REPORT ERROR
       outputs the last error message
     REPORT TRAP EXIT
       outputs the error message for the last trap and sets RC to 10

The option EXIT is used to force an exit from a sequence of commands.
$
Although it can be used to repeat an error message that has gone off screen,
the main use of REPORT is to generate an error message after aa error has been
trapped, for example,

             TRAP = -1 EXAMINE PICNO       ; ! trap any error
             N = RC                        ; ! save error code
             IF N = 30 JUMP NOPICTURE      ; ! test no picture
             IF N = 34 JUMP NODISC         ; ! test no device
             REPORT TRAP EXIT              ; ! other error - report

By default REPORT will ouput the last error message, or the last trap
message if there has not been an error reported yet.  Note that only the
final line of any error report sequence is given, any context or prior
explanatory messages are not preserved.

See also: report.syntax
$add report.syntax
Options:
  ERROR | TRAP   Output last error message or last trapped error
  EXIT           Force exit from a command sequence by setting error 10
$add rewind.command rewind
The REWIND command is not available in this installation.
$add rf.command rf recursive
You use RF to apply two point 'recursive' filters to pictures; the effect is
smoothing or sharpening as if by convolution with an infinitely wide point
response.

Exx: RF 1 TO 2
       smooths picture 1 to picture 2 (mildly)
     RF TO DISPLAY A .9
       displays a strongly smoothed version of the current picture
     RF A -.3
       replaces the current picture by a (mildly) sharpened version

Positive values for the filter width parameter A smooth the picture (retain
the low frequencies), and negative values sharpen it (retain the high
frequencies).  The filter action becomes progressively stronger as A
approaches 1 or -1.
$
Underlying RF is a simple 1-D recursive filter: an output pixel f'(i)
is calculated as a weighted average of the original value f(i) and the last
calculated filtered value f'(i-1)

  f'(i) = a.f'(i-1) + (1-a).f(i)

This has a one-sided point response (negative exponential in shape).  It is
applied in each direction in turn along rows and columns (along the row
only if 1-D) so as to achieve a symmetric point response.

The 1-D spatial frequency response is (1+a^2-2a)/(1+a^2-2a.cos{2pi.i.k/N}) for
a transform pixel k points from the origin; this is unity for zero frequency,
and falls or rises to [(1-a)/(1+a)]^2 at the maximum frequency.  For positive
values of the weighting factor a, the point response has the approximate form
exp{-|x|/w}, with w = 1/|ln{a}| pixels, which has a full width at half height
of about 1.4/|ln{a}|.  (The 2-D responses are simply the product of the 1-D
responses in each direction.)
                                    Multi-layer pictures: all layers processed
                                    Form used internally: fp

See also: rf.syntax
$add rf.syntax
Keys:
  [FROM]         source picture [SELECT]
  [TO]           output picture [FROM]
  A              filter width parameter in range -1 to 1 [.3]

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add rgb.command rgb full false colour monochrome display
RGB converts a full colour image into one of a number of forms suitable for
displaying the image on a monochrome or false colour framestore.  Each output
format makes a different compromise in trying to preserve as much of the
spatial and colour information in the original image as possible.

Exx: RGB 1 TO 2; LUT CREATE MONOCHROME; DISPLAY 2
       converts the full colour byte image in picture 1 into a monochrome
       picture 2 and then displays the result
     RGB 3:1 FALSE
       outputs a false colour conversion of the source image directly to the
       display and modifies the current look-up table for viewing the result
     RGB 3:1 FALSE LEVELS 4,5,3
       same as the previous example, but with the levels assigned to the red,
       green and blue data specified explicitly
     RGB 3:1 SAMPLED TO 3:2 LUT 3:3
       outputs a sampled or dithered representation of the source image
       to picture 3:2 and the corresponding look-up table to picture 3:3
$
RGB provides various ways to generate representations of a full colour image
that can be viewed on monochrome and/or false colour displays.  You select the
type of conversion you want by specifying one of the options MONOCHROME,
FALSE, SAMPLED and AVERAGED.  The default option is MONOCHROME.

The source picture must be in byte form and it must have precisely three
layers.

The conversions for options MONOCHROME and FALSE combine the red, green and
blue information for each pixel to produce a single output value which will
fit within the range of output values for the display (use the command SHOW
SYSTEM or LUT ENQUIRE to find out how many output levels your display will
support).  Both of these conversions preserve full spatial resolution at the
expense of the combined colour and intensity resolution.

For the MONOCHROME option, the result for each pixel is a weighted sum of the
red, green and blue intensities:

      output value = 0.299 * red + 0.587 * green + 0.114 * blue

This retains the luminance (perceived intensity) and discards the colour
information.

For the option FALSE, the red, green and blue intensities are converted to the
corresponding level within the number of intensity levels specified for red,
green and blue by means of the LEVELS key (nr, ng and nb below).  The three
discrete colour intensities  are then combined into a single output value:

      r = round( ( nr - 1 ) * red / 255 )
      g = round( ( ng - 1 ) * green / 255 )
      b = round( ( nb - 1 ) * blue / 255 )

      output value = ( ng * nb * r ) + ( nb * g ) + b

This approach sacrifices intensity resolution to introduce some colour
information.

If the LEVELS key is omitted when the option FALSE is specified, a default
that is suitable for your particular display will be provided.  For an 8-bit
display, the default is 8,8,4 and for a 7-bit display the default is 4,8,4.
For any other displays, the levels are chosen to give as near as possible a
2:2:1 ratio between the number of red, green and blue intensity levels.  When
using the LEVELS key, you must specify at least 2 levels for each colour and
the product of the three numbers must not exceed the maximum number of output
levels for the display.

The conversions for options SAMPLED and AVERAGE sacrifice some spatial
resolution to give full resolution for colour.  Each output pixel displays a
red or a green or a blue intensity that is either taken directly from the
corresponding source pixel (SAMPLED option) or is obtained by taking the
average of three adjacent pixels in the source image (AVERAGED option).  The
results are approximately the same for both options except that the AVERAGED
option will avoid any of the aliasing effects that the SAMPLED option may
introduce when the source image is sampled.  Although much better colour
resolution is obtained by this approach, the brightness of the displayed image
will be reduced to about a third (since only one of the three colour phosphors
is excited at each output pixel on the display).

When output from the RGB command is displayed, you have to use a look-up table
that corresponds to the output representation used.  For the MONOCHROME
option, a grey-scale ramp is required (use the command LUT CREATE MONOCHROME
or LUT RESET to generate one).  For the other conversions, the RGB command
generates the appropriate look-up table.  If the image is output to the
display, the current look-up table is modified.  Otherwise, the look-up table
data is output to the Lut class picture specified by the LUT key.

See also: rgb.syntax, lut
$add rgb.syntax
Keys:
  [FROM]         source picture (must be 3 layer, byte form) [SELECT]
  [TO]           output picture [DISPLAY]
  LUT            if not MONOCHROME and output is not to display, output
                 picture for look-up table data [999]
  LEVELS(3)      if FALSE, number of levels for red, green and blue data
                 [8,8,4 if 8-bit framestore, 4,8,4 if 7-bit framestore,
                  otherwise depends on number of framestore levels]

Options:
  MONOCHROME | FALSE | SAMPLED | AVERAGED  required conversion from full
                 colour to monochrome/false [MONOCHROME]

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add rhistogram.command rhistogram feature feature.plot histogram
The RHISTOGRAM command forms a 2-D histogram (feature space plot) of two
layers of a picture.

Exx: RHISTOGRAM 1 DISPLAY BANDS 2,5
       form a 2-D histogram of picture 1 using the layers 2 and 5 and output
       the results directly to the display
     MIN=0,0 MAX=64,64 RHISTOGRAM 1 2 BANDS 4,1 PRESET
       form a 2-D histogram of picture 1 in picture 2, limiting the histogram
       to the intensity range 0 to 64 in each band
$
A two dimensional histogram (or feature space plot) is formed from the two
specified layers of the source picture.  The layers to use are given by the
BAND keys.  The number of channels (which determines the  size of the output
picture, TO) is limited by the length of a Semper row buffer.  If neither of
the CHANNEL keys is specified then the number of bins defaults to its maximum
possible value.  If the option PRESET is given then the values of the
variables MIN, MI2, MAX and MA2 are used to delimit the ranges over which the
command is to operate.  If the TYPE option is given and the output is to the
display then a character based histogram is displayed on the console, rather
than the display.

On exit the variables MIN, MI2, MAX and MA2 are set to those values used,
during the histogramming operation.

See also: rhistogram.syntax
$add rhistogram.syntax
Keys:
  [FROM]        source picture [SELECT]
  [TO]          output picture [DISPLAY]
  CHANNEL(2)    number of channels to divide histogram into [maximum possible]
  BAND(2)       specifies which two layers to use to form histogram [none]
  TIMES         scaling on output if to display [1]
  SIZE(2)       dimensions of subregion to be processed [whole picture]
  POSITION(2)   position/offset of subregion [0,0]
  ASPECT        aspect ratio [default given by PAGE command]
  WIDTH         display width (no. characters/line) [default given by
                PAGE command]

Options:
  PRESET        use fixed range values (see MIN(2),MAX(2) below)
  TOP | BOTTOM  process subregion abutting indicated border
  LEFT | RIGHT
  REPEATING     repeat histogram counts when magnifying, instead of
                interpolating
  LETTER        letter top of partition with picture number, title, etc. [YES]
  BORDER        mark display border [YES]
  TYPE | LOG    character based display to console or log output stream
  VERIFY        list on the console the output ranges

Variables used:
  MIN(2),MAX(2) If PRESET, specifies range for two layers to be processed

Variables set:
  MIN(2),MAX(2) Set to range used to process two source layers

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add rotate.command rotate
You use ROTATE to rotate pictures by 'large' angles (angles of 45 to 135
degrees, typically), since it is much quicker at this job than EXTRACT.

Exx: ROTATE DISPLAY ANGLE PI/2
       rotates the display 90 degrees clockwise
     ROTATE 50 TO 51 ANGLE RAD(-40) VALUE 57
       rotates picture 50 to 51 by 40 degrees clockwise, padding regions
       that overflow the source picture with the value 57

The picture must be square, and its size must be one of the 'factorisable'
sizes listed in response to SHOW SIZES).  You can of course CUT other
pictures, if necessary, to a suitable (larger) size, ROTATE and then CUT again
afterwards.  The rotation is about the centre of the picture, not its origin,
but the recorded origin is updated appropriately (rounded to the nearest
pixel).
$
The algorithm used involves a relatively fast multi-radix transposition step,
and the execution time is independent of the angle involved.  The field of
view is reduced slightly - only by 2% or so for angles in the range 60-120
degrees, but by progressively larger amounts for angles outside this range;
for this reason, ROTATE faults angles within 30 degrees of 0 or 180 degrees.

                                              Multi-layer pictures: faulted
                                             Forms used internally: fp,complex

See also: rotate.syntax, extract, show, cut
$add rotate.syntax
Keys:
  [FROM]         source picture [SELECT]
  [TO]           output picture [FROM]
  ANGLE          angle by which picture is rotated clockwise, in radians [0]
  VALUE          constant value used for filling regions overflowing rotated
                 source [0]

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add run.command run runfiles
A RUN command makes Semper read and execute commands from the beginning of
a 'run file' until a RETURN or END command, or an end-of-file condition.
(See PROGRAMS for general information about indirect command execution.)

Ex: RUN NAME 'SPECTRA'
      runs the file SPECTRA (or SPECTRA.RUN if the installation forces the
      extension

No special format is needed for a run file.  The commands are executed exactly
as if they were entered at the terminal, except that JUMPs may refer to labels
anywhere in the file before or after the JUMP command.  FOR loops are subject
to the same maximum length as applies to loops typed interactively.  Programs
may be called freely.

Any text in the command line which comes after the RUN command is discarded.
Therefore, the RUN command should always appear at the end of a command line.

See also: run.syntax
$add run.syntax
Keys:
  NAME text      name of file containing commands to be run [none; prompts if
                 interactive]
Options:
  AGAIN          If NAME omitted, and no write operations have taken place
                 since the last file read, use the last value of NAME.

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add save.command save dump archive backup store output write
SAVE allows you to dump copies of pictures to newly created disc files for
backup or archive purposes.  The pictures can be recovered later by using the
commands ASSIGN, EXAMINE and COPY as required.

Exx: SAVE 20 NAME 'PAPER.FIGS'
       saves a copy of pic 20 in the file PAPER.FIGS
     SAVE 1,999 NAME 'DIFFGRAMS' NODEASSIGN; EXAMINE DEVICE N LOG
     DEASSIGN DEVICE N
       copies all of the pictures contained in the current device to the file
       DIFFGRAMS.DSK, recording details in the log file before deassigning
$
SAVE combines the facilities of the commands ASSIGN NEW, COPY and DEASSIGN,
providing a convenient way to save or collate pictures into picture discs.
In its simplest form, the SAVE command carries out the following sequence of
operations:

(1)  It searches for any pictures that exist in the range of picture numbers
     specified with the FROM key. Note that the range must lie entirely
     within a single picture device. By default, the current picture is saved.

(2)  It creates a new picture disc file with overall file size and directory
     size just large enough to accommodate the number of pictures to be saved.
     The file name is specified with the NAME key and the default extension
     for the file name is ".dsk".

(3)  All the specified pictures are copied to the new picture disc with the
     same picture number and exactly the same information (except that all
     write-protect flags are turned off).

(4)  The new picture disc is deassigned.

The RENUMBER and NODEASSIGN options and the DEVICE, SIZE and SLOTS keys may be
used to alter the SAVE command's default behaviour.

If the RENUMBER option is set, the pictures are numbered from 1 upwards
instead of retaining their original picture numbers.

If the NODEASSIGN option is given, the new picture disc is left assigned for
further use during the current session and the device number is returned in
the Semper variable N.  You can specify a device number for the picture disc
with the DEVICE key, otherwise, the SAVE command assigns the lowest free
device number.

With the SIZE and SLOTS keys you can cause the SAVE command to assign the new
picture disc with a larger file size and directory size.  A size which is
smaller than the minumum required to save the specified pictures will be
faulted (the error message will state what is the minimum requirement).  If
the SIZE key is set, the SAVE command performs exactly the same function as
the ASSIGN NEW command.  In this case, the default for the SLOTS key is
changed to be the maximum number of directory slots for a picture disc.

If the VERIFY option is set, the SAVE command verifies its operation on the
console (device assign/deassign and source and destination picture numbers).

See also: save.syntax, assign, examine, copy
$add save.syntax
Keys:
  [FROM(2)]     first,last pictures in range to be saved [SELECT,SELECT]
  NAME text     name of save file to be created [none; prompts if interactive]
  DEVICE        device number for assignment [first free device number]
  SIZE          device file size in KB [minimum required to store data for
                specified range of pictures]
  SLOTS         number of directory slots to be allocated [if SIZE key
                omitted, number of pictures saved + 2, otherwise, smaller of
                2002 and (row buffer size in bytes)/8]

Options:
  DEASSIGN      deassign save file on exit [YES]
  RENUMBER      renumber output pictures from 1 upwards [NO]
  VERIFY        verify device assign/deassign and source/destination picture
                numbers [NO]

Variables set:
  N             if NODEASSIGN, device number assigned

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add scale.command scale rescale
You use SCALE to re-scale pictures linearly so as to have a different pixel
range - scaling into the range 0-255 before conversion to Byte form, for
example, or standardising grey scales between several different pictures which
you want to combine into a montage.

Exx: SCALE 1 BYTE
       scales picture 1 into the range 0 to 255 and converts to Byte form
     SCALE 50 51 MSD 1,.2
       scales 50 to 51, with a final mean of 1 and a standard deviation of 0.2
     SCALE RANGE 1E3,1.3E3
       scales the current picture into the range 1000 to 1300
     MIN=0 MAX=2; SCALE PRESET RANGE 20,10
       scales the current picture so that the range 0 to 2 becomes 20 to 10
       (which means the contrast is reversed)
$
Linear rescaling means replacing source pixels p by p'=ap+b, for suitably
chosen constants a,b.  For more general rescaling operations, including
histogram equalisation, use the MAP command.

If necessary, SCALE scans the source picture to determine the initial range or
mean and standard deviation. An abandon request at this stage simply causes it
to continue with estimated parameters.

The final range is recorded in the output picture label, and returned in the
variables MIN and MAX whenever it is known reliably (i.e. unless MSD, PRESET
or abandoned during an initial range scan).  Otherwise, MIN,MAX (if MSD is
set, MEAN, ME2 and SD as well) are reset to the source picture values.

When the output form is byte, pixel values outside the range 0 to 255 are
truncated.

                      Multi-layer pictures: fully supported
                     Forms used internally: integer (for byte data),fp,complex

See also: scale.syntax, map
$add scale.syntax
Keys:
  [FROM]         source picture [SELECT]
  [TO]           output picture [FROM]
  RANGE(2) | MSD(2)  required range or mean and standard deviation for output
                 picture [range 0,255]

Options:
  PRESET         assume source picture range given by current values of
                 MIN and MAX

Variables used:
  MIN,MAX        if PRESET set, range of source pixel values to be scaled onto
                 required output picture range

Variables set:
  MIN,MAX        unless PRESET or MSD set, output picture range
  MEAN(2),SD     if MSD set, source picture mean and standard deviation

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add section.command section radial average
You use SECTION to extract radial sections from pictures, optionally averaged
over a given sector or the whole picture, in the form of 1-D pictures.

Exx: PS 50; SECTION TO 51; DISPLAY
       displays the rotationally averaged power spectrum of picture 50
     SECTION 21 POSITION 10,20 ANGLE PI/2 WIDTH .4
       replaces picture 21 with an average radial section over a vertical
       sector of angular width 0.4rad radiating from the point (10,20)
     SECTION ANGLE THETA
       produces an interpolated section radiating from the origin in the
       direction indicated
$
The picture is normally averaged over all angles.  You restrict the average to
a sector by specifying the angle and extent in radians of the sector with the
ANGLE and WIDTH keys respectively.

The sections averaged radiate from the picture origin, unless you specify an
offset relative to the origin with the POSITION key.  The output is 1-D, with
the origin at the left.  Its size is chosen so as just to accommodate all
source pixels.

In detail, an initial section is extracted by bilinear interpolation (a narrow
sector might include no source pixels at all).  Any pixels falling within the
sector specified are then averaged with this, with weighted contributions
added to adjacent output sums.  Therefore, setting the WIDTH key to zero will
result in a radial section obtained only by bilinear interpolation.

If the MARK key is set, the direction of the section and its angular limits
are marked on the indicated display picture.
                                              Display marking: sector averaged
                                         Multi-layer pictures: faulted
                                         Form used internally: complex

See also: section.syntax
$add section.syntax
Keys:
  [FROM]         source picture [SELECT]
  [TO]           output picture [FROM]
  POSITION(2)    centre of circle or sector [0,0]
  ANGLE          central direction of sector, in radians anticlockwise from
                 the positive X axis [0]
  WIDTH          angular width of sector, in radians [PI]
  MARK           display to be marked with section centre line and angular
                 limits [none]

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add select.command select
The SELECT command allows you to make any picture you like 'current', and so
the default for subsequent operations.  For example,
     SELECT 2:53
makes picture 2:53 current, so that DISPLAY typed on its own displays picture
2:53, the P command operates on picture 2:53 etc.  The variable SELECT is
reset accordingly.

See also: select.syntax
$add select.syntax
Key:
  [FROM]         picture to be selected [SELECT]

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add separate.command separate layers
You use SEPARATE to copy one or more layers of a multi-layer picture to a
separate output picture for each layer.

Exx: SEPARATE 50 TO 51
       separates all the layers of picture 50 as pictures 51,52..
     SEPARATE LAYERS 3,5 TO 101
       separates layers 3, 4 and 5 of the current picture as pictures 101,
       102 and 103
     SEPARATE LAYER 9
      replaces the current picture with layer 9 of the same picture

Note that the TO key specifies the first output picture number.  If more than
one source picture layer is specified with the LAYER key, the second and
subsequent layers are copied to pictures TO+1, TO+2, etc.
$
                                                    Forms used internally: all

See also: separate.syntax
$add separate.syntax
Keys:
  [FROM]         multi-layer source picture [SELECT]
  [TO]           first output picture (second output picture = TO+1, etc.)
                 [FROM]
  LAYERS(2)      single layer or range of layers to copy [all layers in source
                 picture]

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add sharpen.command sharpen enhance
SHARPEN applies a simple picture sharpening filter, effectively doubling the
high spatial frequencies (fine detail) by adding to each pixel the difference
between the pixel and the average value over a block of neighbouring pixels
(see the command LMEAN for more about local averaging).

Exx: SHARPEN DISPLAY
       sharpens the current display picture
     SHARPEN 50 TO 51 OVER 3
       doubles only frequencies with a period no greater than 3 pixels, from
       picture 50 to picture 51
$
You use the key OVER to specify the size of block over which the SHARPEN
command operates (the filter kernel).  1-D horizontal and vertical filter
kernels can be obtained if you use the option HORIZONTAL or VERTICAL.  It is
not useful to specify large values for OVER, however, as this does little more
than double the picture range without enhancing any of the fine detail.

The general form of the filter kernel will be clear from its value in the
particular case of OVER 3:

            (1/9) (-1  -1  -1)
                  (-1  17  -1)
                  (-1  -1  -1)

Edge pixels of the source - where the block averaged overflows the source -
are processed as if the boundary values were repeated indefinitely outwards.
When OVER is even, the source pixel replaced is rounded to the bottom right
from the block centre.

                                              Multi-layer pictures: faulted
                                             Forms used internally: fp,complex

See also: sharpen.syntax, lmean, hp
$add sharpen.syntax
Keys:
  [FROM]         source picture [SELECT]
  [TO]           output picture [FROM]
  OVER           filter kernel size [5]

Options:
  HORIZONTAL | VERTICAL   apply 1-D horizontal filter (kernel size = OVER,1)
                 or 1-D vertical filter (kernal size = 1,OVER) [apply 2-D
                 square filter (kernel size = OVER,OVER)]

Note:
  Globally setting the VERIFY option will trigger the VERTICAL option for this
  command.

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add sheet.command sheet shadedimage 3dimage perspective surface
You can use SHEET to generate a shaded image of a 3-D surface (sheet) the
height of which is tabulated in a 2-D picture; options allow you to vary the
viewing orientation, output size etc.

Exx: LOR 1 SIZE 150; MIN=0 MAX=255; SHEET RANGE 10,100 BORDER 0
       generates shaded image on DISPLAY of 2-D Lorentzian 'spike' 100 pixels
       high with bordering 'wall' 10 pixels high
     SHEET 1 TO 5 THETA PI/3 PSI PI/6
       generates in 5 image of surface differently oriented (rotated 60
       degrees clockwise in-plane, then tilted 30 degrees, top away from you)
     SHEET SIZE 300,200 TIMES 3
       generates image magnified three times, in output with given size

Note that output goes to DISPLAY in default.
$
SHEET is necessarily a rather complicated command, except that most of
the keys/options can be allowed to default for most purposes; details
of the illumination and surface reflectivity model are given separately
(see ILLUMINATION), in case you want to vary these.

The 3-D object presented (keys RANGE, BORDER and ZORIGIN): the source pixels
are normally interpreted directly as height (Z) values above an X-Y plane; you
can make SHEET scale to represent a different range of heights by quoting the
RANGE you want as in the first example, and if you key a BORDER value, a
border with the given height is added around the sheet so that vertical walls
link the edges of the displayed sheet to a reference horizontal.  The ZORIGIN
key allows you to move the view centre position in the Z direction, if the
default of the mid-point of the height range is not appropriate.

The orientation (keys THETA and PSI): standard Semper display facilities
present you with X-Y layers, as if you were looking down on to the surface
(along the -Z axis).  Starting from this orientation, SHEET presents the 3-D
object after it has been rotated first clockwise by the key THETA as you ivew
it, and then by the key PSI anticlockwise about the +X axis (i.e. top away
from you).  The defaults (THETA=PI/4, PSI=PI/4) present the object turned to
the right and then tilted away from you.  You should not make the magnitude
of PSI exceed PI/2 however (attempt to look at the underside of the sheet);
SHEET does not produce correct results in such cases.

The output picture (keys TIMES, SIZE, POSITION, VALUE): you can increase or
decrease the size of the view generated via the key TIMES, which takes
fractional as well as well as integral values, e.g. SHEET..TIMES .75 or
SHEET..TIMES 1.5.  In default, the output is made large enough to accommodate
the 3-D box enclosing the sheet, in the orientation you select.  If you want
to force the size (e.g. to stop the size changing with the orientation, you
can use the key SIZE to specify it, and the shaded image is simply truncated
if necessary.  By default, the centre of view is positioned at the centre of
the output picture.  You can reposition the view centre by specifying an
offset with the POSITION key.  If the view centre lies within the limits of
the output picture, the output picture's origin is set to the view centre,
otherwise it defaults to the centre of the output picture.  Default values for
the illumination keys ensure that the output pixel values lie in the range
0-255 allowed for byte pictures, and Byte is accordingly the default output
form. The sheet is normally presented on a background of zero (dark) pixels,
but you can control this via the key VALUE if you want to.

See also: sheet.syntax
$add sheet.syntax
Keys:
  [FROM]         source picture [SELECT]
  [TO]           output picture [DISPLAY]
  RANGE(2)       range of heights to be represented by actual pixel range
                 [actual pixel range]
  BORDER         value of constant border to be added around the edge [none]
  ZORIGIN        Z value for view origin [mid point of range]
  THETA          first rotation applied to object before viewing; anti-
                 clockwise about +Z axis (clockwise as you view) [PI/4]
  PSI            second rotation applied to object before viewing; anti-
                 clockwise about +X axis (top inwards as you view) [PI/4]
  SIZE(2)        output picture dimensions [depend on source picture size,
                 height range, and viewing orientation]
  POSITION(2)    view centre position in output picture [0,0]
  TIMES          (not nec integral) magnification factor for output [1]
  VALUE          background value for use outside view of sheet [0]
  LTHETA         angle between main light source direction and +Z axis, in
                 radians [PI/4]
  LPHI           azimuth of main light source direction, anti-clockwise from
                 +X axis, in radians [0]
  MAIN           brightness of main illumination source [154]
  FORWARD        brightness of subsidiary (forward) illumination [42]
  AMBIENT        brightness of non-directional ambient illumination [40]
  DCONTRAST      depth contrast - brightness difference between front and
                 rear of object [30]
  SDR            specular to diffuse ratio - how polished the surface is;
                 0 upwards [.4]

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add show.command show
SHOW lists on the console various kinds of information about your session.

Exx: SHOW DEVICES        [or SHOW DEVICE 3, or SHOW DEVICES 3,5]
       reports the devices currently assigned, with details
     SHOW PARTITIONS     [or SHOW PARTITION FS:3 etc.]
       reports the display partitions currently defined, with details
     SHOW LUTS           [or SHOW LUT 2 etc.]
       reports the luts currently defined
     SHOW TIME
       reports the date and time
     SHOW PATH
       reports the file search path
     SHOW PROGRAMS
       reports the names of all programs in any libraries assigned
     SHOW PROGRAMS FULL
       reports the program index usage as well
     SHOW PROGRAMS DEVICE N
       reports the names of any programs in the library on device N
     SHOW USAGE TIME
       reports the usage of the item TIME within the current syntax
     SHOW VARIABLES
       reports the value of all variables currently set
     SHOW
       tells you other things SHOW knows about (MACROS,COMMANDS,SYSTEM etc.)

See also: show.syntax
$add show.syntax
Keys:
  [(2)]          device/partition/lut/error number to be shown (or first,last
                 number of a range) [all]
  USAGE name     name of item to locate within the current syntax

Options:
  VARIABLES      show all set variables, with values
  DEVICES        show assigned devices (discs,tapes,display,libraries)
  PARTITIONS     show defined display partitions
  LUTS           show defined look-up-tables
  TIME           show date and time of day
  PROGRAMS       show names of all programs in assigned libraries
                 (with DEVICE option, shows programs from specified libraries)
  FULL           with PROGRAMS option shows the program index usage as well -
                 this is useful in determining when to break a program into
                 several components
  PATH           show the search path used to locate files
  COMMANDS       show all commands available
  MACROS         show all named macros available, with replacement texts
  SYSTEM         show installation details (size limits, buffer sizes, etc.)
  ERRORS         show standard error messages, with numerical error code
  SIZES          show 'factorisable' sizes up to the maximum row length
  ECHO           show current echo settings for standard output stream
                 (terminal), standard error stream and any log files
  PAGE           show current terminal output page settings

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add sketch.command sketch draw position list curve
SKETCH allows you to draw curves on the display using the mouse or pointing
device.  You move the cursor to the start point of the curve, and as soon as
one of the mouse buttons is pressed down, a curve is drawn and recorded which
tracks all the movements of the mouse until you release the mouse button.  The
result is stored in a position list picture.  The TOLERANCE key provides the
option to filter the results so that longer or more detailed curves which
would normally overflow the input buffers can still be handled.

Exx: SKETCH FRAME 1 TO 2:3
       draw a curve on display frame 1 and store the results in picture 2:3
     SKETCH TO 1 TOLERANCE 1.5
       draw a curve on the current display picture and store the filtered
       version as picture 1.
$
With the SKETCH command you can draw curves free-hand on the display.  The
curve can be drawn in a display frame or partition, or it may be drawn on top
of a display picture using the underlying image to guide the sketching
process.  This allows you to digitise features in images with considerable
ease.  You start the sketching process by moving the mouse to the start of the
curve and then drawing the curve by pressing one of the mouse buttons and
moving the mouse.  Data for the curve is recorded until the mouse button is
released.  You may alternatively press any key on the keyboard to start and
end the sketching process.

Some curves may be very detailed and SKETCH may generate more data than can be
buffered.  SKETCH incorporates a point filtering facility which will allow
longer or more detailed curves to be digitised.  The resulting curve will
depart from the original curve by a distance that will not exceed the value
given by the TOLERANCE key.  The default for the TOLERANCE key (zero) filters
out redundant points that lie in straight lines.  The filtering process is
described in more detail in the documentation for the PFILTER command.

The curve will be drawn on the display as it is being input.  If the CLOSED
option is specified, the curve will be closed off at the end by SKETCH drawing
a straight line from the end point to the start point of the curve.  A cursor
will be displayed throughout the duration of the SKETCH command.  The cursor
will appear at the position indicated by the POSITION keys.  Also, if the VIEW
option is set, the view will be switched so that the area of interest is made
visible.

For complex display pictures, where the real and imaginary parts of the image
are displayed side by side, SKETCH would normally display the cursor on the
real part and draw the curve on both parts.  If, however, you specify the
option RE or IM, sketching will be carried out in just the real or imaginary
part.

The length of the resulting curve is returned in variable P, and the area for
a closed curve is returned in variable A.

See also: sketch.syntax, pfilter
$add sketch.syntax
Keys:
  []             picture/partition/frame on which to sketch curve [DISPLAY if
                 picture or partition; CFRAME if frame]
  [TO]           output picture [999]
  TOLERANCE      tolerance for approximating the curve [0.0]
  POSITION(2)    start position for the cursor [0,0]

Options:
  PICTURE | PARTITION | FRAME  use indicated coordinate system [PICTURE]
  CLOSED         generate a closed curve [open curve]
  RE | IM        operate with respect to real or imaginary part of complex
                 display picture [display cursor in real part, draw curve in
                 both parts]
  VIEW           switch view to make display region visible

Variables set:
  P              length of the curve
  A              area enclosed by the curve (closed curve only)

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add skiz.command skiz skeleton zones_of_influence distance transforms
You use the SKIZ command to generate the "skeleton by zones of influence" or
skiz associated with the source image.  The skiz is the locus of points which
are equidistant from the labeled regions defined by the source image and is
the complement to the zones of influence associated with the same source
image (see ZONE).  A binary image is output with 1's for pixels that lie
on the skiz and 0's elsewhere.

By default, the source picture is treated as a binary image and a temporary,
labeled image is obtained from it.
(see LABEL for details of the labeling process).

If the LABEL option is set, the source image is treated as being already
labeled.  Distances between pixels are measured, by default, using the true
Euclidean metric.  Faster and possibly acceptable results can be obtained
with simpler metrics by specifying one of the options DIAMOND, SQUARE or
OCTAGON (see DT to find out more about distance transforms and metrics).

Exx: SKIZ
       replaces the binary image in the current picture with the skiz
       associated with the connected foreground regions of the binary image
     SKIZ 1 2 LABEL DIAMOND
       outputs to picture 2 the skiz associated with the labeled regions in
       picture 1 using the 4-connected, 'city block' metric
$
If the source picture is treated as a binary image (the default), a temporary,
labeled image is obtained from it in exactly the same way as the LABEL
command.  By default, the foreground regions are labelled.  You can use the
options FG and BG to control whether foreground and/or background regions are
labeled.  Note that foreground regions are treated as being 8-connected,
whilst background regions are 4-connected.

By specifying the LABEL option, you can suppress the labeling pass.  This
allows you to supply source images which have already been labeled, including
images generated by any of the classification commands (BOX, MINDISTANCE and
LIKELIHOOD).  Note that differently labeled region are allowed to touch each
other.

The skiz is the locus of points which are equidistant from the labeled regions
associated with the source image.  Because pixels occupy discrete positions in
the image plane, there will only be a few pixels which intersect the skiz
exactly.  In order to produce a connected representation of the skiz, all
pairs of 4-connected pixels which lie either side of the skiz are also
included in the output image.  This produces a result which is connected and
equally distributed about the true skiz.  However, the result will be one or
two pixels thick and its level of connectivity will vary.

An entirely 4-connected or 8-connected result can be obtained separately by
using the commands BMLUT and BMMAP, but the end result may be biased with
respect to the true skiz by up to one pixel.

For the 8-connected result use the following commands:

    BMLUT TO nnn IF P4 UNLESS C8=1 & N8~=1 & (~P1 & P7), +
                              C8=1 & N8~=1 & (~P7 & P1), +
                              C8=1 & N8~=1 & (~P3 & P5), +
                              C8=1 & N8~=1 & (~P5 & P3)
    BMMAP WITH nnn

where picture nnn contains the sequence of look-up tables that define the
necessary sequence of 3 by 3 neighbourhood transformations.

For the 8-connected result use the following commands:

    BMLUT TO nnn IF P4|(~P0&P1&P3)|(~P2&P1&P5)|(~P6&P3&P7)|(~P8&P5&P7), +
                    P4,                                                 +
                    P4,                                                 +
                    P4,                                                 +
                    P4                                                  +
             UNLESS 0,                                                  +
                    C4=1&N4~=1&(~P1&P7),                                +
                    C4=1&N4~=1&(~P7&P1),                                +
                    C4=1&N4~=1&(~P3&P5),                                +
                    C4=1&N4~=1&(~P5&P3)
    BMMAP WITH nnn

Here the first transformation is a diagonal fill which makes any 8-connected
components of the skiz 4-connected.  The remaining transformations specify a
4-connected thinning transformation.

Distances between pixels are calculated using one of several possible metrics.
By default, the exact Euclidean metric is used.  A simpler metric requiring
less computation, can be selected with one of the options DIAMOND, SQUARE or
OCTAGON.  For more details about the different metrics and distance
transforms, consult the documentation for the DT command.

See also: skiz.syntax, box, mindistance, likelihood, bmlut, bmmap
$add skiz.syntax
Keys:
  [FROM]         source picture [SELECT]
  [TO]           destination picture [FROM]

Options:
  BINARY | LABEL treat source picture as binary/labeled image [BINARY]
  FG             if BINARY, label foreground regions [YES]
  BG             if BINARY, label background regions [NO]
  CIRCLE | DIAMOND | SQUARE | OCTAGON
                 use Euclidean/4-connected/8-connected/octagonal metric for
                 measuring distances [CIRCLE]

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add solid.command solid shadedimage 3dimage perspective
You can use SOLID to generate a shaded image of a 3-D solid object defined by
thresholding a density distribution tabulated in a multi-layer (3-D) picture;
options allow you to vary the viewing orientation, output size, etc.

Exx: GAUSSIAN 1 SIZE 40,40,40; MIN=0 MAX=255; SOLID THRESHOLD .02
       generates shaded image on DISPLAY of sphere truncated at edges of cube
     SOLID 1 TO 5 THETA PI/3 PSI -PI/6 THRESHOLD .03
       generates in 5 image of object differently oriented (rotated 60 degrees
       clockwise in-plane, then tilted 30 degrees top towards you)
     SOLID SIZE 300,200 TIMES 3
       generates image magnified three times, in output with given size
     SOLID 1 WITH 37
       generates image of object with independent thresholds for each layer,
       as given in pixels of 1-D picture 37

Note that output goes to DISPLAY in default.
$
SOLID is necessarily a rather complicated command, except that most of the
keys/options can be allowed to default for most purposes; details of the
illumination and surface reflectivity model are given separately (HELP
ILLUMINATION), in case you want to vary these.

The 3-D object presented (keys THRESHOLD and WITH): the object portrayed is
formed by thresholding the source pixels, which are treated as continuous
density samples; points as dense as the threshold are treated as part of the
object, and less dense points as empty space.  If you wish, you can give
different thresholds for each layer, by suppling the thresholds in a 1-D
picture whose pixels (from left to right) are the threshold levels to be
applied to the various layers (from back to front); this is useful, for
example, in viewing the 3-D reconstruction of a 2-D crystal.

The orientation (keys THETA and PSI): standard Semper display facilities
present you with X-Y layers, as if you were looking down on to the object
(along the -Z axis).  Starting from this orientation, SOLID presents the 3-D
object after it has been rotated first clockwise by the key THETA as you view
it, and then by the key PSI anticlockwise about the +X axis (i.e. top away
from you).  The defaults (THETA=PI/4, PSI=PI/4) present the object turned to
the right and then tilted away from you.

The output picture (keys TIMES, SIZE, POSITION, VALUE): you can increase or
decrease the size of the view generated via the key TIMES, which takes
fractional as well as well as integral values, e.g. SHEET..TIMES .75 or
SHEET..TIMES 1.5.  In default, the output is made large enough to accommodate
the 3-D box enclosing the solid, in the orientation you select.  If you want
to force the size (e.g. to stop the size changing with the orientation, you
can use the key SIZE to specify it, and the shaded image is simply truncated
if necessary.  By default, the centre of view is positioned at the centre of
the output picture.  You can reposition the view centre by specifying an
offset with the POSITION key.  If the view centre lies within the limits of
the output picture, the output picture's origin is set to the view centre,
otherwise it defaults to the centre of the output picture.  Default values for
the illumination keys ensure that the output pixel values lie in the range
0-255 allowed for byte pictures, and Byte is accordingly the default output
form. The solid is normally presented on a background of zero (dark) pixels,
but you can control this via the key VALUE if you want to.

See also: solid.syntax
$add solid.syntax
Keys:
  [FROM]         source picture [SELECT]
  [TO]           output picture [DISPLAY]
  THRESHOLD | WITH   single threshold level applicable to all layers, or 1-D
                 picture containing independent thresholds for each layer in
                 turn [single threshold value 0]
  THETA          first rotation applied to object before viewing; anti-
                 clockwise about +Z axis (clockwise as you view) [PI/4]
  PSI            second rotation applied to object before viewing; anti-
                 clockwise about +X axis (top inwards as you view) [PI/4]
  SIZE(2)        output picture dimensions [depend on source picture size,
                 height range, and viewing orientation]
  POSITION(2)    view centre position in output picture [0,0]
  TIMES          (not nec integral) magnification factor for output [1]
  VALUE          background value for use outside view of solid [0]
  LTHETA         angle between main light source direction and +Z axis, in
                 radians [PI/4]
  LPHI           azimuth of main light source direction, anti-clockwise from
                 +X axis, in radians [0]
  MAIN           brightness of main illumination source [154]
  FORWARD        brightness of subsidiary (forward) illumination [42]
  AMBIENT        brightness of non-directional ambient illumination [40]
  DCONTRAST      depth contrast - brightness difference between front and
                 rear of object [30]
  SDR            specular to diffuse ratio - how polished the surface is;
                 0 upwards [.4]

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add spawn.command spawn
Spawn is not available on this system
$add spc.command spc
You use SPC to mark intensity contours in a picture, or to superpose the
contours of one picture on another, with some flexibility as to the contour
heights marked and the intensity of the contour lines.  SPC marks contours by
resetting pixels; if you want it drawn in a display overlay instead, use the
CONTOUR command.

Exx: DISPLAY; SPC DISPLAY LEVELS 9
       displays the current picture and superposes 9 contours on it, bright
       where the picture is dark and vice versa
     SPC TO DISPLAY VALUE MIN
       displays the current picture, with 5 contours, all dark, covering the
       range MIN,MAX
     SPC LN RANGE 1,6
       marks 7 contours in picture 50, covering the range ln(1) to ln(64)
       (i.e. contours at values 2,4,8,16 and 32)
     L=32.4,38.7,41.3,44.6,59.3,61; SPC 50 LEVELS 6 LIST TO DISPLAY WITH 51
       displays picture 50, with contours of picture 51 superposed at the six
       heights listed
$
In default, contours are marked by setting pixels to whichever range limit is
further (so that contours are bright where the picture is dark and vice
versa); you can force any particular value instead with the VALUE key.

The contour heights can be specified in several ways.  Normally, LEVELS
contours are drawn (5 in default) covering the RANGE indicated (MIN,MAX in
default), and evenly spaced (not including the extreme values - e.g. LEVELS 3
RANGE 1,5 generates contours at heights 2,3 and 4).  If LN is set, the contour
heights are spaced with a constant ratio rather than difference (effectively
contouring the picture logarithm instead).  This requires an entirely positive
intensity range.  Finally, if LIST is set, an arbitrary set of heights are
taken from variables L,L2,L3.. as in the last example.  The heights marked are
listed on the console if you specifiy the VERIFY option.

You can superpose the contours of one picture on another by setting WITH to
the number of the picture you want to contour, as in the last example.

The algorithm used is fast, and largely independent of the number of contours
you request.  Contours are marked by resetting the outermost pixels
horizontally and vertically of any region as high as, or higher than, each
contour height.
                                              Multi-layer pictures: faulted
                                             Forms used internally: fp,complex

See also: spc.syntax, contour
$add spc.syntax
Keys:
  [FROM]         source picture [SELECT]
  [TO]           output picture [FROM]
  WITH           picture whose intensity contours are marked on source [FROM]
  LEVELS         number of contours to mark [5]
  RANGE(2)       minimum,maximum values between which contours are spread
                 [MIN,MAX]
  VALUE          value used for marking contours [further of minimum,maximum
                 value from each individual contour height]

Options:
  LN | LIST      if LN set, mark contours with equal ratio between heights
                 if LIST set, mark contours with heights given by L(9)
                 [mark contours with equal increment between heights]
  VERIFY         list on the console the contour heights marked

Variables used:
  L(9)           if LIST set, contour height values

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add ssheet.command ssheet 3D viewer shaded surface emmission model wireframe
The command SSHEET interprets the source picture intensity values as Z
(height) information and displays the resulting surface in a separate window
in one of five ways: wireframe, smooth shaded surface, emission or colour
contoured surface and colour mapped surface. A control panel is displayed in a
second window, allowing you to modify the viewing parameters, data sampling
interval and rendering mode and to save/restore all these settings. You may
also save the displayed view as a Semper picture. Separate control panels can
be selected to control the lighting conditions and set the X and Y clipping
limits and front and back sectioning planes.

Exx: SSHEET 2:1
       displays the surface described by the intensity values in picture 2:1

     SSHEET FROM 4 TO 5
       displays picture 4 as a 3D surface and allows you to save the displayed
       image in picture 5, 6, 7 etc.

     SSHEET 9 WITH 10 COLOUR 2 EMISSION 5 MAP 6
       displays picture 9, using picture 10 to define the surface colour and
       separate look-up tables 2, 5 and 6 for each of the emission contour,
       colour contour and colour map rendering modes

     SSHEET 34 VFROM 999 VTO 998
       displays picture 34 according to the viewing parameters saved in
       picture 999.  The viewing parameters on exit from SSHEET are saved
       in picture 998

Interactive controls are presented to you in separate windows to allow you to
modify the appearance of the displayed surface.  All of these controls are
driven by the workstation's mouse.
$
When you invoke SSHEET, Semper copies the source data (4 bytes/pixel for
surface height and 3 bytes/pixel for surface colour) into an array in virtual
memory.  For large images (1K by 1K or larger), this will take some time (more
than 1 minute).  There will also be a time penalty when rendering the image,
if the available amount of physical memory is considerably less than the
source data, causing the data to be continually paged from disc.

How to use the mouse
--------------------
All of the normal window controls may be accessed with the mouse.  You may
reposition any of the control panels but not resize them.  The display window
may be repositioned and also resized at any time.  Selecting the 'Quit' option
in a window's pop-up menu will cause the SSHEET command to be abandoned.  The
normal way to exit the SSHEET command is to select the "QUIT" option on the
main control panel.

When the cursor lies within the display window, or any of the control panels,
you can press the right mouse button to cause the image to be redisplayed.
Pressing the middle mouse button will cancel any redisplaying of the image.

When the cursor is positioned inside any of the control panels, you can adjust
sliders or select menu options by pointing to the relevant item with the
cursor and then pressing the left mouse button.

To move a slider, you place the cursor on or near the slider's pointer and
press the left mouse button.  As long as you hold down the left mouse button,
the pointer will track any movement of the mouse.  There are three types of
sliders: circular sliders for setting angular values, linear sliders and
logarithmic sliders.  Only the field-of-view and vertical scaling parameters
are controled by logarithmic sliders.

When you select a menu option, the option is highlighted in red.  Only when
you release the left mouse button does the menu option take effect.  This
means that you can slide the cursor up and down the menu, over different
options, until you are satified with the selection.  If you move the cursor
right out of the menu box, the menu is restored to its original state, giving
you the option to cancel the selection of any menu option.

When the image is being redisplayed and the single redraw mode is selected,
the appearance of the cursor changes to an hourglass.  This is not the case
when the continuous redraw mode is in effect in order to avoid rapid switching
between the hourglass cursor and the default arrow cursor.

Display window
--------------
The display window is the second window to appear after invoking the SSHEET
command.  You will have to position and size it so that it does not obscure
the control panel and any other windows you may also wish to see.  The display
window can be resized and repositioned at any time.

The display window is the window in which the surface is displayed.  With the
default field-of-view of 45 degrees, the image will occupy the middle third of
the window and it should not exceed the limits of the window, even with
extreme settings for the vertical scaling and view direction.  Decreasing the
field-of-view zooms the view in towards the surface.  Any part of the surface
that extends beyond the window limits will be clipped.

The title of the source picture defining the surface height will appear in the
display window's title bar.

Main Control Panel
------------------
The main control panel is displayed in the first window that appears after you
invoke the SSHEET command.  It occupies most of the width of the screen and
consequently you should position it at the top or the bottom of the screen.
All of the more commonly used viewing controls are to be found on this control
panel.  Further controls can be displayed by selecting the "Lighting" or
"Clipping" options.

SSHEET scales the Z information so that the larger of the X and Y dimensions
of the source picture is four times the Z range, when the surface is viewed
with unit vertical scaling. The vertical scaling factor may be varied from
0.01 to 10.0.

The view is positioned with respect to the surface by means of a 3-D cursor.
This is a cross-hair that displays the view centre position in X, Y and Z. The
slider values for X and Y are displayed in terms of the source picture
coordinates and the Z value in terms of the source data range.  Where the
cursor is obscured by the displayed surface, it will appear dotted.  When the
surface is redisplayed, the view centre position will appear at the centre of
the display window.  The 3-D cursor may be turned on or off.

Circular sliders allow you to set the azimuth and elevation for the viewing
direction.  The surface is displayed so that the Z axis is projected in the
positive screen Y direction.  The azimuth is the anti-clockwise angle between
the positive X axis and the projection of the viewing direction on the X-Y
plane.  The elevation is the angle between the viewing direction and the X-Y
plane.

The surface can be rendered in one of five ways, which you select by means of
the "Rendering mode" menu panel:

  (1)  Wireframe         - a grid is drawn joining all adjacent vertices in
                           the X and Y directions

  (2)  Smooth Shading    - a smoothly shaded surface is displayed, subject to
                           the current lighting conditions

  (3)  Emission contour  - the surface is displayed so that it appears to emit
                           light whose colour varies according to the height
                           of the surface (surface contouring or banding)

  (4)  Colour contour    - the surface is displayed so that the surface colour
                           varies with height, subject to the current lighting
                           conditions

  (5)  Colour map        - the surface is displayed with the surface colour
                           defined by a separate source image, subject to the
                           current lighting conditions

Note that the "Colour map" option will appear in the "Rendering mode" menu
only if the WITH key is specified in the SSHEET command.  The picture
specified by means of the WITH key may define a false-colour image (single
layer picture) or a full-colour image (3 layer picture).  The X and Y
dimensions of this picture must match those of the source picture that defines
the surface height.

The EMISSION, COLOUR and MAP keys allow you to select look-up tables to define
or map the colours used in each of the last three rendering modes.  The
default is to use the current look-up table for the colour contour mode and to
use linear grey-scales for the emission contour and colour map modes.

For the emission and colour contour modes, each look-up table entry defines
the colour of a single contour band.  The total assemblage of bands spans the
entire Z range of the surface. When a series of look-up table entries are the
same, they will be merged into a single colour band.

The time taken to render the surface with colour banding varies in direct
proportion to the number of bands. The band coarseness control allows you to
set an interval for sampling the look-up table data so that the number of
bands is reduced. The default band coarseness results in a maximum of 16
bands.

You can also control the source data sampling interval.  The coarser the
interval, the faster the surface is redisplayed.  The wireframe mode is the
fastest mode, followed by smooth shading and then the colour/emission contour
modes or the colour map mode, depending on the band coarseness.  The default
model coarseness setting results in a maximum of 32 sampling points in the X
direction.

With the default sampling interval, the wireframe mode is fast enough to allow
continuous adjustments to the viewing parameters to be displayed.  Note that
when the "Continuous" redraw mode is selected, the display is double buffered.
In "Single" redraw mode the old image is first erased and you may then observe
the new image being redrawn.

You can redisplay just a part of the surface by switching on "Clipping".  Any
facets that lie entirely outside the clipping limits are skipped over.  The
clipping limits themselves are set by means of a separate control panel which
you select with the "Clipping" option.  Reducing the clipping limits decreases
the amount of time to redisplay the surface.  This allows you to view small
parts of extremely large surfaces in a reasonable time.  This is particularly
useful when much of the surface falls outside the display window.

The surface is displayed with all hidden surfaces removed by making use of the
workstation's hardware Z-buffer.  The 3-D nature of the displayed image can be
further enhanced by having the border surface also drawn ("Border" menu).
This adds a 'plinth' underneath the surface, extending down as far as the
minimum Z-extent of the surface.  The effect obtained is as if the surface was
'sculpted' out of a solid block of material.

The normal way to cause the image to be redisplayed after making changes to
the viewing parameters, is to press the right mouse button. However, if you
select the "Continuous" redrawing mode, the image will be redisplayed every
time any of the viewing parameters change. Irrespective of the current redraw
mode, changing the rendering mode and the redraw mode and switching clipping
and the border on/off will also cause the image to be redisplayed. So too will
any rearrangement of the windows on the screen which causes any part of the
display window to be exposed.

If the TO key is specified, the "Save Image" menu option will appear on the
control panel.  This allows you to save the currently displayed image into the
specified Semper picture.  The picture will contain three layers of byte data
representing the red, green and blue intensities of the displayed image.  You
can save the image as often as you like.  Each time, the output picture number
is incremented (up to the maximum of 999).  In this way you can save a whole
sequence of views (perhaps an animation sequence).

A buffer is provided, into which all the current viewing parameters can be
saved and then restored later on.  If you use the key VFROM, the buffer is
initialised to the values contained in the specified Semper picture.
Otherwise, the following default values are used:

     Azimuth                   315 degrees
     Elevation                 45 degrees
     Field of view             45 degrees
     Cursor position           Centre of X, Y and Z range
     Vertical scaling factor   1.0
     Model coarseness          ( source picture row length ) / 32
     Contour band coarseness   ( display look-up table length ) / 16
     Rendering mode            Wireframe
     Redraw mode               Single
     Cursor on/off             On
     Border on/off             Off
     Clipping on/off           On
     Clipping limits           limit of X and Y range
     Autocentring on/off       Off
     Front section plane       100 %
     Back section plane        -100 %
     Ambient lighting          10 %
     Light source azimuth      0 degrees
     Light source elevation    90 degrees
     Light source colour       white (on), black (off), black (off)

The contents of the buffer are used to set the viewing parameters when you
invoke the SSHEET command and whenever you select the "Restore view" menu
option.  If you specify the VTO key, the contents of the buffer are copied
into the specified Semper picture when you quit from SSHEET.

Lighting Control Panel
----------------------
All the controls to set the lighting parameters have been collected together
onto a separate control panel which will be displayed when you select the
"Lighting" menu option on the main control panel.  You may position the
lighting control panel anywhere you like on the screen.  When you have
finished adjusting the lighting parameters, you can cause the control panel to
disappear by selecting the "HIDE WINDOW" menu option.

For the smooth shaded, colour contour and colour map rendering modes, the
current lighting parameters take effect.  They also affect the appearance of
the border surface.  These consist of ambient lighting and three separate
point light sources.  You can control the colour and orientation of each light
source.  Setting to zero the red, green and blue intensities for a light
source turns off that light source.  There is a small time overhead for each
light source when rendering the surface.  The default lighting consists of 10%
red, green and blue ambient light and one white light source positioned
directly above the surface.  Note that the orientation of the light sources is
specified in the same way as the view direction, with respect to the source
picture axes.

Clipping Control Panel
----------------------
Controls to set the clipping limits and the front and back sectioning planes
are to be found on a separate control panel which will be displayed when you
select the "Clipping" menu option on the main control panel.  You may position
the Clipping control panel anywhere you like on the screen.  When you have
finished adjusting the clipping parameters, you can cause the control panel to
disappear by selecting the "HIDE WINDOW" menu option.

The clippping limits determine which surface facets are displayed.  Any facet
that falls entirely outside the X or Y clipping limits is skipped over.  You
can use the clipping facility to expose parts of a surface that would not
otherwise be visible.  You can also greatly speed up the display of small
parts of large surfaces, by discarding all parts of the surface oustside the
particular area of interest.

The "Centre view" menu option causes the X and Y positions for the view centre
to be set mid-way between the X and Y clipping limits.  This is useful when
the clipping limits get too far away from the view centre position so that the
part of the surface that is not clipped starts to disappear off the edge of
the display window.  Turning on the "Autocentring" facilty causes the view
centre position to be centred on the clipping limits whenever the clipping
limits are adjusted.

The front and back section planes allow you to set clipping planes
perpendicular to the view direction.  The position of the sectioning plane is
arranged so that zero intersects the view centre position and the extreme
values are guaranteed to lie in front of and behind the surface.

The clipping limits are not allowed to cross over.  For example, if the
minimum X limit is moved to the right of the maximum X limit, the pointer for
the maximum X slider will also move to maintain the correct relationship with
the minimum X slider.  The same interlocking mechanism applies to the Y
clipping limits and to the front and back clipping planes.

See also: ssheet.syntax sheet
$add ssheet.syntax
Keys:
  [FROM]         source picture number [SELECT]
  TO             start picture number for saving displayed image [none]
  WITH           picture containing image that specifies surface colour in the
                 colour map rendering mode [none]
  EMISSION       display look-up table number defining the colours to be used
                 in the emission contour mode [linear grey-scale]
  COLOUR         display look-up table number defining the colours to be used
                 in the colour contour mode [CLUT]
  MAP            display look-up table number for mapping the colours to be
                 used in the colour map mode [linear grey-scale]
  VFROM          picture containing initial view parameter settings [none]
  VTO            picture for saving viewing parameters [none]

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add stack.command stack layers
You use STACK to  combine layers from several 2-D or multi-layer pictures as a
single multi-layer picture.

Exx: STACK 1,9 TO 11
       stacks all the layers of pictures 1 to 9 as picture 11
     STACK 1,9 TO 11 LAYERS 2,3
       stacks layers 2 and 3 of pictures 1 to 9 as picture 11

A new multi-layer output picture is created each time you use the STACK
command.  If you want to replace several layers in an existing multi-layer
picture, you must either use PASTE repeatedly as necessary, or STACK to an
intermediate picture in the first instance and PASTE this into the final
output.
$
All the source pictures must have layers of the same size (the same X and Y
dimensions).

                                                    Forms used internally: all

See also: stack.syntax, paste
$add stack.syntax
Keys:
  [FROM(2)]      first,last picture in range to be stacked [SELECT,SELECT]
  [TO]           multi-layer output picture [FROM]
  LAYERS(2)      range of layers to take from each source picture [all layers]

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add stop.command stop terminate finish
You finish a Semper session by typing STOP (or QUIT, or EXIT).

All devices still assigned are deassigned (or deleted in the case of scratch
devices) to ensure data is correct on media before the session completes.
$add quit.command quit terminate finish
You finish a Semper session by typing QUIT (or STOP, or EXIT).

All devices still assigned are deassigned (or deleted in the case of scratch
devices) to ensure data is correct on media before the session completes.
$add exit.command exit terminate finish
You finish a Semper session by typing EXIT (or QUIT, or STOP).

All devices still assigned are deassigned (or deleted in the case of scratch
devices) to ensure data is correct on media before the session completes.
$add return.command return
You leave RUN and LIBRARY programs with a RETURN command, END command or if
there are no further lines in the program.
$add end.command end
You leave RUN and LIBRARY programs with a END command, RETURN command or if
there are no further lines in the program.

The END command is normally placed at the end of the LIBRARY and RUN files to
mark their last line; if you use it as a command interactively, it means
the same as STOP, and ends the Semper session.
$add strain.command strain
You use STRAIN to deduce local strain levels for distorted crystals from a
list of unit cell positions, and re-sort the list into ascending strain order
(for example, to allow averaging the least strained positions only).

Exx: U=10,0 V=0,10 W=0,0; STRAIN 50 to 91
       refines the lattice parameters U,V,W so as to fit the  positions listed
       in picture 50, and outputs a revised list of positions, sorted in order
       of increasing strain level, to 91
     STRAIN 999 TOLERANCE .1
       re-sorts picture 999 by local strain level, excluding any positions
       whose fractional deviation from the nearest lattice site exceeds 0.2

The initial stages of processing (the lattice fitting) is exactly as for the
BASE command, though with fewer options, so STRAIN is used in much the same
way.
$
In an extra pass peculiar to STRAIN, a local strain measure (the r.m.s.
fractional displacement difference between the position itself and each of
its neighbours) is evaluated for each position having at least two neighbours
(defined as other listed positions for which the lattice coordinates differ
from those at the first by values within TOLERANCE of unity).  The strain
values are stored in the list instead of the original height or mass values,
if these are present, and the list is resorted (omitting positions for which
the strain cannot be estimated).  You can then use MOTIF to make averages on
the basis of selected strain levels only.

See also: strain.syntax, base, motif
$add strain.syntax
Keys:
  [FROM]         source Plist picture [SELECT]
  [TO]           output Plist picture [FROM]
  TOLERANCE      fractional deviation from initial estimated lattice sites
                 beyond which sites are excluded from fit [0.3]
  MARK           display to be marked with deviations from lattice positions
                 [none]
  TIMES          magnification of display markings [5]

Options:
  VERIFY         list on the console the details of the fitting process

Variables used:
  U(2),V(2)      initial estimates for lattice base vectors
  W(2)           initial estimate for lattice origin

Variables set:
  U(2),V(2)      base vectors of fitted lattice
  W(2)           origin of fitted lattice
  N              number of sites included in fit
  R              r.m.s deviation between included sites and final (fitted)
                 lattice (in source pixels)

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add survey.command survey min max mean sd
You use SURVEY to scan pictures or picture subregions, to determine the range
of pixel values and the mean and standard deviation.  For Histogram pictures,
SURVEY also determines the median and mode.

Exx: SURVEY 19
       types the data range of picture 19 on the console and sets MIN and MAX
     SURVEY LAYER 3 NOVERIFY
       sets MIN,MAX to the data range within layer 3 of the current picture
     SURVEY FULL SIZE 100 BOTTOM LEFT
       types the range, mean and standard deviation of the bottom left 100
       square of the current picture, setting MIN,MAX,MEAN,(ME2) and SD
$
You indicate the region you want surveyed via the standard subregion keys.
Normally, the range only is determined.  Where possible, it is recovered from
the picture label.

SURVEY FULL ignores the picture label (providing a recovery route in case of
difficulty), and determines the mean (complex if the picture is complex) and
standard deviation too.

If the source is a histogram, SURVEY sets MIN,MAX to the range represented by
the histogram channels, not the minimum,maximum channel counts; it also sets
MEAN(,ME2), SD, MEDIAN and MODE to values estimated from the histogram.  Any
subregion you request is ignored.

SURVEY returns estimated values if you abandon while it is scanning data.

                                      Multi-layer pictures: fully supported
                                     Forms used internally: integer,fp,complex

See also: survey.syntax
$add survey.syntax
Keys:
  [FROM]         picture to be surveyed [SELECT]
  SIZE(3)        dimensions of subregion to be surveyed [whole picture]
  POSITION(3)    position/offset of subregion [0,0,0]
  LAYER(2)       range of layers in subregion [all unless SIZE and POSITION
                 define 3-D subregion]

Options:
  FULL           rescan source picture/subregion for range, mean and standard
                 deviation (if Histogram source, median and mode also) [NO]
  LEFT | RIGHT
  BOTTOM | TOP   survey sub-region abutting indicated border
  NEAR | FAR
  VERIFY         list on the console the values found [YES]

Variables set:
  MIN,MAX        minimum and maximum value found
  MEAN(2),SD     if FULL, (complex) mean and standard deviation found
  MEDIAN,MODE    if FULL and Histogram source, median and mode found

See SUBREGIONS for more details of subregion keys/options.

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add syntax.command syntax command verbdescriptor
You use SYNTAX to obtain a short summary of the syntax for a processing
command as recorded in Semper's own internal data structures.  This is the
definitive command definition that is used by Semper to activate it, and is
always available, even when no help libraries are assigned.

Exx: SYNTAX SURVEY
       gives the details of the command SURVEY.

The output of SYNTAX lists the options, keys and implicit picture opens if any
are defined for the specified command.  There are also a few commands like
HELP, ASK and UNSET that have their own special syntax which the SYNTAX
command will not be able to list.  Note that the control commands IF and
UNLESS are not table-defined and SYNTAX does not recognise them.
$
All options and keys are only given to three characters - the internal
length used by Semper to decode the command line.

Keys are shown either as just the key name, or as 'key=val', where 'val' is
the default value given to the key if the key is not present in the command
line.

The special keys $1,$2,$12,$13 etc. are used to read values from the command
line quoted without any prefixed key name.  This mechanism is used by many
commands.  For instance, DISPLAY has included in its key list the items:

    $1=sel from=$1 $2=dis to=$2

This means that the first value found without a keyword is assigned to the
key $1, and hence to the key FROM, and the second value to the key $2, and
hence to the key TO.  Note that the default values for these keys are
SEL(ECT) for $1 and DIS(PLAY) for $2, meaning that the action of the command
DISPLAY when no keys are present is to display the currently selected picture
to the currently selected display.  In some cases no default values appears;
this means that the command interpreter itself provides no default for the
key - either because no useful default exists, or because the default cannot
be simply expressed; in the latter case, the -.SYNTAX entry for the command
explains the default action taken by the processing module.

Picture opens refer to pictures that the command interpreter opens for the
command before processing commences.  The most common item seen here is:

    (lp1,old)=fro

this means that the picture FRO(M) is opened in 'old' mode as logical picture
number 1, and must therefore already exist.  The other form seen is:

    (lp2,new,lp1)=to

this means that a new picture, number TO, with the default characteristics of
logical picture 1 is opened as logical picture 2.  See the Fortran
Programmers' Guide for more information on logical picture numbers.
$add textfield.command textfield
The command TEXTFIELD controls the creation and operation of  the
Semper 6 Plus Textfield element.

Examples:
     TEXTFIELD CREATE NAME 'Commands' LENGTH 10
     creates a new textfield with the name 'Commands' on the
     current panel, with space for a maximum of 10 characters
     in it. The default values for positioning are used.

     TEXTFIELD ASSIGN 'CON'
     assigns the contents of textfield with id ENO to variable
     CON. Note that the variable name must be quoted, otherwise
     it will be evaluated! Also, the contents of the textfield
     must be a valid expression otherwise Semper 6 Plus will
     report an error.
$
Textfields are similar objects to cells but, unlike cells, cannot
be placed on a menu. They are different to cells in that text may
typed into them from the keyboard. Textfields are extremely
powerful elements as their contents may executed as Semper 6 Plus
commands. Textfields may, to some extent, be thought of as
'string' variables.

There is the concept of a 'current textfield' in Semper 6 Plus.
The currently selected textfield accepts input that is typed from
the keyboard. A textfield is selected when:

     *    It is first created;  the latest textfield to be
          created is selected by default.
     *    It is explicitly selected by use of ACTIVATE.
     *    It is hit using the mouse.

Various 'string' keys are available for textfields: PRIOR,
CONTENTS and APPEND. The PRIOR (text) key inserts the supplied
text at the beginning of the textfield contents. The APPEND key
provides the complementary function, allowing text to be added at
the end of the textfield. The CONTENTS key replaces the current
contents of the textfield with those supplied by the key. Care
should be taken, when using any of these keys, that the
textfield is long enough. The CLEAR option removes the contents
of the identified textfield.

The LENGTH key defines how many characters may be put into the
textfield. Unlike other Semper commands the textfield command
will NOT complain if an attempt is made to put too many
characters into a textfield: it merely truncates the string to
the number that fit in. Provided that the textfield is not
showing, the length may be altered as required. An interesting
point is that if the panel containing the textfield is never
shown the textfield may be 'any' length, limited by the amount of
text space (See the UIF help entry for details of text space).
If a textfield is shortened, then up to the first <newlength>
characters are saved.

The ASSIGN key causes the contents of the textfield to be
evaluated as a numeric expression and the result to be stored in
the named Semper variable. The name of the variable must be given
in quotes.

The TAB key defines a second textfield, which is to be ACTIVATEd
if the TAB key is pressed while this first textfield is selected.

The EXECUTE option causes the contents of the textfield to be
executed as if they were entered at the keyboard. This is,
effectively, AS IF THE COMMANDS WERE TYPED AT THE KEYBOARD. It is
important to remember this point especially when using library
programs. For example, consider the following fragment of library
code:

     TEXTFIELD ID TX CONTENTS 'DISPLAY 1' EXECUTE
     DISPLAY 2
     RETURN
     END

After executing the textfield command, Semper 6 Plus would
execute the 'DISPLAY 2' command, not the 'DISPLAY 1' command
which was in the textfield. Consider what would happen if you
typed 'DISPLAY 1' while executing a library program: picture 1
would not be displayed until the library program ended. It is
very easy to forget this point. In order to have the command
executed immediately (as if the textfield command was a library
command executing the textfield contents) the option IMMEDIATELY
should be given. e.g. if the above command sequence was:

     TEXTFIELD ID TX CONTENTS 'DISPLAY 1' EXECUTE IMMEDIATELY
     DISPLAY 2
     RETURN
     END

then picture 1 WOULD be displayed before picture 2.

See also: textfield.syntax, element.syntax, uif.element
$add textfield.syntax
Keys:
  APPEND text    Appends the given string to the contents of the requested
                 textfield.
  ASSIGN text    Assigns the contents of requested textfield to the variable
                 given.  The textfield need not be of numeric type, but the
                 contents must be a valid numeric expression.
  BACKGROUND     Specifies the background colour to be used for the textfield.
  BEGINS text    The given string is set as the 'interaction begins' action
                 for the textfield.
  CHANGES text   The given string is set as the 'state change' action for
                 the textfield.
  CONTENTS text  Replaces the contents of the requested textfield with the
                 given string.
  ENDS text      The given string is set as the 'interaction ends' action
                 for the textfield.
  FOREGROUND     Specifies the foreground colour to be used for the textfield.
  ID             Defines the textfield to use [ENO].
  IN             Defines the panel in which the textfield is to appear.  Does
                 not reset the value of variable PNO [PNO].
  LENGTH         Defines the maximum number of characters that the textfield
                 may contain.  If this key is not given when the textfield
                 is created, the length defaults to five characters.
  NAME text      Defines a name for the textfield.
  POSITION(2)    Defines the position of the currently set location point
                 of the textfield in the requested panel.  Using POSITION once
                 a textfield has been created moves the textfield.
  PRIOR text     Prepends the given string to the contents of the requested
                 textfield.
  SIZE(2)        Defines a minimum X and Y size for the textfield.  If the
                 textfield requires to be larger than the size specified, the
                 size given here will be overridden.
  TAB            Sets the given textfield to be the 'tab target' of the
                 current textfield.
  VALUE          Replaces the contents of the requested textfield with the
                 value of the given numeric expression.

Options:
  CLEAR          Clears the contents of the requested textfield.
  CREATE         Creates a textfield.  This is the first option that is
                 checked for when the command looks at its arguments.
  DESTROY        Destroys a textfield.
  EXECUTE        Executes the contents of the requested textfield.
  IMMEDIATELY    Causes immediate execution when used with the EXECUTE option.
  ACTIVATE       Causes the textfield to become selected for input (i.e. to
                 be the textfield into which typed input is entered).  The
                 currently selected textfield is automatically deselected.
  WP             Makes the textfield write-protected.  A write-protected
                 textfield may still be selected but it is not possible to
                 type anything into it from the keyboard.
  OFF            Turn off textfield write-protection; this option must be used
                 in conjunction with the WP option.

Variables set:
  ENO            Set by the CREATE option to the identifier of the textfield.

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add threshold.command thresholding intensity bands
You use THRESHOLD to produce a binary image according to one or more intensity
thresholds.  If no threshold values are specified, the mid-range intensity
value for the source picture is used as a lower limit for thresholding.

Exx: THRESHOLD
       converts the current picture into a binary image where non-zero
       pixels represent source pixels with value greater than or equal
       to the mid-range value for the source picture
     THRESHOLD 2:3 2:4 GE I1 LE I2
       thresholds picture 2:3 for intensities in the range I1 to I2
     THRESHOLD 99 GE 70,50,50,10,90 LE 20,40,60,100,80
       thresholds picture 99 for intensity bands 10 to 20, 30 to 40,
       50 to 60, 70 to 80 and 90 to 100 (note how values have been sorted
       into the correct sequence)
     THRESHOLD LT -35 GT 35
       thresholds the current picture for all pixels with absolute value
       greater than 35
$
You use the multi-valued GE or GT key to specify lower threshold limits and
the LE or LT key to specify upper limits.  Up to 18 upper and lower limits may
be specified.  The limits are sorted into adjacent pairs and a check is made
to ensure that they are consistent with each other, e.g.

       GE 10,20 LT 30

would be faulted because the lower limit of 10 does not pair up with an upper
limit (or plus infinity).  On the other hand the limits

       GE 20 LT 10 LE 30

are valid, specifying intensity bands < 10 and 20 to 30.

See also: threshold.syntax, calculate
$add threshold.syntax
Keys:
  [FROM]         source picure [SELECT]
  [TO]           destination picture [FROM]
  GE(9)          lower threshold(s) (including threshold value) [mid-range]
  GT(9)          lower threshold(s) (excluding threshold value) [none]
  LE(9)          upper threshold(s) (including threshold value) [none]
  LT(9)          upper threshold(s) (excludong threshold value) [none]

Threshold values should be specified in adjacent pairs with the exception of a
single, isolated upper or lower limit.  The ordering of the GE/GT and LE/LT
keys on the command line does not matter as they are sorted into numerical
order before being checked for consisitency.

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add time.command time
You can use the command TIME to measure the actual (elapsed) time taken by
different Semper operations, the total duration of your session etc.  The
command types on the console the elapsed time in seconds and also sets the
variable T to the elapsed time.  If you simply want to know the time of day,
use the command SHOW TIME.

Exx: TIME
       reports the number of seconds since the start of your session, or
       since you last typed TIME RESET on the cosole and in variable T
     TIME RESET
       resets the elapsed time clock to zero

The precision of the result is of course installation-dependent; the time is
printed to the nearest centi-second.

See also: time.syntax
$add time.syntax
Options:
  RESET          reset the elapsed time clock to zero
  VERIFY         type result on the console [YES]

Variables set:
  T              elapsed time in seconds

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add title.command title
You can change the title of a picture, or add to it, with the TITLE command.

Exx: TITLE 51
     Text (as textstring): 'Difference between methods'
       records the new title given for picture 51
     TITLE ADD TEXT 'serial number ',NS
       adds the text given, including the value of variable NS, to the end
       of the title recorded for the current picture
     TITLE TEXT ''
       deletes any recorded title
     TITLE 51 FROM 50
       copies the title of picture 50 to that of picture 51

Semper prompts at the terminal for the title text if you omit TEXT, as in the
first example.

See also: title.syntax
$add title.syntax
Keys:
  []             picture whose title is set/changed [SELECT]
  TEXT text | FROM   textstring for title text, or picture whose title is to
                 be used [prompts for textstring if interactive, otherwise
                 faults command]

Option:
  ADD            add text to end of title, rather than replacing title

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add transpose.command transpose
You use TRANSPOSE to transpose pictures (reflect them about the diagonal from
top left to bottom right).  You could use the EXTRACT command to transpose a
picture, but TRANSPOSE is much quicker because it uses a fast multi-radix
transposition algorithm.

Exx: TRANSPOSE DIS:3
       transposes display picture 3
     TRANSPOSE 50 TO 51
       transposes picture 50 to picture 51
$
The position of the transposed origin is stored in the output picture.

The picture must be square, and its size must be one of the factorisable
sizes listed by the SHOW SIZES command.  You can transpose an unsuitably sized
picture by first extending it to a larger factorisable size, transposing it
and then cutting out the transpose of the original image.  For example, if the
current picture has dimensions 250 by 150, you could transpose it in the
following way:

     CUT SIZE 256 TOP LEFT
     TRANSPOSE
     CUT SIZE 150,250 TOP LEFT

The intermediate picture is 256 pixels square, which is a larger size that
TRANSPOSE can deal with.  The origin of the resulting picture will correspond
with the transposed source origin because CUT and TRANSPOSE each record the
position of the transformed origin.

                                              Multi-layer pictures: faulted
                                             Forms used internally: fp,complex

See also: transpose.syntax, extract, show, cut
$add transpose.syntax
Keys:
  [FROM]         source picture [SELECT]
  [TO]           output picture [FROM]

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add turn.command turn reflect
You use TURN for various simple picture reflections and rotations, as it is
much quicker at the jobs it can perform than EXTRACT.

Exx: TURN 1 TO 2     [or TURN 1 TO 2 ANTICLOCKWISE]
       rotates picture 1 90 degrees clockwise [or anticlockwise] to picture 2
     TURN 50 OVER
       reflects the x-axis of pic 50 (like turning the page of a book)
     TURN DISPLAY UPSIDEDOWN
       rotates the display picture by 180 degrees (turning it upsidedown)
     TURN OVER UPSIDEDOWN
       reflects the Y axis (turns over top to bottom rather than side to side)

For the 90 degree rotation modes, the source picture must be square, and its
size must be a power of two.  You can of course CUT other pictures, if
necessary, to a suitable (larger) size, TURN and then CUT again afterwards.
$
Rotations are about the picture centre rather than origin, so the source
picture origin is not always exactly preserved.

                                              Multi-layer pictures: faulted
                                             Forms used internally: fp,complex

See also: turn.syntax, extract
$add turn.syntax
Keys:
  [FROM]         source picture [SELECT]
  [TO]           output picture [FROM]

Options:
  ANTICLOCKWISE  turn 90 degrees anticlockwise rather than clockwise
  UPSIDEDOWN     turn 180 degrees
  OVER           reflect X axis (interchanging left and right sides)

Used together, OVER and UPSIDEDOWN reflect the Y axis instead.  OVER and
ANTICLOCKWISE used together transpose the image about a line at 135 degrees
from the +X axis.  The ANTICLOCKWISE option is ignored if used with UPSIDEDOWN
or with OVER and UPSIDEDOWN combined.

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add type.command type values print report messages console output stream
You can make Semper type messages and/or numerical values with the TYPE
command.  It accepts a comma separated list of numerical values and literal
text strings.  Numerical values can be specified in the form of constants,
variables or general numerical expressions.  Text stings must be enclosed in
single quotes.  Output from the TYPE command goes to the console output
stream.

Exx: TYPE min,max
     TYPE '350 degrees is ',350*pi/180,' radians'

The items following the word TYPE itself in fact comprise a textstring in the
general format described under TEXT.

See also: log, diagnostic, textstring
$add uif.command uif
The command  UIF controls the loading, saving  and  execution  of
user interfaces.

Examples:
     UIF ENABLE; UIF READ 'normal.uif'
     reads   in   a  pre-defined  user   interface   stored    in
     the   file 'normal.uif'.

     UIF GO
     starts the currently defined interface running.
$
The  UIF  command must be executed  with the ENABLE option before
any other user interface related commands can  be  issued.   This
sets up various internal variables relating to the user interface
system.

When  the UIF GO command is issued, Semper 6 Plus calculates  the
maximum  extent of the panels which are visible (i.e. SHOWn).  It
then limits the rest of Semper to outputting in the remainder  of
the host display.

The   EXIT  option  returns  control  to  the   standard   Semper
environment  - to return to the user interface, UIF GO should  be
issued. This is useful during program development and debugging.

The  STOP option is similar to the EXIT option in that  the  user
interface is exited. The difference is that STOP returns  control
to  the host operating system. This is useful in  fixed  function
systems  where  it is not possible (or desirable) that  the  user
interface be altered.

The  STATUS  option displays  the current  'state'  of  the  user
interface  system.  This  includes  details  of  the  number   of
different objects available and used,  as  well  as  how much  of
the text space remains. The text space is used for storing names,
actions, and other strings.

The  READ and SAVE keys take text values which give  a  filename.
The  SAVE key saves the current interface together with  all  the
currently  set  Semper  variables. The  READ   key  provides  the
complementary   function  and  restores   a  previously   defined
interface  (consider this in conjunction with the STOP option  to
provide a 'secure' interface). As well as restoring the currently
defined interface, the READ key restores all variables which  are
not  write protected. It is important to remember this as it  can
lead to confusing 'errors' otherwise.

See also: uif.syntax
$add uif.syntax
Keys:
  READ text      Reads a previously defined user interface from a file.
  SAVE text      Saves the current user interface to a file together with all
                 Semper variables.

Options:
  ENABLE         Initialises the user interface system ready to define a user
                 interface.
  EXIT           Halts the current user interface.  Control is returned to the
                 standard Semper environment.
  GO             Starts up the user interface defined by the previous use of
                 user interface commands.
  STATUS         Display the current status of the user interface system.
  STOP           Halts the current user interface.  Control is returned to the
                 host operating system.

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add unix.command unix shell spawn
Use the UNIX command to execute non-interactive Unix commands from within a
Semper session.

Exx: UNIX 'ls .'
       lists the contents of the current directory
     UNIX 'rm junk.dat'
       deletes the file "junk.dat"
     UNIX 'xclock &'
       display the X clock

The Unix command string is specified as a Semper textstring immediately
following the command name.  If it is omitted, Semper prompts for the command
string.

The string is passed to a separate process running a C shell (csh) and is
executed by the shell.  Standard input for the shell is connected to
/dev/null.  Any attempt to read standard input will report an end-of-file
condition (this means that you can't interact with the C shell - to do that
you should open a new terminal window using the window manager menus or a Unix
command like "xterm").  Standard output is copied to Semper's console output
stream and standard error is connected to Semper's standard error (normally
the terminal window from which Semper starts up).

The UNIX command waits until the commands passed to the shell are completed
and return control to the shell.  Some commands (like "xclock" in the last
example above) do not return to the shell until explicitly terminated by other
means, in which case they should be invoked as background processes.  If the
UNIX command is abandoned, all dependent processes will be terminated.

See also unix.syntax
$add unix.syntax
Keys:
  [ ] text       Unix command as textstring [none; prompts if interactive]
$add unset.command unset set variables
You use UNSET to unset or delete a Semper variable.  The command SHOW
VARIABLES lists all the variables that are set.  You can test whether a
variable has been unset with the SET function.

Exx: UNSET TYPE
     UNSET PRESET,ERASE
     IF  SET(N) TYPE 'Variable N = ',N
     IF ~SET(N) TYPE 'Variable N is unset'

UNSET can unset a list of variables (the variable names may optionally be
separated with commas), as in the second example, but it will not unset fixed
or protected variables.

See also: show, set
$add upgrade new extra features changes corrections fixes Fortran environment
The new facilities that become available with Semper 6.4 include more than two
dozen new processing commands.  Very significant improvements have been made
with respect to:

    binary morphology
    data storage and access
    Fourier Transforms

For more details about the release, consult the following entries:

    UPGRADE.SUMMARY    Brief summary
    UPGRADE.NEW        New commands and programs
    UPGRADE.EXTRA      Extra facilities
    UPGRADE.CHANGES    Changes to existing facilities
    UPGRADE.FIXES      Corrections to existing facilities
    UPGRADE.FORTRAN    Fortran environment

Some additional changes were made with the 6.45 release. See UPGRADE.645
$add upgrade.summary
NEW COMMANDS

   *   obtaining picture parameters                  PICTURE
   *   diagnostic messages                           DIAGNOSTIC
   *   interactive dragging of graphical objects     DRAG
   *   linear peak detection                         LPD
   *   creating binary images                        THRESHOLD
   *   processing connected binary objects           LABEL, HFILL, FLOOD
   *   convex hull                                   CHULL
   *   binary morphology with structuring elements   BERODE, BDILATE
                                                     BOPEN, BCLOSE
                                                     BHMT
   *   binary morphology within 3x3 neighbourhoods   BMLUT, BMMAP
   *   distance transforms and related commands      DT
                                                     DERODE, DDILATE
                                                     DOPEN, DCLOSE
   *   zones of influence and skiz                   ZONE, SKIZ
   *   Hewlett-Packard LaserJet printer support      HPLJ
   *   program to deagglomerate binary objects       SEPARATE
   *   auto-thresholding program                     AUTO

EXTRA FACILITIES

   *   new keys and options added to the commands ASSIGN, CACHE, ECHO, SAVE,
       LSET, INPUT, OUTPUT, VIEW, SHOW, BACKPROJECT, WEIGHT, WP, ADD, RUN and
       READ
   *   improved data storage and faster data access with larger device,
       picture and variable tables, a greater number of row buffers of
       increased length, memory-based data storage devices and disc devices
       permanently cached in memory
   *   new data format for processing bit-packed binary data
   *   improved handling of output picture range
   *   new multi-radix FFT code for larger and faster Fourier transforms
   *   echoing of text to standard output and standard error
   *   more file handling facilities
   *   extra or improved features for the commands ANALYSE, PCALCULATE, PCURVE,
       SURVEY, OVWRITE and SHOW SIZES
   *   new UIF variable

CHANGES TO EXISTING FACILITIES

   *   use of the Return and Space keys with the page prompt
   *   password for systems running on Unix workstations
   *   output from the PRINT command
   *   the INDEX key in the commands PSET and PTYPE
   *   UIF save file format
   *   checking for incorrect picture labels
   *   default file extensions for the commands READ and WRITE
   *   angular range of ring samples in the OCF command
   *   default size for creating help libraries
   *   commands that unset variables: LUT, PCALCULATE, PCURVE, PFERET, PID
   *   output from the SHOW SYSTEM command
   *   Unix data file permissions

CORRECTIONS TO EXISTING FACILITIES

   *   corrections made to the commands ADD, ANALYSE, ASSIGN, BASE, CALCULATE,
       DEASSIGN, DELETE, ERASE, ERODE, EVENT, EXAMINE, EXTRACT, FLC, FOR,
       GAUSSIAN, HISTOGRAM, HPLJ, INKEY, IOWRITE (PC-DOS systems only), LEARN,
       LIST, MAP, OVWRITE, PANEL, PCURVE, PEAKS, PEXTRACT, PHISTOGRAM,
       POSTSCRIPT, RCF, REINITIALISE, RGB, RHISTOGRAM, SAVE, SKETCH, WP and
       XCF
   *   better handling of diagnostic messages output when Semper's
       initialisation sequence fails
   *   safer evaluation of the ^ operator in expressions
   *   less flushing of disc data when the LIBRARY command is invoked
   *   correct handling of DOS device names in the commands HPLJ and POSTSCRIPT


FORTRAN ENVIRONMENT

   *   14 new Fortran routines for processing bit-packed binary data, access
       to a picture's range parameters, enquiring Semper's interactive state
       and for processing text keys: BFORM, BLOGIC, BSHIFT, BDIFF, BSCAN,
       BCLEAR, BSET, BFILL, BREP, BVALUE, SEMRNG, SEMINT, SEMTEX and FILSTR
   *   new row buffer declarations
   *   new Fortran parameters: NNBUF, KNSBUF, LNBYTE, FILMAX and MEDVM
   *   FT2D and INVFT2 now support multi-radix FFT's
   *   FSOVRW now supports efficient access to the display overlay plane
   *   changes in the functioning of the routines FILMAK, FILPAT, FILSEA,
       FT2D, GETRNG, INVFT2, MEANSD, SEMLAB, SEMLU and SEMROW
   *   modified Fortran parameters: LNBUF, NDVS and NLPS
   *   implicit picture opening is handled differently by the command
       interpreter
   *   SEMGEN accepts more keys and options for each command
   *   corrections to existing routines FILDCD, FILEXI, FSAMPL, FSOVRW,
$add upgrade.new new commands
Obtaining picture parameters - PICTURE
======================================

The command EXAMINE FULL lists all of the parameters associated with a given
picture.  A subset of these parameters can be stored in Semper variables by
means of the PCB command.  Some of these variables (the FORM variable in
particular) can clash with the keys or options of other commands, which can
cause some unexpected things to happen.

The new PICTURE command cures all of these problems by allowing you to request
specific information about a Semper picture, including various statistical
parameters.  The names of variables in which the information is stored have
been chosen so that they do not clash with any keys or options for any of the
existing Semper commands.  We strongly recommend that you use the PICTURE
command instead of the PCB command.

Here is an example using the new command which returns the dimensions of the
current picture in variables NX, NY and NZ and the year, month and day in
which the picture was created in the variables YD, MD and DD.

    PICTURE SIZE DATE


Diagnostic messages - DIAGNOSTIC
================================

The DIAGNOSTIC command outputs messages to the diagnostic output stream.  Its
syntax is the same as the TYPE and LOG commands which output text to the
console and log output streams.  This allows you to generate diagnostic
messages which can be handled in exactly the same way as the error messages
generated by Semper itself, independently of text sent to the console and log
output streams.


Interactive dragging of graphical objects - DRAG
================================================

The DRAG command allows you to position interactively a variety of graphical
objects on the display.  When you terminate the DRAG command, the object's
final position is returned in variables X and Y.  The following types of
graphical objects are supported:

    lines
    arcs
    circles
    sub-regions
    open and closed curves

The syntax for the DRAG command is compatible with the named macros @XY,
@LINE, @ARC, @CIRCLE and @REGION and it can be used in conjunction with other
commands such as XWIRES, SKETCH and MARK.  For example, the sequence of
commands

    XWIRES FRAME ARC NOVERIFY
    DRAG FRAME @ARC

allows you to input a circular arc with the display cursor and then drag it on
the current display frame.

Linear peak detection - LPD
===========================

You use the LPD command to search for peaks (true local maxima) in a 1-D
picture and output a list a peak parameters in the form of a particle
parameter list which you can examine with the particle analysis commands such
as PSET and PTYPE.  The command can also output a line spectrum indicating the
peak maxima and bounds.  The number of peaks is returned in the variable N.


Creating binary images - THRESHOLD
==================================

Semper's binary processing commands will accept images with any data form,
treating zero pixels as background pixels and non-zero pixels as foreground
pixels.  Most grey-scale images are not immediately suitable for binary
processing.  They have to be converted into binary (zero/non-zero) form using
an appropriate conversion algorithm.  A simple and very common way to do this
is to apply some kind of intensity thresholding.

The new THRESHOLD command provides a fast and convenient way to do this.  It
allows you to specify one or more upper and lower grey-scale intensity
thresholds to define the conditions for detecting foreground pixels.  Wherever
the threshold limits are satisfied, a 1 is output, and elsewhere, zeros are
output.  For example, the command

    THRESHOLD GE 5 LT 10

would replace the current picture with a byte form picture with 1's where
source pixels are 5 or more and less than 10.

If no threshold limits are specified, a lower limit which is halfway between
the minimum and maximum pixel value in the source picture is used.


Processing connected binary objects - LABEL, HFILL, FLOOD
=========================================================

A binary image can contain any number of disjoint foreground regions.  On a
square grid the rule for connectivity between pixels depends on whether the
pixels are foreground or background pixels.  Foreground pixels are treated as
being 8-connected, that is, two foreground pixels are directly connected if
they are in any way adjacent.  Background pixels are treated as being
4-connected (if they are horizontally or vertically adjacent).  A set of
foreground pixels defines a connected region if an 8-connected path can be
found between every pair of pixels in that region.

The existing ANALYSE command thresholds a source image and then identifies and
measures all foreground regions in the resulting binary image.  All the
measurements are obtained in a single pass through the image and stored in a
position list.  The size of a position list is limited by the row buffer size,
so this in turn limits the number of regions that can be identified.  The
segmented or labelled image, if one is required, is generated in one or more
additional passes through the output image.  Additional passes are only
required if the regions are very convoluted.

The efficient single pass algorithm used by ANALYSE has been adapted to
provide several new commands.  The options FG and BG have been introduced in
all of these new commands to allow you to process background regions as well
as foreground regions.

If you omit the thresholding and measurement stages from ANALYSE, you are left
with the new LABEL command which generates just the segmented image.  This is
much faster than ANALYSE and there is no limit on the number of regions that
can be labelled (up to the maximum 16-bit integer = 32767).  The largest
region id is equal to the number of regions identified so the LABEL command
allows you to count objects in a binary image.  The labelled image obtained by
specifying both the FG and BG options provides a complete description of the
connectivity of a binary image - if any two points in the image have the same
label, they must be connected.

Holes in foreground regions can be filled by inverting any background regions
not touching the edges of the source image.  This is carried out by the new
HFILL command.  By specifying the BG option, holes in background regions can
be filled.

The new FLOOD command provides a seed point fill facility.  Any region which
overlaps a seed point is filled with 1's.  The rest of the output image is set
to zero.  You can use the FG and BG options to specify whether foreground
and/or background regions are considered.  Seed points can be specified by
position with the POSITION key or with a position list.  Alternatively, they
can be specified in the form of a binary mask, where each foreground pixel is
treated as a seed point.


Convex Hull determination
=========================

You generate the convex hull of a set of binary objects with the command
CHULL.  If you imagine stretching an elastic band around all the foreground
regions in the source picture, the convex hull is the area enclosed by the
elastic band.  The convex hull therefore includes in its boundary all the
extreme points of the foreground regions of the source picture.  You can
detect any concavities in a binary object by looking at the difference between
the object and its convex hull.  If there is no difference, the object must be
convex. CHULL also returns the convex perimeter and area in the variables P
and A.


Binary morphology with structuring elements - BERODE,BDILATE,BOPEN,BCLOSE,BHMT
==============================================================================

A whole class of binary morphological operations can be defined in terms of
structuring elements - the binary equivalent of convolution kernels.  A
structuring element is a binary mask which defines the spatial extent of the
morphological operation.  There are no restrictions on the size and shape of
the structuring element: only the total number of defined elements in the
structuring element is limited (to some number in excess of 100).  Since the
processing time for a particular operation is proportional to the number of
defined elements in the structuring element, this limit is not one which you
are likely to want to exceed in practice.  It is worth noting that some very
large structuring elements can be decomposed into a sequence of much reduced
structuring elements.  This technique can bring large savings in processing
time.

The basic morphological operations of erosion, dilation, opening and closing
are directly supported by the new commands BERODE, BDILATE, BOPEN and BCLOSE.
BOPEN is equivalent to BERODE followed by BDILATE and BCLOSE is equivalent to
BDILATE followed by BERODE.  The structuring element is supplied in the form
of a binary picture which you specify by means of the WITH key.  A multi-layer
picture can be used to specify a whole sequence of structuring elements.  The
operation of erosion or dilation can be repeated any number of times by using
the TIMES key.  A zero value for the TIMES key specifies an infinite number of
iterations.  If a given iteration causes no further change in the output
image, the command automatically terminates.  The effect of a particular
operation can be restricted to certain parts of the image by specifying a
binary mask image with the MASK key.  Only those pixels where the mask image
is non-zero are allowed to change.

The operation of erosion can be thought of as a templating operation where the
structuring element is the template and the output image records all the
positions where the structuring element matches the source image.  The
matching process only considers non-zero pixels in the structuring element and
the source image.  A similar templating operation exists where the template
specifies the pattern of zero pixels as well the pattern of non-zero pixels to
be matched.  This is called a Hit or Miss transform and it is what the new
BHMT command supports.  It has the same keys WITH, TIMES and MASK, but in this
case, the picture values for the structuring element are 0 for a Miss, 1 for a
Hit and any other value is ignored (don't care).  In addition to the basic
templating operation, Hit or Miss transforms are used to carry out what are
called thickening or thinning transformations, where the result of the Hit or
Miss transform is either added to or subtracted from the source image.  You
select a thickening or thinning transformation by specifying the option ADD or
SUBTRACT.  Examples of these transformations are skeletonising, eroding or
growing line ends, dilating without touching, convex hull, etc.


Binary morphology within 3 by 3 neighbourhoods - BMLUT, BMMAP
=============================================================

Within a small binary neighbourhood of N points one can encode every possible
pixel configuration (pattern of 0's and 1's) as a number in the range 0 to
2^N, where each bit in the number represents the state of one neighbourhood
pixel.  The number can be used as an index into a look-up table to determine
the result for each neighbourhood configuration for a particular morphological
transformation.  Note that this procedure is applied simultaneously to all
pixels.  The result of changing the state of a pixel has no effect until the
next iteration.  One iteration using a neighbourhood look-up table is not as
fast as one iteration using a 3 by 3 structuring element.  However, the range
of transformations you can specify with structuring elements is more limited
and quite often it takes more iterations to achieve the same effect.  For
example, object skeletons can be generated using a sequence of 4 look-up
tables but a sequence of 8 structuring elements is required to achieve a
similar effect.

The new command BMMAP supports arbitrary morphological transformations for 3
by 3 binary neighbourhoods.  To specify the transformation you must supply a
look-up table with 512 entries.  You may also specify a sequence of
transformations in successive rows of a look-up table picture.  Like the
commands already described above, BMMAP has keys WITH, TIMES and MASK.  The
WITH key specifies the look-up table picture and the TIMES and MASK keys
fulfil the same function as described above.

The existing commands ERODE, DILATE and MEDIAN use the same look-up table
approach as BMMAP but provide a range of keys and options to select and then
apply different look-up tables for different morphological transformations.
BMMAP does not provide similar keys and options.  Instead, there is a new
command BMLUT which will generate the look-up tables for you.  With the
options ERODE, DILATE or MEDIAN, BMLUT will generate look-up-tables for any of
the transformations supported by the commands ERODE, DILATE and MEDIAN.

In addition to supporting these transformations, BMLUT provides a new and very
powerful facility for specifying morphological transformations.  With the keys
IF and UNLESS, you can specify one or more logical expressions which define
the required result for a particular morphological transformation.  There is a
set of special variables to which these expressions must refer.  The variables
describe the state of a particular neighbourhood configuration.  BMLUT sets
these variables according to the state of each of the possible neighbourhood
configurations in turn and then determines the outcome for the current
configuration by evaluating the logical expressions.  The final outcome is
TRUE if the IF expression is TRUE and the UNLESS expression is FALSE.  Either
expression may be omitted, in which case respective defaults of TRUE and FALSE
are assumed.

Variables P0 to P8 describe the pixel value for each of the nine neighbourhood
positions.  These are numbered in the following way:

    0  3  6
    1  4  7
    2  5  8

So for example, negation, erosion and dilation transformations could be
specified like this:

    BMLUT UNLESS P4
    BMLUT IF P0 & P1 & P2 & P3 & P4 & P5 & P6 & P7 & P8
    BMLUT IF P0 | P1 | P2 | P3 | P4 | P5 | P6 | P7 | P8

Although these variables are sufficient to specify any kind of transformation,
several more variables are provided which describe some useful subsidiary
parameters:

    N4 = P1 + P3 + P5 + P7

    N8 = P0 + P1 + P2 + P3 + P5 + P6 + P7 + P8

    C  = (~P0 & P1) + (~P1 & P2) + (~P2 & P5) + (~P5 & P8) +
         (~P8 & P7) + (~P7 & P6) + (~P6 & P3) + (~P3 & P0)

    C4 = P1 + P3 + P5 + P7 - (P0 & P1 & P3) - (P2 & P1 & P5)
                           - (P6 & P3 & P7) - (P8 & P5 & P7)

    C8 = ~P1 + ~P3 + ~P5 + ~P7 - (~P0 & ~P1 & ~P3) - (~P2 & ~P1 & ~P5)
                               - (~P6 & ~P3 & ~P7) - (~P8 & ~P5 & ~P7)

These can be used to simplify the expressions defining morphological
transformations, for example, the expressions corresponding to the three
existing commands ERODE, DILATE and MEDIAN could be specified in the following
way:

    ERODE   =>  BMLUT IF P4 & N8=8
    DILATE  =>  BMLUT IF P4 | N8~=0
    MEDIAN  =>  BMLUT IF (P4 + N8) > 4

A series of comma separated expressions can be used to specify a sequence of
morphological transformations, for example,

    BMLUT IF P4 | N4~=0, P4 | N8~=0

specifies a 4-connected dilation followed by a 8-connected dilation, a
transformation which gives a more rounded appearance to the dilated outlines
of objects.  Notice how the use of subsidiary variables N4 and N8 reflects the
character of the transformations they define.

There are many more examples of useful morphological transformations that
could be given.  Here is one final example which should serve to illustrate
the power and generality of the BMLUT command for specifying morphological
transformations:

    BMLUT IF P4 UNLESS C8=1 & N8~=1 & (~P1 & P7), C8=1 & N8~=1 & (~P7 & P1), +
                       C8=1 & N8~=1 & (~P3 & P5), C8=1 & N8~=1 & (~P5 & P3)

This specifies a four-pass algorithm that thins objects down to an 8-connected
skeleton.  Substituting C4 and N4 for C8 and N8 will give a similar, but
4-connected result.


Distance transforms and related commands - DT, DERODE, DDILATE. DOPEN, DCLOSE
=============================================================================

If you erode a binary source image, add the eroded image to a copy of the
source image and repeat this process until nothing is left of the eroded
image, the result is the distance transform of the source image.  A distance
transform describes the distance of each foreground pixel from the nearest
background pixel.  In this example the distances are based on the 8-connected
metric.  The 8-connected distance between two points (X1,Y1) and (X2,Y2) is
defined as follows:

    D8 = MAX(MOD(X2-X1),MOD(Y2-Y1))

A different distance transform can be generated by using 4-connected erosion
(delete pixels that are 4-connected to the background).  This will be based on
the 4-connected metric which has the following definition:

    D4 = MOD(X2-X1) + MOD(Y2-Y1)

Both of these are approximations to the true or "Euclidean" distance between
two points:

    DE = ROOT((X2-X1)^2 + (Y2-Y1)^2)

Note that the 8-connected metric always gives a result that is less than or
equal to the Euclidean metric and the 4-connected metric always gives a result
that is greater than or equal to the Euclidean metric:

    D8 <= DE <= D4

By using 4-connected and 8-connected erosion on alternate iterations one gets
a result which is much closer to the Euclidean distance transform.

    D48 = MAX(FIX(2*(D4+1)/3)),D8)

The disadvantage with this approach is that it is iterative: the number of
iterations required depends on the size of the largest object in the source
image.  Also, none of these distance transforms provide Euclidean distance
values for all pixels.  It turns out that there exists a non-iterative
approach for generating Euclidean distance transforms which requires a maximum
of four passes through the image.  For the 4-connected and 8-connected
transforms, two passes are sufficient.

Distance transforms are generated by means of the new DT command.  The options
DIAMOND, SQUARE, OCTAGON and CIRCLE allow you to select the metric for
determining distances.  The options describe the shape of the structuring
element you would use if you were to use the iterative approach to generate
the distance transform.  Therefore, the CIRCLE option (the default) selects
the Euclidean metric, the DIAMOND and SQUARE options select the 4-connected
and 8-connected metrics respectively and the OCTAGON option selects the
combined use of 4 and 8-connected metrics.  By default, the distance transform
describes distances inside foreground regions.  With the BG option you can
obtain the same result for background regions.

From the iterative definition of distance transforms it is clear that a
distance transform includes the results of all the possible erosions of a
binary image.  Therefore, the result for an arbitrary number of erosions can
be obtained very quickly from the distance transform by thresholding it.  By
thresholding the Euclidean distance transform, you can obtain the result of
eroding a binary image with an exact circular disc of arbitrary radius, a
result that cannot be achieved by any other means.  Thresholding the distance
transform of background regions gives you the result of dilating a binary
image.  Combining erosion and dilation gives opening and closing
transformations.  These operations have been incorporated into the new
commands DERODE, DDILATE, DOPEN and DCLOSE.  As well as the same options as
the DT command to select the required metric for generating the distance
transforms, there is a RADIUS key to define the size of the structuring
element (the radius in fact is the value with which to threshold the distance
transform).  For example, to carry out an opening with a circular structuring
element of radius 3.4 you would use the following command:

    DOPEN CIRCLE RADIUS 3.4


Zones of influence and skiz - ZONE, SKIZ
========================================

Two new commands ZONE and SKIZ have been provided to generate zones of
influence and the skiz or skeleton by zones of influence.  The commands take
advantage of the development of the new commands LABEL and DT to provide a
non-iterative and fast method for generating the required result.

The starting point for generating zones of influence or the skiz (which is the
complement of the zones of influence) is a labelled image, where different
regions of the image are assigned different positive integer values, with the
remainder of the image (background or unclassified regions) set to zero.  By
default, the source image is treated as a binary image and a labelled image is
automatically generated from it.  You can suppress the initial labelling pass
by specifying the LABEL option.  In this way you can process images generated
by any of the classification commands (BOX, MINDISTANCE and LIKELIHOOD).

The zones of influence are generated by setting each output pixel to the label
of the nearest labelled pixel in the labelled image.  Where there are pixels
in different regions which are equally near to a given pixel, a zero is
output.  The decision as to which labelled pixel is "nearest" is determined by
comparing the distance transforms for each labelled region defined in the
source image.  The same options (CIRCLE, DIAMOND, SQUARE and OCTAGON) as in
the DT command may be used to select the metric for calculating the distance
transforms.  The default option (CIRCLE) selects the Euclidean metric which
gives the exact diagonal distance between pixels.

The skiz is the complement of the zones of influence.  It is the locus of
points which are equidistant from different regions and it represents the
boundary between different zones of influence.  The image generated by the
SKIZ command is a binary image where the foreground pixels represent the skiz.
Strictly speaking, only the zero pixels output by the ZONE command lie exactly
on the skiz.  However, these may be very few and far between, so in order to
ensure that a connected result is obtained, the output image includes as part
of the skiz all pairs of 4-connected pixels which lie in different zones of
influence.  The output result is guaranteed to be connected and to be equally
distributed about the exact skiz.  For the result to be unbiased, it means
that the result may vary in thickness and may also not be entirely 4-connected
or 8-connected.  You can obtain a uniformly connected result by applying an
appropriate thinning transformation to the output of the SKIZ command.



Hewlett-Packard LaserJet printer support - HPLJ
===============================================

The HPLJ command, which was already available on systems running on an IBM PC
or compatible with MS-DOS, is now available on systems running Unix.  The
printer output is written to a file which can then be copied to a printer that
supports Hewlett-Packard's LaserJet+ format.


Deagglomeration of binary objects - SEPARATE
============================================

It is not always possible to separate objects in a grey-scale image by
choosing an appropriate intensity threshold.  However, there may still be
enough detail in the binary image to allow the objects to be separated.  The
key to separating binary objects is to be found in the distance transform.
When rounded objects touch and coalesce, there will usually be some residual
cusps or indentations near the point where the objects meet.  If you look at
the distance transform, you will notice that the distance contours will sooner
or later split into separate contours for each object.  Binary images obtained
by thresholding incomplete grain boundaries also tend to exhibit the same
characteristic separation of contours.

The contours converge on what are called the ultimate erosions of the binary
regions - the regions that would disappear at any subsequent stage of erosion.
By dilating without touching the ultimate erosions until they fill the
foreground regions in the source image, you should end up with an image where
all the objects are separated (or the grain boundaries reconstructed).

The SEPARATE program implements this approach for separating binary objects.
You must first set the variables $SOURCE, $DEST and $TD to specify binary
source and destination pictures and a picture device to act as a temporary
work space.  There are four other variables: $ULT, $DD, $DU, $MONITOR which
you may also set to control the operation of the SEPARATE program.  $dd
specifies the distance increment between each stage of erosion and dilation
and therefore controls the resolution of the separation process.  $DU controls
an extra feature which guards against the fragmentation of ultimate erosions,
a factor which can cause over-segmentation of the source image.

For full details about the SEPARATE program, look at the comments in the
source code in the file SEMPER.SPL.


Automatic thresholding - AUTO
=============================

If you look at the histogram of a grey-scale image which contains bright
objects on a dark background, you will observe two peaks with a minimum
between these two peaks.  The source intensity value which corresponds to
this minimum in the histogram is quite a good value for thresholding the
source image to detect all the bright objects.

The AUTO program implements this approach.  As with the SEPARATE program, you
must first set variables $SOURCE, $DEST and $TD to specify source and
destination pictures and a picture device to provide a temporary work space.
The source picture should contain a grey-scale image and the destination
picture will contain the binary, thresholded result.  Note that this method
does not always work properly if the source image has been rescaled, as this
might result in a histogram with interspersed zero counts which would be seen
as false minima.
$add upgrade.extra extra facilities
New command keys and options
============================

ASSIGN        The MEMORY option allows you to assign a data storage device
              entirely in memory.
CACHE         With the MEMORY and FREE option you can allocate and free a
              separate memory buffer to hold all the data associated with a
              data storage device.  You specify which device with the DEVICE
              key.
ECHO          The options STANDARD OUTPUT and STANDARD ERROR allow you to
              direct text to separate standard ouptut and standard error
              streams.  The STANDARD OUTPUT option is synonymous with the old
              TERMINAL option.  The STANDARD keyword in both options may be
              omitted.
SAVE          The RENUMBER option causes pictures to be renumbered from 1
              upwards instead of retaining the same picture number.  You can
              now control the size of the ouptut file and its directory with
              the keys SIZE and SLOTS in the same way as in the ASSIGN
              command.  You can also specify the device number to be used with
              with the DEVICE key.  The operation of the SAVE command can be
              verified on the console if you set the VERIFY option.
LSET          The LSET command always used to modify the current display
              look-up table.  Now you can change any look-up table by
              specifying the look-up table number with the NUMBER key.
INPUT         For PC systems running MS-DOS, the PAINT and LINK options have
              been added to provide support for Paintbrush PCX files and Link
              Analytical data files.  If you are using the RAW option, you can
              also specify the SKIP key to skip a given number of bytes before
              reading the image data, and the SWAP option to read the data
              assuming the Motorola byte ordering instead of Intel byte
              ordering.
              In all versions of the INPUT command, you can now use the option
              AGAIN instead of the NAME key to read the same file again.
OUTPUT        For PC systems running MS-DOS, the PAINT and TIFF options have
              been added to provide support for Paintbrush PCX files and
              greyscale TIFF files.  As with the INPUT command, you can
              specify the SWAP option with the RAW option to write a file with
              a different byte ordering.
              The output command for Sprynt systems and systems running Unix
              also supports the new TIFF option.
VIEW          With the ENQUIRE option, the VIEW command now returns the
              current viewing parameters in the variables F,Z,X1,X2,Y1,Y2.
SHOW          The option FULL may be used with the PROGRAM option to list
              program index usage.
BACKPROJECT   The ADD option has been added to reflect the BACKPROJECT
              command's default operation.
WEIGHT        The MULTIPLY option has been added to reflect the WEIGHT
              command's default operation.
WP            The ON option has added to reflect the WP command's default
              operation.
ADD,READ,RUN  You can specify the option AGAIN with any of these commands
              instead of the NAME key to read the same file again.
OVERLAY       For systems with an XWindows display, the options ON and OFF
              have been added to allow you to control the visibility of the
              overlay plane.


Storage of data in memory - static and dynamic data arrays
==========================================================

Semper stores frequently used data in memory.  Some of this data, such as the
device table, logical picture table and image row data (row buffers) are
stored in static data arrays.  Other data, such as Semper's disc cache and
display buffers, are stored in dynamically allocated data arrays.  Less
frequently used data are stored externally on disc.  In the past the extent of
memory storage had to be kept within the limited memory resources of the host
computer.  This was particularly the case for PC systems running MS-DOS
(PC-DOS systems).  As memory constraints have receded, every effort has been
made to use the available memory resources in the best possible way.  This
upgrade of the Semper software introduces a number of significant improvements
in the way memory is used.

First of all, the sizes of Semper's device table, logical picture table and
variable table have been increased:

    Device table           PC-DOS systems     10
                           other systems      20

    Logical picture table  PC-DOS systems     10
                           other systems      20

    Variable table         all systems       300

The size of the device table determines the number of devices that can be
simultaneously assigned.  The size of the logical picture table limits the
number of pictures that can be accessed at the same time.  For the CALCULATE
command this means that one entry must be used to refer to the output picture
and the rest may be used to refer to any source pictures.  With the original
limit of 6 logical picture table entries, it meant that CALCULATE could refer
to no more than five separate source pictures.

The number and size of Semper's row buffers have also been increased:

    Number of row buffers  PC-DOS systems       6 (same as before)
                           other systems       15

    Row buffer size        PC-DOS systems    8320 bytes
                           other systems    32448 bytes

The row buffer size has been increased by a small amount for PC-DOS systems,
so that the maximum width of half-plane Fourier transforms can be doubled. For
other systems the size has been slightly more than doubled so that much wider
images in general can be processed.

For systems other than PC-DOS systems the number of row buffers has also been
increased from 6 to 15.  This is of immediate benefit in the new FFT code as
it will allow you to transform images right up to the maximum size that Semper
can store.  The CALCULATE command also benefits from this because the number
of row buffers limits the extent to which expressions can be nested.  There
are several more commands that could benefit from this change, but for the
moment these will continue to assume that the number of row buffers is limited
to six.

The command interpreter's ability to handle nested expressions has been
extended to match the improvements brought about in the CALCULATE command
which means the Semper can noe evaluate more deeply nested expressions.

For systems that can support the dynamic allocation of large memory arrays
(not PC-DOS systems), significant improvements have been made to the way disc
i/o is buffered.  The CACHE command already allowed you to vary the number and
size of cache buffers so that large amounts of disc data could be stored in
memory.  This is the best solution when accessing data from extremely large
files, where it would not be possible to store the entire contents of the file
in memory.  For disc files of more moderate size, the CACHE command now lets
you allocate a separate, dynamically allocated memory buffer into which the
entire contents of the file is transferred.  You do this by setting the MEMORY
option and specifying the device number for the file with the DEVICE key.

Once this happens, all the data is accessed directly from memory, avoiding all
disc i/o.  Only when the device is flushed (with the CACHE FLUSH command) or
the memory buffer is freed (with the CACHE FREE command) is any data written
back to disc.

The ASSIGN MEMORY command goes one stage further by allowing you to create
data storage devices (picture discs, program libraries or help libraries)
which reside only in memory.  You can now use the MEMORY option where you used
to specify the SCRATCH option to create temporary workspaces, with the
guarantee that all data accesses will not involve any disc i/o.  Semper
automatically allocates a memory buffer to store the data that would have been
stored in the temporary work disc (device 0).  If there is insufficient memory
to allocate for the work disc, a temporary disc file is created as before (you
may not want to proceed under this circumstance because it almost certainly
means that Semper will be unable to allocate any memory for its disc cache, so
there will no caching of disc i/o either).


Bit-packed binary data
======================

Binary images can be compressed by storing 8 binary pixels in each byte of
storage.  A way of packing/unpacking and processing data in this way has now
been developed.  This underpins many of the improvements in processing speed
achieved by the new binary morphology commands.  However, it does not mean
that you can store images in a picture storage device in bit-packed form. Only
the four existing data forms: byte, integer, fp and complex are supported for
stored images.  Whenever data in bit-packed form is required, the necessary
conversion is carried out.  This data conversion overhead may cancel out some
of the improvement in processing speed of the new commands when carrying out
very simple operations.  For operations requiring a large number of
iterations, the overhead will be small compared with the overall processing
time.  When comparing the new commands with existing facilities, you should
find that, at worst, they are about the same speed and, at best, the new
commands can be 10 to 20 times faster!

With the increased row buffer size and the bit-packed data format it is now
possible for some of the new commands to store and process reasonable size
images entirely in memory, a factor which can nearly double the processing
speed.  A row buffer of 32,448 bytes can hold 259,584 bits of information
which corresponds roughly to an image size of 500 by 500 pixels.


Output picture range
====================

When the data range of a picture is established (usually as a result of using
the SURVEY or DISPLAY command), the information is recorded in the picture
label.  Most of Semper's processing commands do not do this directly which
means that a picture has to be rescanned in order to establish the data range.
This situation has changed somewhat with the new processing commands.  Where
the data range can be determined at little or no extra cost it is recorded in
the picture label.


New FFT code
============

Semper's FFT code has been rewritten to use a multi-radix approach.  This
means that images with "factorisable" dimensions can now be transformed.  The
command SHOW SIZES lists all the sizes that are factorisable (they must be a
multiple of 4 and must have no factors except 2, 3, 4 and 5).  The code has
also been written to take full advantage of the increases in size and number
of row buffers.  The commands that are affected are FOURIER, IMAGE, PS, ACF
and XCF.

The smallest 2-D image you can transform is a 4 by 4 square of pixels.  Beyond
this, you can transform all images with factorisable dimensions up to the
maximum listed in the table below.  The limit depends on whether or not you
are running on a PC-DOS system and whether the source image is real
(half-plane FFT) or complex (full-plane FFT).

    PC-DOS systems     real image, half-plane FFT         1440 x  1440 pixels
                       complex image, full-plane FFT       800 x   800 pixels

    Other systems      real image, half-plane FFT         8100 x 32400 pixels
                       complex image, full-plane FFT      4000 x 32400 pixels

For PC-DOS systems, the limits given above apply to a square image.  The FFT
code partitions the row buffer space into several arrays, one of which has a
size that depends on the number of rows.  As you reduce the number of columns
in an image, the maximum number of rows increases a rate that is between 8 and
nine times the rate of decrease in the number of columns.  This means that
there are many more sizes that can be transformed than the limits stated above
would suggest.  For other systems, the limits are in fact determined by the
maximum number of rows and columns that Semper can handle (32448 byte = 8112
real = 4056 complex pixels for the number of columns, and 32767 for the number
of rows), rounded down to the nearest factorisable size.

Note that PC-DOS systems could previously transform 1024 by 1024 complex
images.  This is more than the multi-radix code can support, so a branch to
the original radix-2 code has been included to maintain support for this size
of Fourier transform.  Note also that with the slight increase in row buffer
size it is now possible to transform 2048 wide images, provided that the
number of rows is small enough to allow it.

The improved FFT code not only transforms a greater range of image sizes but
it is also intrinsically faster because the multi-radix approach requires
fewer passes through the image and can reduce the amount of computation
required.  In general, images sizes which only include factors of 2 and 4 are
processed 20% to 100% faster than before (depending on which system you are
running on).  Image sizes which include factors of 3 or 5 (which you could not
transform previously) take up to 50% longer to transform than the closest
image size whose dimensions are a power of 2, because factors of 3 and 5
require more floating-point calculations to be carried out.


Echoing of text to standard ouptut and standard error
=====================================================

Semper recognises different classes of output text and handles each one by
means of a separate logical output stream: console, diagnostic, log, monitor,
command and input.  The ECHO command allows you to control where each class of
output will be sent: to the terminal and to any number of log files.

Now the terminal stream has been replaced with two separate output streams
called standard output and standard error.  When Semper is running in batch
mode (BATCH variable is set to 1), text will be sent unprocessed to the host
operating system's standard output and standard error streams.  Some systems
(especially Unix systems) will allow you to redirect output sent to these
streams.  When Semper is running in interactive mode, (BATCH variable is set
to 0), output to standard error is treated in exactly the same way as in batch
mode and output to standard output is processed into pages and sent directly
to the terminal.  In interactive mode, the new STANDARD OUTPUT option for the
ECHO command has exactly the same meaning as the old TERMINAL option.  The
ECHO command retains the TERMINAL option as a synonym for STANDARD OUTPUT.


File handling
=============

You refer to data files in Semper commands by specifyning the file name with
the NAME key.  Several input commands (ADD, INPUT, READ and RUN) now recognise
the option AGAIN which allows you to read the same file again without you
having to respecify the file name with the NAME key.

A file name may consist of a name followed by an extension with a dot "."
separating the two strings.  Most commands supply a default extension if none
is specified.  The file name may also be preceded by a directory path to
locate the file.  The maximum lengths allowed for each component are as
follows:

    directory     130
    name           80
    extension      40

giving a maximum length for a file name of 250 characters.  Note that the host
operating system may impose further limits on the length of these components.

If the directory path is omitted when specifying an input file name, a search
is made for the file in each of the directories in Semper's file search path.
The current directory is always the first directory in the search path.  The
search path is obtained from the host operating system's search path which is
usually stored in the environment variable called PATH.  On PC systems, the
length of the search path string is limited to 255 characters.  On all other
systems, this limit has now been raised to 1024 characters.

When creating an output file, the file is created in the current directory
unless you specify the directory path to point to another directory.

There is no need to specify a file name when creating a temporary or scratch
file.  Semper generates a unique 8 character name string starting with "zzzz"
and supplies a default extension.  You can now specify the directory in which
a temporary file (including Semper's work disc) will be created by setting one
of the following environment variables:

    SEMPER$TEMP, TEMPDIR, TEMPFILES, TEMP

If more than one of these environment variables is set, the first one in the
list is used.  If none is set, the file is created in the current directory.
The choice of directory on some systems was originally left to the operating
system.  This could cause problems if the chosen directory was in a disc
partition with insufficient space.  Use the command SHOW DEVICES (or SHOW
DEVICE 0 for Semper's work disc) to list the full path name for any temporary
files.


Other new features
==================

The ANALYSE command now returns the number of particles found in the variable
N.  Previously, ANALYSE faulted the absence of the key GE or LE for specifying
an intensity threshold and returned with error 152.  Now a default value for
GE which is equal to the middle of the source picture's intensity range is
used and error 152 has now been removed from the ANALYSE command.

The commands PCALCULATE and PCURVE now returns the intensity range and
standard deviation for a given particle or curve in the variables I1, I2 and
SDI.  In the case of the PCURVE command, the new varaibles are set only if the
IMAGE key is set.

The SURVEY FULL command could give unreliable results for the intensity mean
and standard deviation when scanning pictures with extreme variations of
intensity.  The command would then rescan the image to try to recover the
situation.  The underlying code for the SURVEY command has been rewritten to
minimise the effect of numerical roundoff.  The code is more accurate and more
efficient.  The greater accuracy also means that a second scan is never
required.

The OVWRITE command in its original form was generally slower than the display
command for outputting images to the display.  This was because it output each
row of pixels to the overlay by first erasing the row and then drawing each
continuous row of pixels as a horizontal line.  Now the underlying code for
OVWRITE will support direct pixel output to the overlay so you should observe
images appearing on the overlay plane at about the same rate as on the image
plane.

The command SHOW SIZES will now list all factorisable sizes up to 32767.

A new protected variable called UIF has been added to flag whether the UIF
menu system has control (between the commands UIF GO and UIF EXIT).  This
variable can be used in library procedures to determine how to interact with
the user.

For systems with an XWindows display, the XWIRES command can now alter the
view position so that it tracks the cursor across a frame that is larger than
the display window.  Press H or ? when the XWIRES command is running for
details about this new feature.

$add upgrade.changes changes
The actions associated with the Return and Space keys, in response to the page
prompt, have been swapped.  Pressing the Return key now causes the next line
to be output and pressing the Space key outputs the next page of text.  This
makes the operation ot the Return and Space keys compatible with other paging
programs such as MORE.

All systems running on Unix workstations now require a password before Semper
will start up.  The password is ties to the software's serial number and the
host computer's id.  This is to prevent unauthorised use of the Semper
package.  When you first attempt to run the new software, a message will
appear with instructions about how to go about obtaining a password.  If you
are licensed to use Semper, Synoptics will issue you with the appropriate
password which you should enter into Semper's password file "semper.pwd".  You
should then be able to run Semper as usual.  Full details about this can be
found in the password file itself.

When using the PRINT command to type arrays of pixel values, the command would
type the message "All values equal to zero" if all the pixel values were zero.
The PRINT command will now output the array of zeros.

The INDEX key is faulted by the commands PSET and PTYPE if it is less than
zero.  It is now also faulted if it exceeds the number of selected particles.

The format for the UIF save file has changed.  Any attempt to read a save file
with the old format will be faulted with the error message "Wrong version UIF
file".  Most programs which use such files, such as TUTOR, test for the
presence of the save file and recreate it if it does not exist.  In this case,
all you have to do to generate a save file with the new format is to delete
the old save file.

When invoking Semper, you can specify the size of the display partition table
with the -PARTITION keyword.  The size can be anywhere in the range 1 to 999.
The default size used to be 400 for all systems.  Now a default of 80 is
assumed for PC systems runnind MS-DOS, and a default of 100 is assumed for all
other systems except Massram and Syntillate systems where the original default
of 400 still applies.

It is possible, when importing images with commands such as INPUT and READ,
for the picture label to be incorrect.  This can cause obscure problems later
on if you do not immediately encounter error 52 - "Picture ... has malformed
label".  The information in the picture label is now checked more often and
more thoroughly so that any attempt to store invalid data in a picture label
is flagged immediately with one of the new errors 147, 148 or 149.

The default extension for files handled by the READ and WRITE commands, with
the UNFORMATTED option specified, has been changed from ".dat" to ".unf".  The
READ command will use the default extension ".dat" if it fails to find a file
with the default extension ".unf".

By default, the OCF command uses semi-circular ring samples.  These used to
range from 0 to 180 degrees with respect to the X axis.  This meant that half-
plane Fourier pictures could not be processed by the OCF command.  The angular
range has been changed to -90 to 90 degrees so that such pictures can now be
processed.

When the Help Manager program HELPMAN creates a new help library, the default
size used to be 800 Kbytes.  This has now been increased to 1000 Kbytes.

The commands LUT KEYS, PCALCULATE, PCURVE, PFERET and PID return information
by setting variables.  They used to unset all the variables regardless of
whether or not the variables were ultimately returned with a value.  This
could cause problems when these variables were expected to retain their value
when one of these commands was invoked.  The commands no longer unset the
following variables:

    LUT KEYS      B,C,R,R2,H,H2
    PCALCULATE    SI,MI,XCM,YCM,MM1,MM2,PHI
    PCURVE        XR,YR,X1,X2,Y1,Y2,HF,VF,AF,BF,HP,VP,R,A,C,NP,XC,YC,M1,M2,
                  THETA,SI,MI,XCM,YCM,MM1,MM2,PHI
    PFERET        F,F2,F3,F4,F5,F6,F7,F8,F9
    PID           PID

The output from the command SHOW SYSTEM has been modified to improve the
presentation of the system parameters and to include additional information
such as the number of row buffers and the number of edge pixels.

On systems running Unix, the permissions mask for data files (picture discs,
program libraries and help libraries) created by the ASSIGN command and the
Help Manager program HELPMAN has been changed to allow read access for all
users.  Previously, read access was denied to users who did not have owner or
group priviledges.

$add upgrade.fixes corrections
COMMAND-SPECIFIC CHANGES
========================

ADD           When inputting the source code for a program with the ADD
              command, an unmatched quote in a comment would cause subsequent
              lines to be treated as part of the comment and cause the program
              to misbehave or fail when it was executed.  For example,

              example()
                 for i=1,10
                    !  What's this comment for?
                    type i
                 loop
              end

              The ADD command now inserts an additional quote at the end of
              the line to limit this effect and tells you that it has done so
              with a warning message.

ANALYSE       Under certain circumstances, the ANALYSE command could produce
              incorrect results for the perimeter of a particle.  The result
              was either grossly incorrect, in which case you would immediately
              notice the error, or, more often the the result would be slightly
              less than the correct value.  This has now been put right.  If
              you have any suspicions about the accuracy of perimeter
              measurements obtained with the ANALYSE command, you can check
              this by repeating the analysis with the new version of the
              command.

ASSIGN        Early versions of Semper 6.3 failed to request confirmation
              before creating a new picture disc or program library (option
              NEW) which would overwrite an existing file.  This has now been
              corrected.

BASE          Several corrections have been made to the BASE command:

              *   if the base vectors (variables U,U2 and V,V2) are zero,
                  this is now trapped (the command used to fail with a zero
                  divide error)
              *   the direction of the displacement marks is now correct
                  (they used to point in the opposite direction)
              *   correct values are now returned with the variable R

CALCULATE     The function RE() now returns the real part instead of the
              imaginary part of a complex pixel.

              The following changes were made to deal with situations which
              could cause the command to fail when evaluating the ^ operator:

              *   0^N for all values of N now returns 0.0
              *   N^0 for non-zero values of N now returns 1.0
              *   raising negative numbers to fractional powers is now
                  faulted with error 99

DEASSIGN      Early versions of Semper 6.3 failed to request confirmation
              before deleting a file associated with a device (option DELETE).
              This has now been corrected.

DELETE        The documentation for commands DELETE, EXAMINE and WP states
              that picture numbers are specified without any preceding
              keyword.  The syntax definitions for these commands, however,
              still referred to the FROM key for specifying picture numbers.
              The dependence on the FROM key has now been removed.

ERASE         The options IMAGE and OVERLAY are supposed to be mutually
              exclusive.  When both options were specified, the ERASE command
              used to clear the image plane.  The command now faults the
              presence of both options.

ERODE         The following corrections have been made to the neighbourhood
              mapping table for the command ERODE ENDS:

                 . . .      o o .      . o o
                 . x .      o x .      . x o
                 o o o      . . .      . . .

              These 3 neighbourhood configurations correspond to entries 14,
              193 and 112 in the mapping table.  Entry 14 is now set to 1 and
              entries 193 and 112 are now set to 0.

EVENT         An attempt to flush the pointer or button queue used to result
              in the keyboard queue being flushed.  Also, to enable and
              disable the break queue, you had to use the commands EVENT BREAK
              and EVENT NOBREAK instead of the documented commands EVENT BREAK
              OPEN and EVENT BREAK CLOSE.  The pointer and button queues can
              now be flushed correctly and the break queue can be controlled
              as documented.

EXAMINE       If the position list type parameter in the picture label for a
              position list was out of range, the EXAMINE command could fail.
              Now all such cases are listed as type "unknown".

              The dependence on the FROM key has now been removed
              (see the DELETE command for details).

EXTRACT       It is possible with very wide byte or integer images to exceed
              the length of the floating-point buffers used by the EXTRACT
              command.  This caused the command to fail.  A check is now made
              for this condition and the problem is reported with the error
              message "Output row length is too long to process".

              The EXTRACT UV command will verify the base vectors on the
              console if the VERIFY option is set.  However the option was
              missing in the syntax definition for the command.  This has now
              been corrected.

FLC           The lower half of the left-hand column is now written correctly
              instead of being overwritten with another part of the image.  A
              possible format overflow has been corrected in text output when
              the VERIFY option is set.

FOR           Several minor problems with FOR loops have been put right.

              *   large loops with very small increments now work
              *   decrementing loops will now start with the correct initial
                  value
              *   the loop variable will never go out of range

GAUSSIAN      The radius of the gaussian function generated by the GAUSSIAN
              command has been doubled so that it agrees with the documented
              function exp(-(x^2)/(2*(r^2))).

HISTOGRAM     The commands HISTOGRAM, PHISTOGRAM and RHISTOGRAM support direct
              output of histogram data to the display with exactly the same
              syntax as the DISPLAY command.  This includes support for the
              option REPEATING which causes the data to be replicated rather
              than interpolated when its is displayed in magnified form (TIMES
              key).  The option REPEATING was missing in the syntax definition
              for these commands.  This has now been corrected.

HPLJ          On PC systems running MS-DOS, the HPLJ command has been modified
              not to change the values of the fixed variables MIN and MAX when
              the PRESET option is set or to swap their values when the
              NEGATED option is set.

INKEY         Use of the INKEY command when Semper is running in batch mode is
              now faulted.  Previously the command would wait indefinitely
              because keyboard and mouse input is not supported in batch mode.

LEARN         Training regions that were too large to process were not
              faulted.  This caused the LEARN command to generate incorrect
              results.  The condition is now correctly checked for and
              reported with the error message "Training regions are too large
              to process".

LIST          When listing programs with the LIST command, a spurious
              character could be output where a short label appears after a
              long command.  If such a program was output to a file the source
              code would be corrupt and the program would fail when read back
              in and executed later on.  The has now been corrected.

MAP           In some versions of Semper 6.3 the MAP command could wrongly
              establish the source picture range and produce incoreect
              results.  This has now been corrected.

OVWRITE       The OVWRITE can now correctly overlay images on a magnified or
              undersampled display picture.

PANEL         The PANEL command allows you to combine several actions.  If one
              of these actions is to destroy the panel (DESTROY option), there
              could still be some unprocessed actions which would be faulted
              if the panel has been destroyed.  The command has now been
              modified to ignore all unprocessed actions once the panel has
              been destroyed.

PCURVE        The choice of pixel coordinate axes that the PCURVE command used
              in the past to calculate pixel-based parameters resulted in the
              diagonal feret diameters being swapped round (variables AF and
              BF).  This has now been changed so that the command returns the
              correct feret diameters.  It also means that the pixel count now
              agrees with the result produced with the MASK command with the
              same curve data.

PEAKS         The PEAKS command could fail if no peaks are detected in the
              source image.  The code has been modified to avoid any further
              processing if the number of peaks is zero.

PEXTRACT      The selected particle should appear in the output picture with
              an extra layer of background pixels so that it does not touch
              any of the edges of the picture.  A fault in calculating the
              position of the particle meant that it was offset by one pixel
              in the X and the Y direction, which means that it was touching
              the bottom and right-hand edges of the output picture.  This
              has now been put right.

PHISTOGRAM    The option REPEATING was missing in the syntax definition
              (see the HISTOGRAM command for details).

POSTSCRIPT    In some versions of Semper 6.3 the POSTSCRIPT command could
              output an incorrect Postscript header.  This has now been put
              right.

RCF           Part of the code for the RCF command has been rewritten to
              avoid problems with numerical roundoff when summing data with
              a very large dynamic range.

REINITIALISE  Early versions of Semper 6.3 failed to request confirmation
              before deleting the contents of picture disc.  The header block
              was also incorrectly written which meant that any attempt to
              assign the picture disc, after it was deassigned, would be
              faulted.  Both of these faults have now been corrected.

              On systems running on a Silicon Graphics workstation, use of the
              LIST command to copy the contents of a program to a file (NAME
              key) would fail because the file was opened with the READONLY
              attribute set.  The has now been corrected.

RGB           When the RGB command was first introduced, the LUT key was not
              documented and was omitted from Semper's syntax file.  This has
              now been corrected.

RHISTOGRAM    The option REPEATING was missing in the syntax definition
              (see the HISTOGRAM command for details).

SAVE          The calculation to determine the size of the output file did not
              include the the size of the initial header block.  This could
              cause the SAVE command to fail under certain circumstances.  The
              size is now correctly calculated.

SKETCH        The SKETCH command returns the area of a closed input curve in
              the variable A.  A fault in calculating the area has now been
              corrected.

WP            The dependence on the FROM key has now been removed
              (see the DELETE command for details).

XCF           If the FROM and WITH keys in the XCF command point to the same
              picture, no attempt was made to transform the images and the
              result was incorrect.  This has now been put right.


OTHER CHANGES
=============

When an error was detected during Semper initialisation sequence it was
sometimes difficult to read the diagnostic messages describing the problem. On
systems running on Unix workstations, the last output line could be
overwritten by the Shell prompt.  On Sprynt and Xwindows displays, the
terminal window would disappear before you had the chance to read the
diagnostics messages.  Now last diagnostic message is followed by a blank line
and by a five second pause.

The following changes were made to deal with situations which could cause the
evaluation of an expression to fail when the ^ operator is used:

*   0^N for all values of N now returns 0.0
*   N^0 for non-zero values of N now returns 1.0
*   raising negative numbers to fractional powers is now faulted with error 99

Whenever the LIBRARY command was used to execute a Semper program, any
modified data in Semper's disc cache was written out to disc.  This could
cause a lot of unnecessary output to disc, especially when running programs
with many nested invocations of the LIBRARY command (such as the TUTOR
interface program).  The code for handling programs has been modified so that
only data associated with program libraries is written out to disc when the
LIBRARY command is used.

$add upgrade.fortran fortran environment
NEW ROUTINES
============

A total of 14 new Fortran routines have been added to provide support for the
following functions:

   *   conversion to/from the new bit-packed data format and efficient
       processing of bit-packed data
   *   access to a picture's range parameters
   *   enquiring Semper's interactive state
   *   processing text keys

Precise details about the operation of these new routines can be found in the
new manual pages for the Fortran Programmers' Guide.


PROCESSING BIT_PACKED BINARY DATA
=================================

A new data format for compressing binary data has been introduced in Semper
6.4.  The new routine BFORM carries out the conversion between the new data
format and the existing data forms: byte, integer, floating-point and complex.
A specification for the new data format can be found in the section entitled
Data Structures in the Fortran Programmers' Guide.  A further 9 routines
provide the necessary functions for processing bit-packed binary data in a
highly optimised way:

    BLOGIC    carry out Boolean operations between two bit-packed arrays
    BSHIFT    shift bit-packed array to left or right
    BDIFF     compare two bit-packed arrays
    BSCAN     return data range of bit-packed array
    BCLEAR    clear pixels (set to 0) in bit-packed array
    BSET      set pixels (set to 1) in bit-packed array
    BFILL     set pixels in bit-packed array to 0 or 1
    BREP      replicate pixels in bit-packed array
    BVALUE    return value of single pixel in bit-packed array


ACCESS TO A PICTURE'S RANGE PARAMETERS
======================================

The new routine SEMRNG provides the necessary operations to read, set and
delete a picture's range parameters.  SEMRNG completely replaces the routine
GETRNG and replaces most of the operations provided by the RANGE routine.


ENQURING SEMPER'S INTERACTIVE STATE
===================================

The following states may influence the behaviour of a procesing command:

   *   the UIF menu interface is running (UIF variable is set to 1)
   *   Semper is running in batch mode (BATCH variable is set to 1)
   *   Semper is executing a program (LIBRARY command)
   *   Semper is executing a run file (RUN command or startup run file)

The new routine SEMINT provides a convenient way to check for certain
combinations of these states.


PROCESSING TEXT KEYS
====================

Semper allows you to supply textual data to commands by means of text keys.
Access to this information at the Fortran level has been provided in the past
by the routine SEMKTX.  The new routine SEMTEX is a simplified version of
SEMKTX, without the prompt string argument or the flag to convert the text to
upper-case.  A further routine FILSTR has been introduced for getting hold of
file names by means of the NAME key.  FILSTR also provides support for the new
option AGAIN which allows the user to re-use the name of an input file without
having to specify the NAME key again.


NEW FACILITIES
==============

Semper's underlying Fortran system has been extended to provide a number of
significant new facilities:

   *   new row buffer declarations
   *   new Fortran parameters: NNBUF, LNSBUF, LNBYTE, FILMAX and MEDVM
   *   routines FT2D and INVFT2 have been recoded to support multi-radix
       FFT's and optimised use of Semper's row buffer array
   *   routine FSOVRW now supports efficient access to the display overlay
       plane in both directions (output used to be much slower than input)


NEW ROW BUFFER DECLARATIONS
===========================

The row buffer space is now declared as a single floating-point array in
Semper's COMMON block INCLUDE file:

      REAL RBS(1-LNEDGE:LNBUF/LNREAL+LNEDGE,NNBUF)
      COMMON /SEMBUF/ RBS

Note that the array has two dimensions and that both array subscripts can be
safely declared with type INTEGER.  The Fortran parameter NNBUF determines the
number of row buffers.  For PC systems runing MS-DOS, NNBUF is set to 6, but
on all other systems, the number of row buffers has been increased to 15.  The
size of row buffers, controled by the parameter LNBUF has also been increased.
The total size in bytes of the row buffer array RBS is provided as another
Fortran parameter LNSBUF.  Support for the existing row buffer arrays RB1 to
RB6 is maintained by means of the following Fortran equivalences:

      REAL RB1(LNBUF/LNREAL),RB2(LNBUF/LNREAL),RB3(LNBUF/LNREAL)
      REAL RB4(LNBUF/LNREAL),RB5(LNBUF/LNREAL),RB6(LNBUF/LNREAL)
C
      EQUIVALENCE (RB1,RBS(1,1)),(RB2,RBS(1,2)),(RB3,RBS(1,3))
      EQUIVALENCE (RB4,RBS(1,4)),(RB5,RBS(1,5)),(RB6,RBS(1,6))

Similar equivalences have been provided for the arrays RB1LHS to RB6LHS and
the arrays RB1RHS to RB6RHS.  Fortran compilers should generate equally
efficient code for references to RBS as for references to the old row buffer
arrays if RBS's second subscript is a constant.  The advantage with the new
array is that it allows you to address any row buffer (including any beyond
the first six buffers) and it can also address edge pixels directly.


NEW FORTRAN PARAMETERS
======================

Five new Fortran parameters have been added:

    NNBUF     number of row buffers
    LNSBUF    total size of the row buffer array RBS in bytes
    LNBYTE    size of byte storage unit in bytes (always equal to 1)
    FILMAX    maximum length for strings containing file names
    MEDVM     parameter associated with memory-based data storage devices

NNBUF and LNSBUF are described in the previous section.  LNBYTE is a new
parameter to complete the set of parameters which define the size of Semper's
data storage units: LNBYTE, LNINT, LNREAL and LNCOMP.  You should use FILMAX
for declaring arrays and character variables for storing file names.  MEDVM is
the value returned by the routine SEMMED for a memory-based device created
with the new ASSIGN MEMORY command.


NEW FFT CODE
============

The routines FT2D and INVFT2 have been recoded to use a multi-radix algorithm
for obtaining the forward and inverse Fourier transform of a picture.  This
means that the routines are no longer restricted to processing images whose
dimensions are a power of 2 (any dimensions which are "factorisable" can now
be transformed).  The command SHOW SIZES lists all the factorisable sizes.
The new code also makes optimum use of Semper's row buffer array.  The
increased size of the array means that much larger images in general can be
transformed. This factor combined with the multi-radix approach means that the
FFT code runs 20% to 100% faster.  For more details about the new FFT code
look in the section entitled NEW FFT code in Chapter 3 of this document.


FASTER OVERLAY OUTPUT
=====================

The overlay access routine as originally released could read overlay data much
faster than it could write it.  This was because there was no direct support
for outputting rows of pixels to the display overlay.  Instead FSOVRW emulated
the facility by erasing the row and drawing lines for each horizontal run of
pixels.  Direct support for outputting pixel data to the overlay has now been
provided and the speed of access is about the same for input and output.


CHANGES TO EXISTING FACILITIES
==============================

The changes to existing facilities which have been introduced in the 6.4
upgrade are briefly described here.  Most of the changes relate to specific
routines.  These are listed in alphabetical order by routine name. The
remaining changes are described at the end of this section.

FILMAK   Longer file names are now supported.  A file name may consist of
         three components: a name, optionally preceded by a directory path
         and followed by an optional extension.  The maximum lengths for
         these components is as follows:

             directory    130
             name          80
             extension     40

         This places an upper limit on the length of a file name which FILMAK
         can process of 250 characters.  Note that some operating systems may
         impose a lower limit on file names.

FILPAT   On systems not running on PC's, FILPAT can now handle a search path
         string of up to 1024 characters.  For PC systems, the limits remains
         at 255 characters (not that MS-DOS imposes a limit of 127 characters
         for the search path).

FILSEA   The changes described for the routines FILMAK and FILPAT also apply
         to FILSEA.

FT2D     The code for FT2D has been rewritten so the pictures with
         factorisable sizes can now be transformed.  The requirement for
         setting the variable IDERR has been dropped.

GETRNG   This routine has been superseded by the new routine SEMRNG.  Any
         calls to GETRNG can be replaced very simply by an equivalent call
         to SEMRNG, for example,

               IF (GETRNG(PMIN,PMAX)) RETURN

         could be replaced with

               IF (SEMRNG(1,PMIN,PMAX)) RETURN

         For backwards compatibility, the routine has been retained in
         Semper's object library.

INVFT2   The changes for the routine FT2D also apply to INVFT2.

MEANSD   The code for MEANSD has been rewritten to minimise the effects of
         numerical roundoff when accumulating the sume used to calculate the
         source picture's intensity mean and standard deviation.  The results
         obtained with the new code are generally more accurate and they do
         not require a second pass for ill-conditioned data.

SEMLAB   Thorough checks are now carried out by SEMLAB to detect any corrupt
         or invalid data in a picture label.  Error 149 is returned if an
         attempt is made to store a malformed picture label and error 147 or
         148 is returned if the picture label contains any invalid data.
         These checks should trap incorrectly formatted picture labels before
         they can cause serious problems elsewhere.

SEMLU    The code for SEMLU has been modified to give faster access to
         variables.  This has been achieved by keeping the variable table
         compressed at all times so that that unset entries are never scanned,
         and by arranging the table so that more frequently used variables
         tend to be scanned first.

SEMROW   SEMROW now validates the logical picture number.  It returns error
         165 if the logical picture number is outside the range 1 to NLPS and
         returns error 166 if the corresponding entry in the logical picture
         table is undefined.

The values of the following Fortran parameters have been increased:

    LNBUF   PC-DOS systems    8320 bytes
            other systems     32448 bytes

    NDVS    PC-DOS systems    10
            other systems     20

    NLPS    PC-DOS systems    10
            other systems     20

LNBUF defines the length of a row buffer in bytes.  NDVS and NLPS define the
size of the device table and logical picture table respectively.

Semper's syntax file contains implicit picture opening statements of the form
OPEN(...,OLD) or OPEN(...,NEW,...).  The keywords OLD and NEW specify whether
the command interpreter should open an existing picture or create a new
picture.  These statements used to be processed by the command interpreter in
the order in which they appeared in the syntax file.  The command interpreter
has now been modified so that all statements with the keyword OLD are executed
before any statements with the keyword NEW.  Error 145 is returned if two OPEN
statements use the same logical picture number, for example OPEN(LP1,OLD) and
OPEN(LP1,NEW).  Statements with the keyword NEW may optionally specify a
logical picture number to provide default parameters for the newly created
picture.  Error 146 is returned if this logical picture number does not refer
to a picture that is open, for example OPEN(LP2,NEW,LP1) where there is no
OPEN statement refering to LP1.

The Semper program generator SEMGEN has been modified to accept more keys and
options for each command.  The limit for the number of keys has been increased
from 30 to 41 and the limit for the number of options has been increased from
30 to 49.  Note that SEMGEN does not count keys and options referred to in
syntax routines.  This means that it is still possible to exceed these limits
when a command is executed, in which case the command will fail with error 84.


CORRECTIONS TO EXISTING ROUTINES
================================

FILDCD   The code for FILDCD has been corrected to deal with multiple file
         name extensions.  For example, the string xxx.yyy.zzz will now be
         split into xxx.yyy for the name component and .zzz for the extension,
         instead of xxx and .yyy.zzz respectively.

FILEXI   For PC systems running MS-DOS, FILEXI would fail to detect the
         existence of a file if the file name referred to a DOS device.  This
         prevented access to DOS devices by specifying the device name with
         the NAME key in commands such as HPLJ and POSTSCRIPT.  FILEXI now
         flags DOS device names in the same way as an existing file.

FSAMPL   Any sub-region with dimensions greater than 32000 should be faulted
         by FSAMPL with error 89.  This is to avoid an integer overflow when
         returning the sub-region size via FSAMPL's arguments NCOL and NROW.
         The test in the Y direction never used to work.  This has now been
         corrected.

FSOVRW   Several faults in FSOVRW have been corrected:

         *   output to magnified or undersampled display pictures were
             incorrectly scaled
         *   rounding of pixel coordinate values caused the output, in some
             places, to be offset by one pixel (now a binary image displayed
             in the image and the overlay plane will correspond exactly)
         *   FSOWRW now handles access to complex display pictures correctly,
             with proper note being taken of the general options RE and IM
             (for input, FSOVRW reads the real part unless the option IM is
             set, and for output, FSOVRW writes to both parts unless the
             option RE or IM is set)

FSROW    The corrections described for FSOVRW also apply to FSROW.

KLINE    KLINE looks for break and keyboard events.  However, it used to
         ignore button and pointer events which could allow the button and
         pointer queues to overflow if such events were enabled before KLINE
         was called.  KLINE now reads all events and discards button and
         pointer events.

KPRESS   KPRESS looks for break, keyboard and button events.  However, it
         used to ignore pointer events which could allow the pointer queue to
         overflow if such events were enabled before KPRESS was called.
         KPRESS now reads all events and discards pointer events.

KREAD    The corrections described for KPRESS also apply to KREAD.

SEMCLS   When data is output to a picture, a flag is set in the logical
         picture table to tell the command interpreter to delete the
         picture's range parameters in the picture label.  In this way, the
         operation can be carried out just once, at the end of a command.
         Calling SEMCLS deletes the picture's entry in the logical picture
         table, including the range delete flag.  This means that the range
         parameters in the picture label are not deleted when they should be
         and any subsequent call to SEMRNG to fetch the range parameters will
         return incorrect values.  SEMCLS has now been modified to delete the
         range parameters if required to, before it closes the picture.

SEMOPN   The code for SEMOPN has been modified to correct a number of faults:

         *   when opening a display picture, a magnified picture would be
             mistaken for an undersampled picture and faulted with error 33
         *   opening a temporary picture would fail if the directory of the
             first device to be examined was full (now all writeable picture
             devices are scanned before the request can fail)
         *   when opening a new picture which is a position list, a suitable
             default for the position list type is provided (if LPN is zero,
             the default type is 1, otherwise, the type is taken from the
             specified prototype picture)

SEMROW   When a processing command outputs directly to a complex display
         picture, SEMROW would only output the real part.  Now it outputs
         the results to the imaginary as well as the real part.

SEMWAI   Wait times between about 29000 and 32000 used to cause an integer
         overflow error (wait times in excess of 32000 were truncated anyway).
         Now SEMWAI limits wait times to 29000 to avoid this problem.  A wait
         time of 29000 seconds is just longer than 8 hours.
$add upgrade.645 new commands
Release 6.45 of Semper incorporates several corrections and fixes. It also
introduces three new commands on all systems and adds a number of new local
commands on some systems.


NEW COMMANDS (6.45)
-------------------

   *   store additional information in picture labels  DATA
   *   calculate particle invariant moments            PMOMENT
   *   convert image to RGB using a colour map         COLOUR
   *   ability to invoke an external Unix command      UNIX

NEW FEATURES FOR EXISTING FACILITIES (6.45)
-------------------------------------------
   *   support for TrueColour visuals added            ASSIGN DISPLAY
   *   external font selection enabled
   *   when opening output files NEW option is not
       required for overwriting - user is prompted     WRITE etc.

   *   support for uncompressed TIFF files added       INPUT, OUTPUT
   *   support for uncompressed BitMap files added     INPUT, OUTPUT
   *   (unsupported) input for ACR NEMA files added    INPUT NEMA


CORRECTIONS TO EXISTING FACILITIES (6.45)
-----------------------------------------

   *   all references to direct tape support removed from systems that do not
       have Semper tape devices (e.g. REWIND command removed)
   *   memory buffer sometimes (albeit rarely) failed to flush on file close

COMMAND-SPECIFIC CHANGES (6.45)
-------------------------------

ADD           Blank line in input file could cause a garbage character to be
              added into the program. Not obvious until the program was run.

ASSIGN HELP   Help libraries are now assigned as WP

ASSIGN        Demo picture disks now correctly assigned

COVARIANCE    Restrictions on input picture size relaxed

INPUT RAW     SKIP now interpreted more accurately. Previously could be
              truncated to a lower value, causing file alignment problems.

LEARN         Restrictions on input picture size relaxed

PCT           Restrictions on input picture size relaxed

SAVE          Incorrect calculation of file size for huge images fixed.


WRITE         Output file is always closed (previously left open until
              next file access, preventing file from being input into
              other packages),
$add stop.press upgrade unix framestore overlay password
In porting Semper 6.4 to Sun, Silicon Graphics and Hewlett-Packard
workstations, the following improvements and extensions have been made:


Multiple passwords
------------------

The password file "semper.pwd" can now record up to 8 different passwords.
This means that on installations where Semper is licensed to run on several
workstations connected to a networked file server, Semper need only be
installed once on the file server, and the appropriate passwords entered in
the one copy of the password file.  It should then be possible to run Semper
on any machine with access to the Semper executable on the file server, as
long as the password for that particular workstation is present in the
password file.


Executing Unix commands
-----------------------

The new UNIX command allows you to execute non-interactive Unix commands in a
C shell during a Semper session.  This is particularly useful in Semper
programs where there used to be no way in which Unix commands could be
executed (for example, to send a PostScript file to the printer).


X Windows display
-----------------

The following improvements have been made to Semper display under X Windows:

(1)  Full support for GrayScale, PseudoColor and TrueColor visuals has been
     provided.  Until now, the display code would only work with a PseudoColor
     visual with a depth of 8 bits or less for the default visual.  Now the
     PseudoColor visual with the greatest depth is used, or failing that the
     GrayScale visual with the greatest depth is used (the minimum acceptable
     depth is 6 bits).  If the depth of the selected visual is more than 8
     bits, the display window will handle the maximum 256 colours that Semper
     can store and display.  If you set the FRAMES key in the ASSIGN DISPLAY
     command to 3 and a 24-bit TrueColor visual is supported, you will then be
     able to display three-layer full colour images.  Full colour look-up
     tables are also supported by repainting the display whenever the current
     look-up table changes.

     You should now be able to display images at a higher resolution than that
     supported by the workstation on which Semper is actually running.  You do
     this by setting the DISPLAY environment variable before starting up
     Semper, so that it points to a networked machine running an X server
     which supports the necessary visuals.

(2)  The display now supports 8 independent overlays, each with its own colour
     and visibility.  The overlays are numbered from 1 to 8 and where overlay
     data is overlapped, the highest numbered overlay will be displayed.  You
     use the OVERLAY command to control the overlay settings and to control
     which overlays are used to display graphical output, rubberband lines and
     the cursor.  The command also lists the current overlay settings if the
     SHOW option is set.


Erasing overlays
----------------

The ERASE option has been added to the OVERLAY command so that any specified
overlay can be cleared, regardless of which overlay is currently selected for
graphical output.  This is in contrast to the ERASE command which can only
clear the graphics overlay.
$add user.command user prototype Fortran routine
The command USER is provided to help you to incorporate your own Fortran
modules into Semper as new commands.  The command as supplied does nothing,
but it is included to show you where user routines sit within Semper and how
they are compiled and linked into the system.

For a detailed description of how to write your own commands for including
into Semper, you should consult the Semper 6 Fortran Programmer's Guide.

See also: user.syntax
$add user.syntax
Keys:
  .......        none

Options:
  .......        none

Variables set:
  .......        none

Variables set:
  .......        none

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add view.command view
VIEW allows you to select the region of display memory presented on the
viewing monitor screen, the zoom factor, and the look-up table used (which
determines whether images are displayed in monochrome, false colour or full
colour).  It also allows you to switch between several views in succession.
Note that most processing commands support the use of the VIEW option if the
output picture is a display picture, in which case, the VIEW option will cause
the output picture to be brought into view on the display monitor.

Exx: VIEW ZOOM 8 PAN X,Y
       views position X,Y of picture DISPLAY at 8 times normal magnification
     VIEW PARTITION DIS:5 LUT 2
       views partition DIS:5 with lut number 2
     VIEW DIS:3,DIS:4
       views pictures DIS:3 and DIS:4 five times in alternation, switching
       between the two at one second intervals
     LUT 3 CREATE COLOUR; VIEW DIS:5 LUT 3
       views picture DIS:5 (and the corresponding parts of the two succeeding
       frames) in the full colour mode; use option FALSE for false colour
     VIEW FRAME 3 TOP RIGHT
       views the top right of frame 3 (frame CFRAME if you omit the number,
       and lut CLUT)
     VIEW ENQUIRE
       returns current viewing parameters in variables F,Z,X1,X2,Y1 and Y2
$
VIEW (and LUT) never alter display picture data as stored or as seen by
Semper; merely how they are presented on the screen.

How much of VIEW is implemented in a given installation depends of course on
the local hardware capabilities, and some details are in any case determined
by choices made at the time of installation .  Ideally, the region requested
is presented centrally and the rest of the screen is blanked, but you may find
that your installation views without blanking, 'wraps round' at frame
boundaries, or does not always centre the view as requested. HELP INSTALLATION
may give some information; otherwise, just experiment.

The graphics mode selected (picture, partition or frame - see GRAPHICS)
determines the blanking limits, and what is centred on the screen in default
(the appropriate coordinate origin).  You can move the centre if you wish via
the key PAN (as in the 2nd example), which 'pans' the monitor to the specified
position (in the appropriate coordinate system).

Alternatively, you can specify what you want to see via the standard 2-D
subregion keys/opts - still with respect to the appropriate coordinate system,
and with the subregion size fixed by the monitor size (subdivided if ZOOM is
not 1); you can accordingly use the key POSITION as a synonym for PAN whenever
the region implied is not truncated at the picture/partition/frame boundary).

For complex display pictures, where the real and imaginary parts of the image
are displayed side by side, the view will normally be centred on the region
which includes both parts.  You can restrict the view to just the real or
imaginary part by specifying the option RE or IM.

When viewing displays in rotation (you can request up to nine, in picture,
partition or frame mode), you can alter the number of times the set is viewed
via the key TIMES and the number of seconds for which Semper waits on each
display via the key WAIT (in seconds), e.g. VIEW DIS:2,DIS:3 TIMES 3 WAIT 2.
You can list up to nine pictures for successive viewing in this way.

If the CLIP option is set and the display hardware has the facility, then any
part of the display which lies outside the picture, partition or frame border
will be blanked out.

If the ENQUIRE option is set, the current view parameters: the number of the
frame currently in view, the zoom factor and the extent of the viewable area
in the specified coordinate frame (PICTURE,PARTITION,FRAME option) are
returned in the Semper variables F, Z, X1, X2, Y1 and Y2.

See also: view.syntax
$add view.syntax
Keys:
  [(9)]          picture, partition or frame to be viewed, or list of them
                 to be viewed in turn
  LUT            lut to be used for viewing [partition default in picture or
                 partition mode; else CLUT]
  ZOOM           (integral) zoom factor for viewing [1]
  TIMES          number of viewing cycles in rotating view mode [5]
  WAIT           time for which each view is presented in rotating view mode,
                 in seconds [1]
  SIZE(2)        dimensions of subregion to be viewed; blanking limits where
                 hardware permits [whole]
  POSITION(2)    position/offset of subregion [0,0]
  PAN(2)         position presented at centre of monitor screen (independent
                 of POSITION) [0,0 or centre of subregion if SIZE/POSITION
                 keys used]

Options:
  PICTURE | PARTITION | FRAME  view picture, partition or frame [PICTURE]
  LEFT | RIGHT   view subregion abutting indicated border
  BOTTOM | TOP
  CLIP           blank out view beyond picture/partition/frame border
  ENQUIRE        return current view parameters in variables F,Z,X1,X2,Y1,Y2
  RE | IM        centre view on real or imaginary part of complex display
                 picture [centre view on both parts]

Variables set:
  F              frame number of frame currently in view
  Z              zoom factor
  X1,X2          X limits of view
  Y1,Y2          Y limits of view

See SUBREGIONS for more details of subregion keys/options.

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add wait.command wait
You can make Semper wait for fixed times, or until you press a key or mouse
button, with the WAIT command.

Exx: WAIT 5
       waits 5 seconds
     WAIT
       types an prompt message and waits until you press a key or mouse button


A zero wait time ia allowed and causes the WAIT command to return immediately.
This allows you to control waits in a program by using a variable to specify
the wait time, for example,

     WAIT DELAY

If the DELAY is set to zero, the WAIT command does nothing.

Negative wait times cause the WAIT command to output a prompt message and
pause until a key or mouse button is pressed.

See also: wait.syntax
$add wait.syntax
Key:
  [FOR]          time delay in seconds - if less than zero, output prompt
                 message and wait for key or mouse button to be pressed [-1]

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add walsh.command walsh hadamard
You use WALSH to calculated Walsh/Hadamard transforms of pictures.  These are
decompositions into square wave rather than sinusoidal components.  Unlike the
Fourier transform, a Walsh transform is real if the source picture is real.
Walsh transforms have been used for data compression, texture classification,
etc.  You recover the original image by performing the inverse transform with
the IMAGE command.

Ex: WALSH 1 4
      places the Walsh transform of picture 1 in picture 4
$
The output form is Complex if the source is Complex, and Fp otherwise.

The transform would be described as 'sequency-ordered', with the origins
central in both planes irrespective of any different origins recorded.  The
output cannot be sent directly to the display (WALSH TO DISPLAY) because of
incompatible ranges used during intermediate stages of the transform
calculation.
                         Restrictions: image sizes must be powers of two
                                     : unsuitable for direct output to display
                 Multi-layer pictures: faulted
                Forms used internally: fp,complex

See also: walsh.syntax, image
$add walsh.syntax
Keys:
  [FROM]         source picture [SELECT]
  [TO]           output picture [FROM]

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add warp.command warp geometric.correction correction
The WARP command geometrically corrects a picture using an specified order
polynomial mapping function.

Exx: WARP 2 3 MAP 4 IMAGE 5
       resamples picture 2 to picture 3 using map control points in picture 4
       and image control points in picture 5
     WARP 2 3 MAP 4 IMAGE 5 BICUBIC ORDER 2
       as above but uses a second order polynomial and resamples using bicubic
       interpolation
     WARP 2 3 MAP 4 IMAGE 5 POSITION 120.,100. SIZE 64 STRIDE 10.
       resamples picture 3 to picture 3 using nearest neighbour sampling with
       controls points obtained from pictures 4 and 5 and an output size of
       64 by 64 pixels, covering an area ranging from 120.0 to 760.0 in X and
       100.0 to 740.0 in Y (sampling points are 10.0 units apart)
$
The source picture is warped using a polynomial mapping function, the
coefficients of which are calculated from the control points using the method
of least squares.  The control points for the source and reference images are
contained in two position list pictures (plists) which you specify with the
IMAGE and MAP keys respectively and which must contain the same number of
points.  The maximum order of polynomial is at least 3 but may be more,
depending on the length of a Semper row buffer.  The maximum number of control
points that the WARP command can cope with also depends on the row buffer
size.  If there are not enough control points, it may not be possible to solve
the equations for determining the coefficients of the polynomial function, or
the equations may be ill-conditioned.

By default, the output data values are obtained using nearest neighbour
sampling. With the options BILINEAR or BICUBIC you can select bilinear or
bicubic interpolation instead. The LAYER key specifies the layer of the source
picture to be resampled.  By default, all all layers of the source picture are
processed.

The dimensions of the output picture is given by the SIZE key, and it defaults
to the size of the source picture.  The position of the bottom left output
pixel with respect to the reference image (map space) is given by the POSITION
key with a default position of (0,0).  The STRIDE key specifies a sampling
interval in map space (default value is 1.0).

The VERIFY option causes the registration accuracy to be listed on the
console.  The listing consists of the control points and their calculated
position as compared with their given position together with the error in the
X and Y directions.

The ERRMAX key gives the maximum displacement allowed between a control point
and its calculated position.  If any point is found to exceed this value then
the point is dropped and the coefficients are re-calculated.  If not enough
points remain the command will terminate.  The process will be repeated until
all points are within the required accuracy or not enough points remain (in
which case the command will terminate with an error).  If the VERIFY option
has been specified then the accuracy information will be listed for each
cycle.

1st order polynomial:

        u = a0 + a1.x + a2.y
        v = b0 + b1.x + b2.y

2nd order polynomial:

        u = a0 + a1.x + a2.y + a3.x.x + a4.x.y + a5.y.y
        v = b0 + b1.x + b2.y + b3.x.x + b4.x.y + b5.y.y

(u, v) uncorrected image coordinates
(x, y) map (reference) coordinates

See also: warp.syntax
$add warp.syntax
Keys:
  [FROM]         source picture [SELECT]
  [TO]           ouptut picture [FROM]
  IMAGE          plist containing image control points [none]
  MAP            plist containing control points for reference image [none]
  ORDER          order of polynomial mapping function [1]
  LAYER          source picture layer to resample [all layers]
  SIZE(2)        size of output picture [source picture size]
  POSITION(2)    position of bottom left output pixel in map image space [0,0]
  STRIDE         sampling interval in map space [1.0]
  ERRMAX         maximum error for control points [infinite]

Options:
  BILINEAR | BICUBIC  generate output values using bilinear or bicubic
                 interpolation [use nearest neighbour sampling]
  VERIFY         list the results of each stage for calculating coefficients
                 of polynomial mapping function

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add weight.command weight radial section
You use WEIGHT to multiply a picture by, or add to it, an arbitrary function
of distance from a given point (a 'radial' function) supplied in a 1-D
picture.  If you want to multiply by a function with a simple mathematical
form, used CALCULATE instead.

Exx: WEIGHT 50 WITH 3 TO 51
       uses 1-D picture 3 to define a function of radius by which picture 50
       is multiplied to form picture 51
     WEIGHT 1 WITH 2 ADD
       adds to picture 1 the radial function defined in 1-D picture 2
     FOURIER 1 2; PS TO 3; SECTION; DISPLAY; XWIRES GRAPH TO 4
     WEIGHT 2 WITH 4; IMAGE
       applies a hand-drawn Fourier transform filter to picture 1
$
The centre of the radial function is positioned at the origin of the source
picture, or it can be positioned relative to the origin by using the POSITION
key.

The WITH key specifies a 1-D picture which defines the function of radius. The
pixel value at the origin defines the function value at zero radius.  Function
values for positive radii are obtained by linear interpolation between pixels
to the right of the origin.  If the radius exceeds the righthand limit of the
picture, the rightmost pixel value is used.

If you specify the ADD option, instead of the default MULTIPLY option, the
radial function is added to the source data instead of being multiplied with
the source data.
                                                 Multi-layer pictures: faulted
                                                Forms used internally: complex

See also: weight.syntax, calculate
$add weight.syntax
Keys:
  [FROM]         source picture [SELECT]
  [TO]           output picture [FROM]
  WITH           1-D picture containing function to be applied [999]
  POSITION(2)    position of centre for radial function [0,0]

Options:
  ADD | MULTIPLY   add/multiply the radial function [MULTIPLY]

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add window.command window
You use WINDOW to apply a 'window array' Fourier transform filter that
retains only components close to a site of a predefined lattice; it allows you
to perform 'lattice averaging' of a noisy image of a periodic structure, by
filtering out Fourier components that do have the right periodicity.

Exx: U=20,5 V=3,18; WINDOW DISPLAY
       masks the display picture retaining only pixels near sites of the
       lattice defined by U,V; this is NOT in itself useful(!), but will show
       you clearly what WINDOW does
     WINDOW 50 TO 51 WIDTH .1 RADIUS 120
       masks picture 50 with windows whose sides are a fraction .1 of the
       corresponding lattice base vectors in length, also setting to zero any
       pixels more than 120 units from the origin
     FOURIER; MIN=0 MAX=1E8; PS TO DISPLAY; LIBRARY LATTICE
     WINDOW; IMAGE; DISPLAY
       performs a complete filtration process on the current picture (though
       you may need to adjust the display grey scale to suit your data); you
       indicate the lattice via the display cursor when you are prompted

You can apply WINDOW to full-plane and half-plane Fourier pictures.
$
The transform of an image of a periodic structure is localised near an array
of peaks arranged in a ('reciprocal') lattice, while the image noise is spread
throughout the transform; the image can therefore be improved substantially by
setting to zero all pixels that are not near a lattice site - which can be
seen as applying a mask consisting of an array of small windows centred on the
lattice sites.

The lattice is defined by base vectors U,U2 and V,V2; you can use the key
POSITION to move its origin if you want to.  The windows generated are in fact
parallelograms with sides .2 (or WIDTH) times the corresponding base vector
length.  Smaller windows filter more strongly, but are more likely to cause
artefacts if the base vectors are imperfectly known or the image is
imperfectly periodic, and in any case some signal distortion is likely if the
windows are smaller than 3 pixels wide.

The effect of the filter can also be seen as a local averaging of unit cells
in real space: transform windows of width 1/n correspond roughly to averaging
the image over regions n cells wide.  For alternative ways of effecting the
average, see LATTICE, MOTIF etc.

If you need to interchange real and reciprocal lattice base vectors, using the
program LIBRARY RECIPROCAL.
                                                 Multi-layer pictures: faulted
                                                 Form used internally: complex

See also: window.syntax, lattice, motif
$add window.syntax
Keys:
  [FROM]         source picture [SELECT]
  [TO]           output picture [FROM]
  POSITION(2)    lattice origin [0,0]
  WIDTH          width, in lattice coordinates, of regions retained around
                 each lattice site [.2]
  RADIUS         maximum radius of lattice sites retained [infinite]

Options:
  VERIFY         list on the console the components of the lattice vectors

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add wp.command wp write protect
You write-protect pictures with WP or WP ON, and remove write-protection with
WP OFF.

Exx: WP 40
       protects picture 40 against subsequent deletion or alteration
     WP ON 100,200
       protects all pictures in the range 100 to 200 on the current device CD
     WP OFF 4:3,4:5
       removes the protection from pictures 4:3 to 4:5

See also: wp.syntax
$add wp.syntax
Keys:
  [(2)]          picture or range of pictures whose write-protection state is
                 to be set [SELECT,SELECT]

Options:
  ON | OFF       turn write-protection on or off [ON]

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add write.command write
You use WRITE to output pictures to files independent of Semper, for transfer
to other programs or other machines, or possibly for archive purposes (though
SAVE will be found to faster and more convenient for this purpose).  Use the
READ command to recover files output by the WRITE command.

Exx: N = 23; WRITE N NAME 'sec',N
       writes picture 23 to a file named "sec23.dat"
     WRITE FORMAT '(10F8.2)' NAME 'scantransform'
       writes the current picture in 10F8.2 format
     WRITE UNFORMATTED
       prompts for a file name at the terminal, and writes it using Fortran
       unformatted output
     WRITE SCR:12 UNLABELLED NEW NAME 'TOXYZ.DAT'
       writes picture 12 from device 'SCR' to a new file named "TOXYZ.DAT"
       with no picture label
$
In the absence of the UNFORMATTED option, a Fortran formatted file is output.
This a readable text file which should allow you to transfer picture data to
virtually any system.  You specify the Fortran format string for writing the
picture data with the FORMAT key.  The default format strings for byte,
integer, fp and complex pictures respectively are "(1X,24I3)" for byte
pictures, "(1X,12I6)" for integer pictures, and "(1X,1P6E12.6)" for fp and
complex pictures.

If the UNFORMATTED option is specified, the file is written using Fortran
unformatted output and it is essential that the UNFORMATTED option is used
when reading the file with the READ command.  Unformatted files are faster to
read and write and are usually more compact but it is most unlikely that they
can be read by Fortran programs on different systems.

Normally the contents of the picture label are output to the file.  Specifying
the UNLABELLED option will cause the READ command to omit this information.

The default file extension for unformatted files is ".unf" and for formatted
files is ".dat".

A precise description of the file formats supported by the READ and WRITE
commands is to be found in the separate document entitled

    Semper 6 READ/WRITE file format

This document can be obtain on request from Synoptics.

WRITE will complain if the output file already exists.  Use the option NEW
if you want to overwrite an existing file.

                                    Multi-layer pictures: fully supported
                                   Forms used internally: integer,fp,complex

See also: write.syntax, read, save
$add write.syntax
Keys:
  [FROM]         source picture [SELECT]
  NAME text      name of file to contain picture data [none; prompts if
                 interactive]
  FORMAT text    Fortran format string for writing each picture row [depends
                 on data form; "(1X,24I3)" if byte, "(1X,12I6)" if integer and
                 "(1X,1P6E12.6)" if fp or complex]

Options:
  NEW            overwrite an existing output file
  UNFORMATTED    write using Fortran unformatted output [use Fortran formatted
                 output]
  UNLABELLED     do not write picture label information

The FORMAT key and the UNFORMATTED option may not be present at the same time
in the WRITE command.

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add xcf.command xcf
You use XCF to calculate cross-correlation functions between pairs of
pictures; these allow you to find a lateral shift needed to align (register)
the pictures, to locate motifs occurring at many places in a picture, to
detect features buried in high noise levels, and to measure signal-to-noise
ratios.  The output picture is class Correlation, form Fp.

Exx: XCF 1 WITH 2 TO 3; EXTRACT 2 TO 3 @XY
       calculates the xcf of pictures 1 and 2 in picture 3 (class Correln),
       and produces a shifted version of picture 2 in register with picture 1
     XCF 1 WITH 2; TYPE X,Y,T,ROOT(T/(1-T))
       replaces picture 1 with the xcf between 1 and 2, and reports the
       correlation peak position and height, and the signal to noise ratio on
       the assumption that they are identical apart from noise
     FOURIER 1; XCF 2 WITH 1; CUT 2 SIZE 400 @XY
                XCF 3 WITH 1; CUT 3 SIZE 400 @XY
                XCF 4 WITH 1; CUT 4 SIZE 400 @XY    [and so on..]
       produces subregions from pictures 2,3,4.. in turn that are in register
       with picture 1
     CREATE 1 SIZE 512; PASTE 2; MASK RADIUS 35; XCF WITH 3 NOSEARCH
       produces a correlation map showing positions in a 512 square picture 3
       that match a radius 35 motif in picture 2
$
The dimensions of the two source pictures must be compatible (the resulting
Fourier transforms must have the same dimensions).  Also, the X and Y
dimensions of the source images must be a multiple of 4 and factorisable (no
factors other than 2, 3, 4 or 5).  The command SHOW SIZES lists all the
factorisable sizes.  If a source image is a half-plane Fourier image, the size
restriction is applied with respect to the dimensions of the image used to
generate the Fourier transform.

The xcf of a picture f with a picture w is a map of w showing how well f
matches w when its centre is shifted to the position being mapped; if f and w
are similar apart from a relative displacement, the xcf contains a single
strong peak the position of which identifies the displacement; alternatively,
if w contains many copies of a motif at the centre of f, the xcf has local
peaks marking the position of each such copy.

Unless you force SEARCH to NO as in the last example, XCF also calls FIND to
locate the highest correlation peak - once searching the whole picture, during
which the FIND option LOWEST restricts the search to positive peaks; and then,
if RADIUS is set, a second time to find a local centre-of-mass around the
peak, with the other FIND options also being honoured.

In more detail, the form of the normalised xcf calculated by XCF F WITH W is:
  xcf(x') = { <f(x)w(x-x')> - <f><w> } / root{ (<f^2>-<f>^2)(<w^2>-<w>^2) }
where <..> denotes an average over the whole picture.  The normalisation makes
the result independent of the grey-scaling of the two pictures (unchanged by
constant addition, subtraction, multiplication or division).  It lies in the
range -1 to 1, taking values near zero when there is little agreement between
the pictures, near 1 when the pictures agree closely, and near -1 when they
agree closely but with opposite contrast.  In general, correlation functions
are remarkably powerful at detecting a match in the presence of noise
(correlating images n points square detects a common signal buried in noise
with a level root(n)/2 times that of the signal); and substantial differences
in imaging conditions between f and w do not usually prevent a match from
being found.

To calculate the cross average, Semper transforms both source pictures in
general (FROM to TO, and WITH to VIA, which defaults to 999), and then
multiplies the conjugate of the first transform by the second before inverse
transforming the product.  You can offer XCF pictures already transformed
(Fouriers instead of Images) if you wish, and the calculation is simply picked
up at the appropriate point; this allows you to include additional filters to
manipulate xcf peak shapes and/or noise levels if you wish, and is also useful
if you are aligning several pictures in turn with a reference picture, since
you need only transform the reference once.

If the images are not correctly registered, correlation levels are reduced in
proportion to fraction of the image area that is common to both images; if
this matters (e.g. because you are using the peak height to deduce the signal-
to-noise ratio as in the 2nd example), you can correct the height before
proceeding by a sequence such as
   XCF..; PCB; T = T * NCOLS/(NCOLS-MOD(X)) * NROWS/(NROWS-MOD(Y))

Warning: when discrete transform methods are used as here to calculate xcfs,
the Images correlated and the Correln produced are both treated as if repeated
periodically in both directions.  This means that features shifted off one
edge of an Image reappear at the opposite edge, and may give rise to spurious
correlation; also, if the Images are mis-registered by more than half the
field of view, the Correln peak which should be displaced off one edge of the
picture in fact re-appears at the opposite edge in a spurious position - if in
doubt, align a larger area in the first instance, more coarsely sampled if
necessary.

If the MARK key is set, the cross-correlation peak position and the circular
region searched for the peaks centre of mass (only if the RADIUS key is set)
are marked on the indicated display picture.
                         Restrictions: image sizes must be powers of two
                                     : unsuitable for direct output to display
                      Display marking: peak position, region searched for c.m.
                 Multi-layer pictures: faulted
                Forms used internally: fp (complex in transforms);

See also: xcf.syntax, show
$add xcf.syntax
Keys:
  [FROM]         first source picture [SELECT]
  [TO]           output picture [FROM]
  WITH           second source picture [none]
  VIA            intermediate picture receiving Fourier transform of WITH
                 if this is calculated [999]
  RADIUS         if SEARCH, radius around peak over which a local centre-of-
                 mass is calculated to replace the raw peak position [none]
  MARK           display to be marked with cross-correlation peak position and
                 region searched for centre of mass (if RADIUS key set) [none]
  MKMODE         mark mode [1]
  MKSIZE         mark size [2]

Options:
  SEARCH         search x.c.f. for peak, returning position as X,Y [YES]
  LOWEST         if SEARCH, locate lowest rather than highest point
  NEGATIVE       if SEARCH and RADIUS, include negative pixels in c.m. search
                 [YES]
  SQUARED        if SEARCH and RADIUS, find c.m. of squared pixels
  ITERATED       if SEARCH and RADIUS, repeat the c.m. location once, with a
                 region shifted to be centred at the c.m. found initially
  VERIFY         list the cross-correlation results on the console

Variables set:
  X,Y            position of x.c.f. peak found
  T              height (or mass if RADIUS) of x.c.f. peak found

Options NEGATIVE, SQUARED and ITERATED are relevant only in the centre of mass
mode, i.e. when RADIUS is set.

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add assign.display.command assign.display assign X framestore display window
You use the ASSIGN DISPLAY command to create a display window for displaying
images.  The display window emulates the functioning of a framestore: storing
image data in the framestore causes the image to be displayed on the screen.
The colours and intensities used to display images are determined by a display
look-up table.  There is also support for a number of overlays for displaying
graphical data, a cursor and rubberband lines on top of images.  The size of
the framestore is specified with the SIZE and FRAMES keys.  Use the command
DEASSIGN DISPLAY to destroy the display window.

Exx:  ASSIGN DISPLAY
        create a false colour display window with the default size of
        768 by 512 pixels
      ASSIGN DISPLAY SIZE 400 POSITION 0,0
        create a display window with size 400 by 400 pixels, positioned at
        the top left-hand corner of the screen
      ASSIGN DISPLAY FRAMES 3
        create a display window with 3 frames for displaying full colour
        images (if the X server supports this)
$
The ASSIGN DISPLAY command assigns the display device to emulate a framestore
with a frame size given by the SIZE key and the number of frames given by the
FRAMES key.  If the SIZE key is omitted, the frame size defaults to 768 by 512
pixels.  If the Y dimension is omitted, it defaults to the X dimension.  The
largest frame size allowed is 16384 by 16384 pixels.  The initial size of the
display window is limited to three-quarters of the screen dimensions.  The
display window may be repositioned at any time and resized within the limits
imposed by the screen and the window manager.  The initial position of the
display window may be specified with the POSITION key (the default is to
position the window at the top left-hand corner of the screen).  If the window
manager allows it, the window will be positioned as specified.  Failing that,
the window will have to be manually positioned.

If the display window is not large enough to display the entire frame, the
view position can be altered with the VIEW command.  The view position is the
frame position which appears at the centre of the display window.  The default
for the view poistion is the centre of the frame.  The XWIRES command also
provides the facility (enabled by pressing the V key) to make the view
position track the movement of the cursor.  This allows you to roam freely
around a very large frame.

Image data associated with each display frame and overlay data is separately
stored in memory buffers so that the information can always be accessed,
regardless of the visibility of the displayed image.  The image data is stored
with a maximum resolution of 8 bits (256 levels): the actual resolution
depends on the depth of any PseudoColor and GrayScale visuals supported by the
X server (use the X command "xdpyinfo" to list the supported visuals).  The
minimum suitable depth is 6 bits.  The PseudoColor visual with the greatest
depth is used in preference to the GrayScale visual with the greatest depth.
If no suitable visuals are supported, the ASSIGN command will fail.  If the
depth of the selected visual is greater than 8 bits, the full 256 levels of
image data can be stored and displayed.  The number of display levels (which
is equal to the look-up table size) is listed by the SHOW SYSTEM command and
returned in the variable LSIZE by the command LUT ENQUIRE.

The FRAMES key determines the number of display frames.  The only acceptable
values are 1 (the default) and 3.  You can display monochrome and false colour
images with a single frame.  In order to display full colour images (RGB
pictures with three layers), you must assign three display frames.  The X
server must support a 24-bit TrueColor visual for this to succeed.  Full
colour look-up tables are supported by repainting the display window whenever
changes are made to the current look-up table (the variable CLUT records the
current look-up table number).  You will also have to create a partition with
3 frames in order to display RGB images, for example,

    ASSIGN DISPLAY FRAMES 3
    PARTITION 1 FRAMES 1,3
    DISPLAY 2:1 TO DIS:1

The resolution for each component of a full colour image (the number of levels
and the look-up table size) is the same as for a false colour image.

A total of 8 overlays are supported.  You can control the visibility and
colour of overlays with the OVERLAY command.  The overlays are numbered from 1
to 8 and where overlay data overlaps, the highest numbered overlay is
displayed.  Cursor and rubberbanding functions are carried out using one
overlay each.  Different overlays must be used for displaying graphics, cursor
and rubberbanding.  The display window is repainted whenever an overlay is
turned on of off and when the colour of an overlay for a full colour display
changes.

Interactive input is possible when the display window (or any other window
created by Semper) has input focus.  If during a command which tracks the
pointer (for example, LADJUST), the pointer leaves the window, no further
tracking will take place until it rejoins the window.  Since pointer movement
is handled incrementally, you can obtain more movement than the window allows
by circling the pointer around the outside of the window and dragging it
across the window in the same direction as before.

When image or graphics data is output by a Semper command it is immediately
stored in the memory buffers associated with the display window.  By default,
the display window is updated less often than the memory buffers in order to
reduce the overhead in communicating with the X server.  The rate at which the
display window is updated is controlled with the X11 command.

See also: assign.display.syntax, deassign, overlay, x11, lut, ladjust, view,
          show
$add assign.display.syntax
Keys:
  SIZE(2)        frame size in pixels [768,512]
  FRAMES         number of frames [1]
  POSITION       initial position of the top left-hand corner of the window
                 with respect to the top left-hand of the screen [0,0]

Options:
  DISPLAY        assign the display device

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add x11.command x11 X refresh window
You use the X11 command to control the rate at which the server display is
updated from the client (Semper host) machine.

Exx:
     X11 ILIMIT 8
        refresh after every eight image writes (the default)

     X11 VLIMIT 0
        refresh vectors and annotation only at the end of display operations
        or on display flush (the default)

     X11 VLIMIT 1 ILIMIT 1
        refresh on every operation
$
In order to maintain a non-destructive overlay, Semper maintains seperate
copies of the contents of the display and overlay and uses them to update the
visible areas of the window on the server.

To keep the display up to date after every operation involves an additional
processing time overhead of about 80% (images) and up to 10000% (annotation).
To reduce this overhead Semper delays writing to the server until one of the
following occurs:

(a) the number of operations exceeds the appropriate threshold

(b) Semper requires a display flush or display close

(c) the server requests a refresh (e.g. on exposing the window)

(d) the internal table of updates overflows

The X11 command allows the user to set the refresh thresholds or to turn off
the threshold mechanism.  This allows the user to trade off interactive
display rate against processor time.  The default thresholds are generally
acceptable for normal monitoring purposes.  Turning off the display refresh
threshold will give the impression of very fast display update when the image
is completed.  The annotation refresh threshold is turned off by default, so
complex annotation (e.g. YMOD plots) appears to be painted in bands from top
to bottom.  If you require a more conventional appearance use a VLIMIT of
(say) 8, but be prepared to wait for the results.

See also: X11.syntax
$add X11.syntax
Keys:
  ILIMIT      Sets the image refresh threshold. A positive value specifies the
              threshold. A zero or negative value turns off the threshold
              refresh. (Image only appears when complete).

  VLIMIT      Sets the vector/annotation refresh threshold. A positive value
              specifies the threshold. A zero or negative value turns off the
              threshold refresh. (Annotation only appears when complete).

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add xwires.command xwires cursor mouse tablet
XWIRES allows you input positions, directions, curves etc. directly on the
display device, for use in subsequent commands.

Exx: XWIRES; PRINT @XY
       prints a block of pixel values around the point you mark
     XWIRES SECTION; EXTRACT @SECTION TO 999; DISPLAY
       extracts line scan between two points you mark
     XWIRES DIS:4 REGION; CUT @REGION
       cuts out rectangular region for which you mark a pair of opposite
       corners on DIS:4
     XWIRES CLOSED CURVE TO 51; TYPE P,A; MASK WITH 51
       (with a 2-D display picture) types the perimeter and area of a region
       you draw round, and masks the current picture outside this region

With no options set, XWIRES simply returns the coordinates of the point you
mark in variables X and Y.  Details of the alternative modes are given in
separate files (HELP XWIRES. types them all).  If you specify the VIEW option,
XWIRES will make visible the part of the display you want to point to.
$
In default, XWIRES works on DISPLAY, in picture coordinate mode; however, you
can also use it in PARTITION or FRAME mode -

      e.g., XWIRES PARTITION DIS:7 (see HELP GRAPHICS).

You can control the form of the marks verifying all but the last position, if
you want to, via MKMODE and MKSIZE; you can also prevent any verification at
all by forcing option VERIFY to NO.  In some installations, you can control
where the display cursor first appears set its initial position via the key
POSITION, e.g. XWIRES POSITION 10,20 or XWIRES @XY; if this position is
outside the frame limits, the cursor appears centrally instead.

On complex display pictures, where the real and imaginary parts of the image
are displayed side by side, the cursor normally operates with respect to the
real part of the image.  If, however, you specify the option IM, the cursor
will operate with respect to the imaginary part of the image.  By default, the
input data is verified by marking it on both the real and imaginary parts.  If
you specify the option RE or IM, verification is restricted to just the real
or imaginary part.

See also: xwires.graph, xwires.line, xwires.circle, xwires.arc

See also: xwires.region, xwires.section, xwires.list, xwires.curve

See also: xwires.syntax
$add xwires.syntax
Keys:
  []             picture/partition/frame number [DISPLAY if picture or
                 partition; CFRAME if frame]
  TO             if CURVE, LIST or GRAPH set, output picture [999]
  SIZE(2)        if REGION UV set, dimensions of skewed subregion [2,SIZE]
                 if CURVE or GRAPH set, number of sampling points to be used
                 along curve or graph [actual length]
  SAMPLING       if REGION, CURVE or GRAPH, sampling interval [1 if REGION,
                 none if CURVE or GRAPH]
  POSITION(2)    position at which cursor first appears [0,0]
  MKMODE         mark mode [1]
  MKSIZE         mark size [2]

Options:
  PICTURE | PARTITION | FRAME   use indicated coordinate system [PICTURE]
  VERIFY         verify positions accepted on display [YES]
  LINE           set  X,Y,XN,YN,R,THETA from line marked
  CIRCLE         set X,Y,R from circle marked
  ARC            set X,Y,R,THETA-TH2 from circular arc marked
  SECTION        set X,Y,R(2) from 1-D subregion marked (same as REGION ONED)
  REGION         set X,Y,R(2) from subregion marked
  ONED           if REGION, accept 1-D subregion only and force R2=1
  ANGLED         if REGION, accept rotated subregion and set THETA too
  UV             if REGION, accept skewed subregion and set U(2),V(2) too
  LIST | CURVE   generate Plist of type given
  OPEN | CLOSED  if CURVE, type required [OPEN]
  GRAPH          generate 1-D picture from graph marked
  SYMMETRIC | ANTISYMMETRIC   if GRAPH, input symmetric/anti-symmetric data
                 from right-hand side of graph only [input entire graph]
  RE | IM        operate with respect to real or imaginary part of complex
                 display picture [operate with respect to real part]
                 if VERIFY set, verify input data on real or imaginary part of
                 complex display picture [verify input data on both parts]
  VIEW           switch view to make display region visible [NO]

Variables set:
  X,Y            start point of line, centre of arc/circle, centre of region
  XN,YN          end point of line
  R              length of line, radius of arc/circle, X/U dimension of region
  R2             Y/V dimension of region
  THETA          angle of line, angle of region, start angle of arc
  TH2            end angle of arc
  U,U2,V,V2      base vectors for skewed region
  P              length of curve
  A              area enclosed by closed curve

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add xwires.line
XWIRES LINE
  defines a line from first point marked (X,Y) to second (XN,YN); also returns
  length (R) and direction (ANGLE), in radians anticlockwise from +X axis; use
  with TYPE R or PROJECT ANGLE THETA or MASK @CIRCLE etc.
$add xwires.circle
XWIRES CIRCLE
  defines a circle passing through three points marked; returns centre (X,Y)
  and radius (R); use with MASK @CIRCLE etc.
$
XWIRES CIRCLE also sets THETA=0,2*PI, for what this is worth.
$add xwires.arc
XWIRES ARC
  defines a circular arc passing through three points marked, betwee first and
  last through second; returns centre (X,Y), radius (R), and angular range
  (THETA,TH2) in radians anticlockwise from +X axis (with TH2>THETA); use with
  SECTION @ARC etc.
$add xwires.section
XWIRES SECTION
  defines 1-D subregion along the line between two points marked; returns R2
as 1; use with EXTRACT @SECTION etc.; SAMPLING key available too
$add xwires.region
XWIRES REGION
  defines horizontal/vertical subregion via either pair or opposite corners;
  returns centre (X,Y) and size (R,R2); use with CUT @REGION etc.
XWIRES REGION SAMPLING .75; EXTRACT @REGION SAMPLING .75
  allows for a change of sampling interval (R,R2 is multiplied by 1/SAMPLING)
XWIRES REGION ONED
  defines 1-D subregion along the line between two points marked; returns R2
  as 1; use with EXTRACT @REGION etc.; SAMPLING key available too; equivalent
  to SECTION option.
XWIRES REGION ANGLED
  defines rotated rectangular subregion - use with EXTRACT @REGION ANGLE THETA
  etc; first two points define pair of opposite corners as above, and third
  defines direction (THETA) of new X axis wrt first point marked, in radians
  anticlockwise from +X axis; SAMPLING key available too
XWIRES REGION UV SIZE 50,30
  defines skewed (parallelogram) subregion - use with EXTRACT @REGION UV etc;
  first two points define pair of opposite corners as above; third and fourth
  define directions in which the sides leave first corner - these sides become
  the horizontal and vertical sides respectively after EXTRACTion, and are
  returned after division by (SIZE-1) and (SI2-1) as base vectors (U,U2) and
  (V,V2).  [SI2 defaults to SIZE, and SIZE to 2 - returning U,V as the
  parallelogram sides themselves.]
$
R,R2 are rounded to the nearest integer, and the region centre is adjusted
accordingly, preserving the first point marked exactly.
$add xwires.list
XWIRES LIST TO 51
  defines a list of positions marked and stores them as an output Plist
  picture 51 (default 999); the list is terminated by repeating the last
  point; use with MOTIF WITH 51 etc.
$add xwires.curve
XWIRES CURVE TO 51
  defines a curve linking positions marked, and stores them as an output Plist
  picture 51 (default 999); the curve is terminated by repeating the last
  point (open curve) or the first (closed curve); use with MASK WITH 51 etc.
XWIRES CURVE SIZE 123 TO 51
  defines a Plist curve with 123 equally spaced positions along straight line
  segments linking the positions actually marked
XWIRES CURVE SAMPLING .77 TO 51
  defines a Plist curve with positions spaced .77 pixels apart along straight
  line segments linking the positions actually marked
$
For curves drawn on 2-D displays, the perimeter or length is returned in
variable P.  If a curve is closed, the area is also returned in variable A.

SIZE and SAMPLING are mutually exclusive, for obvious reasons.

You can force a curve OPEN or CLOSED by quoting those options; OPEN stops the
curve terminating if you pass through (or very near to) the original point
again, and CLOSED allows you to terminate by repeating a point with the last
line segment being generated automatically to close the curve.
$add xwires.graph
Given a display in the form of a 1-D graph..
XWIRES GRAPH
  defines a function, drawn left to right, output as 1-D picture 999
XWIRES GRAPH TO 51 SYMMETRIC   [or ANTISYMMETRIC]
  defines a symmetric (or antisymmetric) function for which you draw only the
  right hand side
FOURIER 50; SECTION TO 51; DIS; XWIRES GRAPH SYMM; WEIGHT 50 WITH 999; IMAGE
  applies a hand-drawn radial filter to the Fourier transform of picture 50
XWIRES GRAPH SIZE 123
  outputs a 1-D picture with 123 evenly spaced samples taken from the function
  drawn
XWIRES GRAPH SAMPLING 1.3
  outputs a 1-D picture with function samples spaced 1.3 pixels apart
$
After the first point, any points you mark to the left of the displayed graph
(or its x-origin, if you are drawing a SYMM or ANTISYMM graph) are ignored;
similarly, any points you mark to the left of a previously marked point are
ignored.  You terminate the graph either by repeating a point, or by marking a
point beyond the right hand edge of the graph.  If you do not draw a graph
extending to both ends of the displayed graph, the end points of your graph
are continued in both directions.

The size of the output picture is the same as that of the displayed graph,
unless you use SIZE or SAMPLING (which are mutually exclusive, for obvious
reasons).  Its origin is recorded in the same position as that of the display
(rounded if necessary).
                                                      Form used internally: fp
$add ymod.command ymod perspective surface
You use YMOD to produce 'perspective' displays of pictures or picture
subregions, as line drawings in a display overlay representing intensity as
surface height.

Exx: YMOD 23 TO DIS:2
       presents picture 23 on the overlay of DIS:2
     YMOD TIMES 2
       presents the current picture, interpolated by a factor of 2 so as to
       fill out a sparse basic structure
     XWIRES REGION; MIN=0 MAX=2; YMOD PRESET @REGION LAYER 2
       presents the subregion of layer 2 indicated, scaling 0 and 2 to the
       bottom and top of the surface
$
You can display a (single-layer) subregion via the standard subregion
keys/options, as in the last example.

Display erasure and lettering is exactly the same for YMOD as it is for
DISPLAY.  The real and imaginary parts of Complex pictures are drawn one
beneath the other (real at the top).  Ymod displays cannot be annotated or
measured with a cursor.

If the MARK key is set, the limits of the source region are marked on the
indicated display picture.
                                    Restrictions: not 1-D
                                 Display marking: source region
                            Multi-layer pictures: single layer subregions only
                           Forms used internally: fp,complex

See also: ymod.syntax
$add ymod.syntax
Keys:
  [FROM]         picture to be displayed [SELECT]
  [TO]           output display picture [DISPLAY]
  SIZE(2)        dimensions of subregion to be displayed [whole picture]
  POSITION(2)    position/offset of subregion [0,0]
  LAYER          layer containing subregion [layer containing origin]
  TIMES          integral magnification factor for display [1]
  MARK           display to be marked with border indicating source region
                 [none]

Options:
  LEFT | RIGHT   display subregion abutting indicated border
  BOTTOM | TOP
  PRESET         use current values of MIN,MAX to set height limits [actual
                 min,max pixels present]
  LETTER         letter partition top with picture number etc. [YES]

See SUBREGIONS for more details of subregion keys/options.

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add zone.command zone zones_of_influence distance transforms
You use the ZONE command to generate the zones of influence associated with
the source image.  Each pixel in the output image is assigned the label of the
nearest labeled pixel in the source image.  By default, the source picture is
treated as a binary image and a labeled image is obtained from it (see the
LABEL command for details about the labeling process).  If the LABEL option is
set, the source image is treated as being already labeled.  Distances between
pixels are measured, by default, using the true Euclidean metric.  Faster and
possibly acceptable results can be obtained with simpler metrics by specifying
one of the options DIAMOND, SQUARE or OCTAGON (see the DT command to find out
more about distance transforms and metrics).

Exx: ZONE
       replaces the binary image in the current picture with the zones of
       influence associated with the connected foreground regions of the
       binary image
     ZONE 1 2 LABEL DIAMOND
       outputs to picture 2 the zones of influence associated with the labeled
       regions in picture 1 using the 4-connected, 'city block' metric
$
If the source picture is treated as a binary image (the default), a labeled
image is obtained from it in exactly the same way as the LABEL command.  By
default, the foreground regions are labelled.  You can use the options FG and
BG to control whether foreground and/or background regions are labeled.  Note
that foreground regions are treated as being 8-connected, whilst background
regions are 4-connected.

By specifying the LABEL option, you can suppress the labeling pass.  This
allows you to supply source images which have already been labeled, including
images generated by any of the classification commands (BOX, MINDISTANCE and
LIKELIHOOD).  Note that differently labeled regions are allowed to touch each
other.

Each pixel in the output picture is assigned the label of the nearest labeled
pixel.  If more than one region is equidistant from a given pixel, the pixel
is not labeled (set to zero).

Distances between pixels are calculated using one of several possible metrics.
By default, the exact Euclidean metric is used.  A simpler metric requiring
less computation, can be selected with one of the options DIAMOND, SQUARE or
OCTAGON.  For more details about the different metrics and distance
transforms, consult the documentation for the DT command.

See also: zone.syntax, dt, label, box, mindistance, likelihood
$add zone.syntax
Keys:
  [FROM]         source picture [SELECT]
  [TO]           destination picture [FROM]

Options:
  BINARY | LABEL treat source picture as binary/labeled image [BINARY]
  FG             if BINARY, label foreground regions [YES]
  BG             if BINARY, label background regions [NO]
  CIRCLE | DIAMOND | SQUARE | OCTAGON
                 use Euclidean/4-connected/8-connected/octagonal metric for
                 measuring distances [CIRCLE]

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add extras sg Silicon Graphics framestore display cache unix binary file format
Semper on a Silicon Graphics workstation supports the following features in
addition to the standard image processing facilities:

Command interface
-----------------

A scrolling terminal window is created on the screen pointed to by the
environment variable DISPLAY.  You can enter commands into this window and the
command line whenever it (or any other window created by Semper) has input
focus.  Previous commands can be recalled by pressing the up and down cursor
keys.  Characters can be inserted by first pressing the insert key or
Control-A.

Processing of commands can be abandoned by pressing Control-C.

You can specify the font and the foreground/background colours for the terminal
window by setting the environment varibles SEMPER_FONT, SEMPER_FG and SEMPER_BG
respectively.  Set SEMPER_FONT to the desired font name.  The font must be
fixed width.  Use the X11 command "xlsfonts" to find out what fixed width fonts
are available on your system.  SEMPER_FG and SEMPER_BG can be set to X11 colour
names (e.g. "black", "white", "slate blue", etc.) or to hexadecimal colour
specification strings.  Type the following Unix commands to make the font and
foreground/background colours the same as the workstation's Unix shell window:

    setenv SEMPER_FONT Screen15
    setenv SEMPER_FG   #d6d6d6
    setenv SEMPER_BG   #00003f

Image display window
--------------------

You can create a separate window for displaying images with the ASSIGN DISPLAY
command.  The window emulates a framestore.  You can display monochrome, false
colour and full colour images, depending on the graphics capapbilities of the
workstation.  There is support for 8 independent overlays for displaying
graphical output, rubberband lines and a cursor.  You can control the colour
and visibilty of each overlay with the OVERLAY command.

Menu interface window
---------------------

A separate window for displaying menus is created as required.  The window
supports up to 8 different menu colours.

Caching data in memory
----------------------

By default, all disc i/o associated with Semper's data storage devices
(picture discs, program libraries and help libraries) is cached in Semper's
disc cache in order to speed up access to the data.  The CACHE command allows
you to control the size and configuration of Semper's disc cache (you can even
turn off the disc cache by setting the size of the cache to zero) and to
create a separate memory buffer to cache all of the data in a Semper storage
device (MEMORY option).  You can also create temporary memory-based devices
with the ASSIGN MEMORY command.

Executing Unix commands
-----------------------

You can execute non-interactive Unix commands from within a Semper session
with the UNIX command.  Any text sent to standard output will be redirected to
Semper's console output stream.  All dependent processes will br terminated if
the UNIX command is abandoned.

Image file formats
------------------

The commands INPUT, OUTPUT, IPUT, IGET, EPUT, EGET, SPUT, SGET, ZPUT, ZGET and
HPLJ allow you to handle images in various file formats, in particular
Semper's binary image file format and Sun's raster file format (INPUT and
OUTPUT) and Silicon Graphics' image file format (IPUT and IGET).  The OUTPUT
command will also write grey-scale TIFF files.  The HPLJ command outputs
images to file in Hewlett-Packard's Laserjet format.

Frame grabber support
---------------------

If your workstation has an Imaging Technology FG100 frame grabber installed,
you can capture live images from a camera with the GRAB command.  The commands
VIDEO and ILUT allow you to configure the operation of the frame grabber.

Host-specific commands
----------------------

Here is a list of the commands which are specific to your Semper installation.
Consult the documentation for these commands for more details about their
operation.

    ASSIGN DISPLAY
    OVERLAY
    X11
    CACHE
    UNIX
    INPUT, OUTPUT
    EPUT, EGET
    IPUT, IGET
    SPUT, SGET
    ZPUT, ZGET
    HPLJ
    GRAB, ILUT, VIDEO
$add eput.command eput Eikonix
You use EPUT to write images to Type 2 Eikonix picture files.

Exx: EPUT 20 NAME 'eikpic'
       writes data to the Eikonix type 2 picture file 'eikpic' from picture
       20 on the current device.
     EPUT 20 NAME 'eikpic' NEW
       As for the above example but also allows an existing file named
       'eikpic' to be overwritten.

$
Files are created in the current directory, unless a pathname is given.

See also: eput.syntax, eget
$add eput.syntax
Keys:
  [FROM]         picture from which data is to be read [SELECT]
  NAME text      name of file to contain picture data  [none; prompts if
                 interactive]

Options:
  NEW            Allows an existing file of name NAME to be overwritten.

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add eget.command eget Eikonix
You use EGET to read images from Type 2 Eikonix picture files.

Exx: EGET 20 NAME 'eikpic'
       reads data from the Eikonix type 2 picture file 'eikpic' into picture
       20 on the current device.

$
Files are searched for in the current directory and then throughout the search
path.  You can give a full path name to avoid the path scan.

See also: eget.syntax, eput
$add eget.syntax
Keys:
  [TO]           picture into which data is to be read [SELECT]
  NAME text      name of file containing picture data  [none; prompts if
                 interactive]

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add iput.command iput sg image file
You use the command IPUT to output a Semper image to file using the Silicon
Graphics' image file format.  The file created can then be accessed by other
facilities like istat, icut, ipaste and snapshot (consult the corresponding
Unix manual entries for these).  The data written to file is run-length
encoded.

Exx: IPUT 3:2 NAME 'picture.img'
       writes picture 3:2 out to image file "picture.img"

See also: iput.syntax, iget
$add iput.syntax
Keys:
  [FROM]         source picture [SELECT]
  NAME text      name of file to which picture is to be written [prompts if
                 interactive]

Options:
  NEW            overwrite an existing output file

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add iget.command iget sg image file
You use the command IGET to read in an image stored in a file using Silicon
Graphics' image file format.  IGET can read compressed (run-length encoded)
images.  You can check the file header information for image files before
starting up Semper by using the istat command (see the corresponding Unix
manual entry for this).

Exx:  IGET DIS:1 NAME 'cat.rgb'
        transfers the image in file "cat.rgb" directly to display partition 1

See also: iget.syntax,iput
$add iget.syntax
Keys:
  [TO]           output picture [SELECT]
  NAME text      name of file from which picture is to be read [prompts if
                 interactive]

Options:
  AGAIN          If NAME omitted, and no write operations have taken place
                 since the last file read, use the last value of NAME

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add sput.command sput Stanford
You use SPUT to write out images in 'Stanford' format image files.

Exx: SPUT 20 NAME 'stanford_pic'
       writes data to the file 'stanford_pic' from picture
       20 on the current device.

     SPUT 20 NAME 'stanford_pic' NEW
       As for the above example but also allows an existing file named
       'stanford_pic' to be overwritten.

$
Files are created in the current directory, unless a pathname is given.

See also: sput.syntax, sget
$add sput.syntax
Keys:
  [FROM]         picture from which data is to be read [SELECT]
  NAME text      name of file to contain picture data  [none; prompts if
                 interactive]

Options:
  NEW            Allows an existing named file to be overwritten.

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add sget.command sget Stanford
You use SGET to read images from 'Stanford' format image files.

Exx: SGET 20 NAME 'stanford_pic'
       reads data from the file 'stanford_pic' into picture
       20 on the current device.

$
Files are searched for in the current directory and then throughout the search
path. You can give a full path name to avoid the path scan.

See also: sget.syntax, sput
$add sget.syntax
Keys:
  [TO]           picture into which data is to be read [SELECT]
  NAME text      name of file containing picture data  [none; prompts if
                 interactive]

Options:
  AGAIN          If NAME omitted, and no write operations have taken place
                 since the last file read, use the last value of NAME

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add zput.command zput Sarastro
You use ZPUT to write images into Sarastro binary file format.

Exx: ZPUT 20 NAME 'zimage'
       writes data to the Sarastro bianry file 'zimage' from picture
       20 on the current device.
     ZPUT 20 NAME 'zimage' NEW
       As for the above example but also allows an existing file named
       'zimage' to be overwritten.

$
Files are created in the current directory, unless a pathname is given.

See also: zput.syntax, zget
$add zput.syntax
Keys:
  [FROM]         picture from which data is to be read [SELECT]
  NAME text      name of file to contain picture data  [none; prompts if
                 interactive]

Options:
  NEW            Allows an existing file of name NAME to be overwritten.

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$add zget.command zget Sarastro
You use ZGET to read images from Sarastro binary image files.

Exx: ZGET 20 NAME 'zimage'
       reads data from the Sarastro binary image file 'zimage' into picture
       20 on the current device.

$
Files are searched for in the current directory and then throughout the search
path.  You can give a full path name to avoid the path scan.

See also: zget.syntax zput
$add zget.syntax
Keys:
  [TO]           picture into which data is to be read [SELECT]
  NAME text      name of file containing picture data  [none; prompts if
                 interactive]

See SYNTAX.NOTATION for explanation of notation used in -.syntax entries.
$end
